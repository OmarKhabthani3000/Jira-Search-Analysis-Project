Index: src/test/org/hibernate/search/test/FSDirectoryTest.java
===================================================================
*** src/test/org/hibernate/search/test/FSDirectoryTest.java	(revision 14525)
--- src/test/org/hibernate/search/test/FSDirectoryTest.java	(working copy)
***************
*** 99,105 ****
  		properties.put( "indexBase", root );
  		properties.put( "indexName", relative );
  
! 		File f = DirectoryProviderHelper.determineIndexDir( "name", properties );
  
  		assertTrue( new File( root ).exists() );
  
--- 99,105 ----
  		properties.put( "indexBase", root );
  		properties.put( "indexName", relative );
  
! 		File f = DirectoryProviderHelper.getVerifiedIndexDir( "name", properties );
  
  		assertTrue( new File( root ).exists() );
  
Index: src/java/org/hibernate/search/store/FSSlaveDirectoryProvider.java
===================================================================
*** src/java/org/hibernate/search/store/FSSlaveDirectoryProvider.java	(revision 14525)
--- src/java/org/hibernate/search/store/FSSlaveDirectoryProvider.java	(working copy)
***************
*** 14,21 ****
  import org.apache.lucene.analysis.standard.StandardAnalyzer;
  import org.apache.commons.logging.Log;
  import org.apache.commons.logging.LogFactory;
- import org.hibernate.HibernateException;
  import org.hibernate.AssertionFailure;
  import org.hibernate.search.util.FileHelper;
  import org.hibernate.search.util.DirectoryProviderHelper;
  import org.hibernate.search.engine.SearchFactoryImplementor;
--- 14,21 ----
  import org.apache.lucene.analysis.standard.StandardAnalyzer;
  import org.apache.commons.logging.Log;
  import org.apache.commons.logging.LogFactory;
  import org.hibernate.AssertionFailure;
+ import org.hibernate.search.SearchException;
  import org.hibernate.search.util.FileHelper;
  import org.hibernate.search.util.DirectoryProviderHelper;
  import org.hibernate.search.engine.SearchFactoryImplementor;
***************
*** 56,73 ****
  			throw new IllegalStateException("No current marker in source directory");
  		}
  		log.debug( "Source directory: " + source );
! 		indexDir = DirectoryProviderHelper.determineIndexDir( directoryProviderName, properties );
  		log.debug( "Index directory: " + indexDir.getPath() );
  		try {
- 			boolean create = !indexDir.exists();
- 			if (create) {
- 				log.debug( "index directory not found, creating: '" + indexDir.getAbsolutePath() + "'" );
- 				indexDir.mkdirs();
- 			}
  			indexName = indexDir.getCanonicalPath();
  		}
  		catch (IOException e) {
! 			throw new HibernateException( "Unable to initialize index: " + directoryProviderName, e );
  		}
  	}
  
--- 56,68 ----
  			throw new IllegalStateException("No current marker in source directory");
  		}
  		log.debug( "Source directory: " + source );
! 		indexDir = DirectoryProviderHelper.getVerifiedIndexDir( directoryProviderName, properties );
  		log.debug( "Index directory: " + indexDir.getPath() );
  		try {
  			indexName = indexDir.getCanonicalPath();
  		}
  		catch (IOException e) {
! 			throw new SearchException( "Unable to initialize index: " + directoryProviderName, e );
  		}
  	}
  
***************
*** 125,140 ****
  					FileHelper.synchronize( new File(sourceFile, String.valueOf(sourceCurrent) ), destinationFile, true);
  				}
  				catch (IOException e) {
! 					throw new HibernateException("Umable to synchonize directory: " + indexName, e);
  				}
  				if (! currentMarker.createNewFile() ) {
! 					throw new HibernateException("Unable to create the directory marker file: " + indexName);
  				}
  			}
  			log.debug( "Current directory: " + current);
  		}
  		catch (IOException e) {
! 			throw new HibernateException( "Unable to initialize index: " + directoryProviderName, e );
  		}
  		timer = new Timer(true); //daemon thread, the copy algorithm is robust
  		TimerTask task = new TriggerTask(source, indexName);
--- 120,135 ----
  					FileHelper.synchronize( new File(sourceFile, String.valueOf(sourceCurrent) ), destinationFile, true);
  				}
  				catch (IOException e) {
! 					throw new SearchException("Unable to synchronize directory: " + indexName, e);
  				}
  				if (! currentMarker.createNewFile() ) {
! 					throw new SearchException("Unable to create the directory marker file: " + indexName);
  				}
  			}
  			log.debug( "Current directory: " + current);
  		}
  		catch (IOException e) {
! 			throw new SearchException( "Unable to initialize index: " + directoryProviderName, e );
  		}
  		timer = new Timer(true); //daemon thread, the copy algorithm is robust
  		TimerTask task = new TriggerTask(source, indexName);
Index: src/java/org/hibernate/search/store/FSMasterDirectoryProvider.java
===================================================================
*** src/java/org/hibernate/search/store/FSMasterDirectoryProvider.java	(revision 14525)
--- src/java/org/hibernate/search/store/FSMasterDirectoryProvider.java	(working copy)
***************
*** 15,24 ****
  import org.apache.lucene.analysis.standard.StandardAnalyzer;
  import org.apache.commons.logging.Log;
  import org.apache.commons.logging.LogFactory;
  import org.hibernate.search.util.DirectoryProviderHelper;
  import org.hibernate.search.util.FileHelper;
  import org.hibernate.search.engine.SearchFactoryImplementor;
- import org.hibernate.HibernateException;
  
  /**
   * File based DirectoryProvider that takes care of index copy
--- 15,24 ----
  import org.apache.lucene.analysis.standard.StandardAnalyzer;
  import org.apache.commons.logging.Log;
  import org.apache.commons.logging.LogFactory;
+ import org.hibernate.search.SearchException;
  import org.hibernate.search.util.DirectoryProviderHelper;
  import org.hibernate.search.util.FileHelper;
  import org.hibernate.search.engine.SearchFactoryImplementor;
  
  /**
   * File based DirectoryProvider that takes care of index copy
***************
*** 54,77 ****
  		if ( source == null)
  			throw new IllegalStateException("FSMasterDirectoryProvider requires a viable source directory");
  		log.debug( "Source directory: " + source );
! 		indexDir = DirectoryProviderHelper.determineIndexDir( directoryProviderName, properties );
  		log.debug( "Index directory: " + indexDir );
  		try {
- 			boolean create = !indexDir.exists();
- 			if (create) {
- 				log.debug( "index directory not found, creating: '" + indexDir.getAbsolutePath() + "'" );
- 				indexDir.mkdirs();
- 			}
  			indexName = indexDir.getCanonicalPath();
! 			directory = FSDirectory.getDirectory( indexName);
! 			if ( create ) {
  				log.debug( "Initialize index: '" + indexName + "'" );
! 				IndexWriter iw = new IndexWriter( directory, new StandardAnalyzer(), create );
  				iw.close();
  			}
- 		}
  		catch (IOException e) {
! 			throw new HibernateException( "Unable to initialize index: " + directoryProviderName, e );
  		}
  		this.searchFactory = searchFactoryImplementor;
  	}
--- 54,70 ----
  		if ( source == null)
  			throw new IllegalStateException("FSMasterDirectoryProvider requires a viable source directory");
  		log.debug( "Source directory: " + source );
! 		indexDir = DirectoryProviderHelper.getVerifiedIndexDir( directoryProviderName, properties );
  		log.debug( "Index directory: " + indexDir );
  		try {
  			indexName = indexDir.getCanonicalPath();
! 			directory = FSDirectory.getDirectory( indexDir );
  			log.debug( "Initialize index: '" + indexName + "'" );
! 			IndexWriter iw = new IndexWriter( directory, new StandardAnalyzer() );
  			iw.close();
  		}
  		catch (IOException e) {
! 			throw new SearchException( "Unable to initialize index: " + directoryProviderName, e );
  		}
  		this.searchFactory = searchFactoryImplementor;
  	}
***************
*** 104,110 ****
  			log.debug( "Current directory: " + current);
  		}
  		catch (IOException e) {
! 			throw new HibernateException( "Unable to initialize index: " + directoryProviderName, e );
  		}
  		timer = new Timer(true); //daemon thread, the copy algorithm is robust
  		TimerTask task = new FSMasterDirectoryProvider.TriggerTask(indexName, source, this );
--- 97,103 ----
  			log.debug( "Current directory: " + current);
  		}
  		catch (IOException e) {
! 			throw new SearchException( "Unable to initialize index: " + directoryProviderName, e );
  		}
  		timer = new Timer(true); //daemon thread, the copy algorithm is robust
  		TimerTask task = new FSMasterDirectoryProvider.TriggerTask(indexName, source, this );
Index: src/java/org/hibernate/search/store/FSDirectoryProvider.java
===================================================================
*** src/java/org/hibernate/search/store/FSDirectoryProvider.java	(revision 14525)
--- src/java/org/hibernate/search/store/FSDirectoryProvider.java	(working copy)
***************
*** 28,49 ****
  	private String indexName;
  
  	public void initialize(String directoryProviderName, Properties properties, SearchFactoryImplementor searchFactoryImplementor) {
! 		File indexDir = DirectoryProviderHelper.determineIndexDir( directoryProviderName, properties );
  		try {
- 			boolean create = !indexDir.exists();
- 			if (create) {
- 				log.debug( "index directory not found, creating: '" + indexDir.getAbsolutePath() + "'" );
- 				indexDir.mkdirs();
- 			}
  			indexName = indexDir.getCanonicalPath();
! 			directory = FSDirectory.getDirectory( indexName );
  			//this is cheap so it's not done in start()
- 			if ( create ) {
  				log.debug( "Initialize index: '" + indexName + "'" );
! 				IndexWriter iw = new IndexWriter( directory, new StandardAnalyzer(), create );
  				iw.close();
  			}
- 		}
  		catch (IOException e) {
  			throw new HibernateException( "Unable to initialize index: " + directoryProviderName, e );
  		}
--- 28,42 ----
  	private String indexName;
  
  	public void initialize(String directoryProviderName, Properties properties, SearchFactoryImplementor searchFactoryImplementor) {
! 		File indexDir = DirectoryProviderHelper.getVerifiedIndexDir( directoryProviderName, properties );
  		try {
  			indexName = indexDir.getCanonicalPath();
! 			directory = FSDirectory.getDirectory( indexDir );
  			//this is cheap so it's not done in start()
  			log.debug( "Initialize index: '" + indexName + "'" );
! 			IndexWriter iw = new IndexWriter( directory, new StandardAnalyzer() );
  			iw.close();
  		}
  		catch (IOException e) {
  			throw new HibernateException( "Unable to initialize index: " + directoryProviderName, e );
  		}
Index: src/java/org/hibernate/search/util/DirectoryProviderHelper.java
===================================================================
*** src/java/org/hibernate/search/util/DirectoryProviderHelper.java	(revision 14525)
--- src/java/org/hibernate/search/util/DirectoryProviderHelper.java	(working copy)
***************
*** 4,12 ****
  import java.util.Properties;
  import java.io.File;
  import java.io.IOException;
- import java.text.MessageFormat;
  
- import org.hibernate.HibernateException;
  import org.hibernate.AssertionFailure;
  import org.hibernate.search.SearchException;
  import org.hibernate.annotations.common.util.StringHelper;
--- 4,10 ----
***************
*** 15,20 ****
--- 13,19 ----
  
  /**
   * @author Emmanuel Bernard
+  * @author Sanne Grinovero
   */
  public class DirectoryProviderHelper {
  	private static Log log = LogFactory.getLog( DirectoryProviderHelper.class );
***************
*** 34,93 ****
  							+ " and " + relativePropertyName + " " + relative != null ? relative : "<null>"
  			);
  		}
! 		if (relative == null) relative = directoryProviderName;
  		if ( StringHelper.isEmpty( root ) ) {
  			log.debug( "No root directory, go with relative " + relative );
! 			File sourceFile = new File(relative);
! 			if ( ! sourceFile.exists() ) {
! 				throw new SearchException("Unable to read source directory: " + relative);
  			}
  			//else keep source as it
  		}
  		else {
! 			File rootDir = new File(root);
! 			if ( ! rootDir.exists() ) {
! 				rootDir.mkdirs();
! 			}
! 			else if ( ! rootDir.isDirectory() ) {
! 				throw new SearchException(rootPropertyName + " is not a directory");
! 			}
! 			//test it again in case mkdir failed for wrong reasons
! 			if ( rootDir.exists() ) {
! 				File sourceFile = new File(root, relative);
! 				if (! sourceFile.exists() ) sourceFile.mkdirs();
! 				log.debug( "Get directory from root + relative");
  				try {
  					relative = sourceFile.getCanonicalPath();
  				}
  				catch (IOException e) {
! 					throw new AssertionFailure("Unable to get canonical path: " + root + " + " + relative);
! 				}
! 			}
! 			else {
! 				throw new SearchException(rootPropertyName + " does not exist and cannot be created");
  			}
  		}
  		return relative;
  	}
  
! 	public static File determineIndexDir(String directoryProviderName, Properties properties) {
  		String indexBase = properties.getProperty( "indexBase", "." );
  		String indexName = properties.getProperty( "indexName", directoryProviderName );
  		File indexDir = new File( indexBase );
! 		if ( ! indexDir.exists() ) {
! 			//if the base directory does not exist, create it
! 			//we do not fear concurrent creation since mkdir does not raise exceptions
! 			indexDir.mkdirs();
! 		}
! 		else if ( ! indexDir.isDirectory() ) {
! 			throw new SearchException( MessageFormat.format( "Index directory is not a directory: {0}", indexBase ) );
! 		}
! 		if ( !indexDir.canWrite() ) {
! 			throw new SearchException( "Cannot write into index directory: "
! 					+ ( indexDir.isAbsolute() ? indexBase : indexDir.getAbsolutePath() ) );
! 		}
! 
  		indexDir = new File( indexDir, indexName );
  		return indexDir;
  	}
  }
--- 33,97 ----
  							+ " and " + relativePropertyName + " " + relative != null ? relative : "<null>"
  			);
  		}
! 		if ( relative == null ) relative = directoryProviderName;
  		if ( StringHelper.isEmpty( root ) ) {
  			log.debug( "No root directory, go with relative " + relative );
! 			File sourceFile = new File( relative );
! 			if ( ! sourceFile.isDirectory() ) { // this also tests for existence
! 				throw new SearchException( "Unable to read source directory: " + relative );
  			}
  			//else keep source as it
  		}
  		else {
! 			File rootDir = new File( root );
! 			makeSanityCheckedDirectory( rootDir, directoryProviderName );
! 			File sourceFile = new File( root, relative );
! 			makeSanityCheckedDirectory( sourceFile, directoryProviderName );
! 			log.debug( "Get directory from root + relative" );
  			try {
  				relative = sourceFile.getCanonicalPath();
  			}
  			catch (IOException e) {
! 				throw new AssertionFailure( "Unable to get canonical path: " + root + " + " + relative );
  			}
  		}
+ 		assert relative!=null;
  		return relative;
  	}
  
! 	public static File getVerifiedIndexDir(String directoryProviderName, Properties properties) {
  		String indexBase = properties.getProperty( "indexBase", "." );
  		String indexName = properties.getProperty( "indexName", directoryProviderName );
  		File indexDir = new File( indexBase );
! 		makeSanityCheckedDirectory( indexDir, directoryProviderName );
  		indexDir = new File( indexDir, indexName );
+ 		makeSanityCheckedDirectory( indexDir, directoryProviderName );
  		return indexDir;
  	}
+ 	
+ 	private static void makeSanityCheckedDirectory(File indexDir, String directoryProviderName) {
+ 		if ( ! indexDir.exists() ) {
+ 			log.warn("Index directory not found, creating: '" + indexDir.getAbsolutePath() + "'");
+ 			//if not existing, create the full path
+ 			if ( ! indexDir.mkdirs() ) {
+ 				throw new SearchException("Unable to create index directory: "
+ 						+ indexDir.getAbsolutePath() + " for index "
+ 						+ directoryProviderName);
+ 			}
+ 		} else {
+ 			// else check it is not a file
+ 			if ( ! indexDir.isDirectory() ) {
+ 				throw new SearchException("Unable to initialize index: "
+ 						+ directoryProviderName + ": "
+ 						+ indexDir.getAbsolutePath() + " is a file.");
+ 			}
+ 		}
+ 		// and ensure it's writable
+ 		if ( ! indexDir.canWrite() ) {
+ 			throw new SearchException("Cannot write into index directory: "
+ 					+ indexDir.getAbsolutePath() + " for index "
+ 					+ directoryProviderName);
+ 		}
+ 	}
+ 	
  }
