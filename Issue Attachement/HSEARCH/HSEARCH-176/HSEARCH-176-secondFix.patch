Index: src/java/org/hibernate/search/backend/LuceneIndexingParameters.java
===================================================================
--- src/java/org/hibernate/search/backend/LuceneIndexingParameters.java	(revision 14501)
+++ src/java/org/hibernate/search/backend/LuceneIndexingParameters.java	(working copy)
@@ -9,6 +9,7 @@
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.apache.lucene.index.IndexWriter;
+import org.hibernate.search.SearchException;
 import org.hibernate.search.backend.configuration.IndexWriterSetting;
 
 /**
@@ -28,8 +29,8 @@
 	// value keyword
 	public static final String EXPLICIT_DEFAULT_VALUE = "default"; 
 	// property path keywords
-	public static final String BATCH = "batch.";
-	public static final String TRANSACTION = "transaction.";
+	public static final String BATCH = "batch";
+	public static final String TRANSACTION = "transaction";
 	
 	private final ParameterSet transactionIndexParameters;
 	private final ParameterSet batchIndexParameters;
@@ -40,11 +41,11 @@
 		//don't iterate on property entries we know all the keys:
 		for ( IndexWriterSetting t : IndexWriterSetting.values() ) {
 			String key = t.getKey();
-			String trxValue = sourceProps.getProperty( TRANSACTION + key );
+			String trxValue = sourceProps.getProperty( TRANSACTION + "." + key );
 			if (trxValue != null) {
 				transactionProps.setProperty( key, trxValue );
 			}
-			String batchValue = sourceProps.getProperty( BATCH + key );
+			String batchValue = sourceProps.getProperty( BATCH + "." + key );
 			if (batchValue != null) {
 				batchProps.setProperty( key, batchValue );
 			}
@@ -80,14 +81,14 @@
 		 * @param writer the IndexWriter whereto the parameters will be applied.
 		 */
 		public void applyToWriter(IndexWriter writer) {
-			try {
-				for ( Map.Entry<IndexWriterSetting,Integer> entry : parameters.entrySet() ) {
+			for ( Map.Entry<IndexWriterSetting,Integer> entry : parameters.entrySet() ) {
+				try {
 					entry.getKey().applySetting( writer, entry.getValue() );
+				} catch ( IllegalArgumentException e ) {
+					//TODO if DirectoryProvider had getDirectoryName() exceptions could tell better
+					throw new SearchException( "Illegal IndexWriter setting "
+							+ entry.getKey().getKey() + " "+ e.getMessage(), e );
 				}
-			} catch (IllegalArgumentException e) {
-				//FIXME shouldn't we raise an exception instead
-				log.error( "Illegal IndexWriter setting" + e.getMessage()
-						+ ". Will use default settings." );
 			}
 		}
 		
Index: src/java/org/hibernate/search/store/DirectoryProviderFactory.java
===================================================================
--- src/java/org/hibernate/search/store/DirectoryProviderFactory.java	(revision 14501)
+++ src/java/org/hibernate/search/store/DirectoryProviderFactory.java	(working copy)
@@ -7,6 +7,7 @@
 import java.util.Map;
 import java.util.Properties;
 import java.util.concurrent.locks.ReentrantLock;
+import java.util.regex.Pattern;
 
 import org.hibernate.HibernateException;
 import org.hibernate.annotations.common.reflection.ReflectionManager;
@@ -202,18 +203,26 @@
 	 * If the index is sharded, the Properties index matches the shard index
 	 */	
 	private static Properties[] getDirectoryProperties(Configuration cfg, String directoryProviderName) {
+		Pattern dotPattern = Pattern.compile( "\\." );
 		Properties cfgAndImplicitProperties = new Properties();
-		// fcg has no defaults, so we may use keySet iteration
+		// cfg has no defaults, so we may use keySet iteration
 		//FIXME not so sure about that cfg.setProperties()?
 		for ( Map.Entry entry : cfg.getProperties().entrySet() ) {
 			String key = entry.getKey().toString();// casting to String
 			if ( key.startsWith( LUCENE_PREFIX ) ) {
 				//put regular properties and add an explicit batch property when a transaction property is set
 				cfgAndImplicitProperties.put( key, entry.getValue() );
-				if ( key.contains( LuceneIndexingParameters.TRANSACTION ) ) {
-					//FIXME fix that transaction can appear in the index name
-					//I imagine checking the last '.transaction.' is safe.
-					String additionalKey = key.replaceFirst(LuceneIndexingParameters.TRANSACTION, LuceneIndexingParameters.BATCH);
+				//be careful to replace only the intended ".transaction." with ".batch.":
+				String[] splitKey = dotPattern.split( key );
+				if ( splitKey.length > 2 && splitKey[ splitKey.length - 2 ]
+				                                      .equals( LuceneIndexingParameters.TRANSACTION ) ) {
+					splitKey[ splitKey.length - 2 ] = LuceneIndexingParameters.BATCH;
+					StringBuilder missingKeyBuilder = new StringBuilder( splitKey[0] );
+					for (int i = 1; i < splitKey.length; i++) {
+						missingKeyBuilder.append( "." );
+						missingKeyBuilder.append( splitKey[i] );
+					}
+					String additionalKey = missingKeyBuilder.toString();
 					if ( cfg.getProperty(additionalKey) == null ){
 						cfgAndImplicitProperties.put(additionalKey, cfg.getProperty(key) );
 					}
