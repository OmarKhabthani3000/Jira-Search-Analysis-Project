Index: query_sql.xml
===================================================================
RCS file: /cvsroot/hibernate/Hibernate3/doc/reference/en/modules/query_sql.xml,v
retrieving revision 1.7
diff -u -r1.7 query_sql.xml
--- query_sql.xml	28 Feb 2005 12:43:52 -0000	1.7
+++ query_sql.xml	17 Mar 2005 13:28:46 -0000
@@ -1,4 +1,4 @@
-<chapter id="querysql" revision="1">
+<chapter id="querysql" revision="2">
     <title>Native SQL</title>
 
     <para>
@@ -9,8 +9,8 @@
     </para>
 
     <para>
-        Hibernate3 allows you to specify handwritten SQL for all create, update, delete, and load
-        operations.
+        Hibernate3 allows you to specify handwritten SQL (including stored procedures) for 
+        all create, update, delete, and load operations. 
     </para>
 
     <sect1 id="querysql-creating">
@@ -76,6 +76,8 @@
             <literal>Cat</literal>s from a different table (<literal>cat_log</literal>) to the one 
             declared in the mapping metadata. Notice that we may even use the property aliases in the 
             where clause if we like.
+            
+            The <literal>{}</literal>-syntax is not required for named queries. See more in <xref linkend="querysql-namedqueries"/>
         </para>
 
         <programlisting><![CDATA[String sql = "select cat.originalId as {cat.id}, " +
@@ -95,7 +97,7 @@
 
     </sect1>
     
-    <sect1 id="querysql-namedqueries" revision="1">
+    <sect1 id="querysql-namedqueries" revision="2">
         <title>Named SQL queries</title>
 
         <para>
@@ -134,6 +136,99 @@
              elements are used to join associations and define queries which initialize collections,
              respectively. TODO!
          </para>
+         
+         <sect2 id="fieldresults">
+         	<title>Using fieldresult to explicitly specify column/alias names</title>
+         	
+         	<para>
+         		With <literal>&lt;fieldresult&gt;</literal> you can explicitly tell Hibernate what columns
+         		to use as opposed to use <literal>{}</literal>-syntax to let Hibernate inject its own aliases.         		
+         	</para>
+         	
+        	<programlisting><![CDATA[<sql-query name="mySqlQuery">
+    <return alias="person" class="eg.Person">
+      <fieldresult name="name" column="myName"/>
+      <fieldresult name="age" column="myAge"/>
+      <fieldresult name="sex" column="mySex"/>
+    </return>
+    SELECT person.NAME AS myName,
+           person.AGE AS myAge,
+           person.SEX AS mySex,
+    FROM PERSON person WHERE person.NAME LIKE :name
+</sql-query>
+]]></programlisting>
+         	
+         	<literal>&lt;fieldresult&gt;</literal> also works with multiple columns. This solves a limitation with
+         	the <literal>{}</literal>-syntax which can not allow fine grained control of multi-column properties.
+         	
+         	<programlisting><![CDATA[<sql-query name="organizationCurrentEmployments">
+            <return alias="emp" class="Employment">		    
+             <fieldresult name="salary"> 
+               <resultcolumn name="VALUE"/>
+			   <resultcolumn name="CURRENCY"/>			
+			 </fieldresult>
+			 <fieldresult name="endDate" column="myEndDate"/>
+		    </return>
+            SELECT EMPLOYEE AS {emp.employee}, EMPLOYER AS {emp.employer}, 
+            STARTDATE AS {emp.startDate}, ENDDATE AS {emp.endDate},
+            REGIONCODE as {emp.regionCode}, EID AS {emp.id}, VALUE, CURRENCY
+            FROM EMPLOYMENT
+            WHERE EMPLOYER = :id AND ENDDATE IS NULL
+            ORDER BY STARTDATE ASC
+</sql-query>]]></programlisting>
+         	
+         	Notice that in this example we used <literal>&lt;fieldresult&gt;</literal> in combination
+         	with the <literal>{}</literal>-syntax for injection. Allowing users to choose 
+         	how they want to refer column and properties.
+         </sect2>
+         
+         <sect2 id="sp_query">
+         	<title>Using stored procedures for querying</title>
+         	
+         	<para>
+         		Hibernate 3 introduces support for queries via stored procedures. 
+         		
+         		The stored procedures must return a resultset as the first out-parameter to be able to work with Hibernate. 
+         		
+         		An example of such a stored procedure in Oracle 9 and higher is as follows:
+         		
+         		<programlisting><![CDATA[CREATE OR REPLACE FUNCTION selectAllEmployments 
+    RETURN SYS_REFCURSOR 
+AS 
+    st_cursor SYS_REFCURSOR; 
+BEGIN 
+    OPEN st_cursor FOR 
+ SELECT EMPLOYEE, EMPLOYER, 
+ STARTDATE, ENDDATE, 
+ REGIONCODE, EID, VALUE, CURRENCY 
+ FROM EMPLOYMENT; 
+	  RETURN  st_cursor; 
+ END;]]></programlisting>
+         		
+         		To use this query in Hibernate you need to map it via a named query.
+         		
+         			<programlisting><![CDATA[<sql-query name="selectAllEmployees_SP" callable="true">
+		<return alias="emp" class="Employment">
+			<fieldresult name="employee" column="EMPLOYEE"/>
+			<fieldresult name="employer" column="EMPLOYER"/>			
+			<fieldresult name="startDate" column="STARTDATE"/>
+			<fieldresult name="endDate" column="ENDDATE"/>			
+			<fieldresult name="regionCode" column="REGIONCODE"/>			
+			<fieldresult name="id" column="EID"/>						
+			<fieldresult name="salary"> 
+  			  <resultcolumn name="VALUE"/>
+			  <resultcolumn name="CURRENCY"/>			
+			</fieldresult>
+		</return>
+	 { ? = call selectAllEmployments() }
+	</sql-query>]]></programlisting>
+         	</para>
+         	
+         	<para>
+         	Notice stored procedures currently only return scalars and entities. <literal>&gt;return-join&lt;</literal> and
+         	<literal>&gt;load-collection&lt;</literal> is not supported.
+         	</para>
+         </sect2>
 
     </sect1>
 
@@ -160,7 +255,8 @@
 
         <para>
             The SQL is directly executed in your database, so you are free to use any dialect
-            you like.
+            you like. This will of course reduce the portability of your mapping if you use database
+            specific SQL.
         </para>
 
         <para>
@@ -177,6 +273,17 @@
     <sql-update callable="true">{? = call updatePerson (?, ?)}</sql-update>
 </class>]]></programlisting>
 
+		<para>
+		  The order of the positional parameters are currently vital, as they must be in 
+		  the same sequence as Hibernate expects them.
+		</para>
+		
+		<para>
+		  You can see the expected order by enabling debug logging for the <literal>org.hiberante.persister.entity</literal>
+		  level. With this level enabled Hibernate will print out the static SQL that is used to create, update, delete etc. entities.
+		  To see the expected sequence, remember to not include your custom SQL in the mapping files as that will override the Hibernate generated static sql.		  
+		</para>
+
         <para>
             The stored procedures are in most cases (read: better do it than not) required to
             return the number of rows inserted/updated/deleted, as Hibernate has some runtime
@@ -198,6 +305,7 @@
 
 END updatePerson;]]></programlisting>
 
+		
     </sect1>
 
     <sect1 id="querysql-load">
@@ -224,6 +332,10 @@
     <property name="name" not-null="true"/>
     <loader query-ref="person"/>
 </class>]]></programlisting>
+	
+		<para>
+			And this also works with stored procedures.
+		</para>
 
         <para>
             TODO: Document the following example for collection loader.
