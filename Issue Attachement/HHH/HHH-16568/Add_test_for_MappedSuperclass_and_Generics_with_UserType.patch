Subject: [PATCH] Add test for MappedSuperclass and Generics with UserType
---
Index: hibernate-core/src/test/java/org/hibernate/orm/test/annotations/generics/MappedSuperclassAndGenericsWithUserTypeTest.java
===================================================================
diff --git a/hibernate-core/src/test/java/org/hibernate/orm/test/annotations/generics/MappedSuperclassAndGenericsWithUserTypeTest.java b/hibernate-core/src/test/java/org/hibernate/orm/test/annotations/generics/MappedSuperclassAndGenericsWithUserTypeTest.java
new file mode 100644
--- /dev/null	(revision f20c3e5aacd6473d193b946c308fcac214fffb86)
+++ b/hibernate-core/src/test/java/org/hibernate/orm/test/annotations/generics/MappedSuperclassAndGenericsWithUserTypeTest.java	(revision f20c3e5aacd6473d193b946c308fcac214fffb86)
@@ -0,0 +1,149 @@
+package org.hibernate.orm.test.annotations.generics;
+
+import jakarta.persistence.Entity;
+import jakarta.persistence.GeneratedValue;
+import jakarta.persistence.GenerationType;
+import jakarta.persistence.Id;
+import jakarta.persistence.MappedSuperclass;
+import java.io.Serializable;
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.sql.Types;
+import org.hibernate.annotations.Type;
+import org.hibernate.engine.spi.SharedSessionContractImplementor;
+import org.hibernate.testing.orm.junit.DomainModel;
+import org.hibernate.testing.orm.junit.SessionFactory;
+import org.hibernate.testing.orm.junit.SessionFactoryScope;
+import org.hibernate.usertype.UserType;
+import org.junit.jupiter.api.Test;
+
+@DomainModel(annotatedClasses = {MappedSuperclassAndGenericsWithUserTypeTest.StringEntity.class})
+@SessionFactory
+class MappedSuperclassAndGenericsWithUserTypeTest {
+
+  public enum MyEnum {
+    LONG(1),
+    STRING(2);
+
+    private final int ordinal;
+
+    MyEnum(final int ordinal) {
+      this.ordinal = ordinal;
+    }
+
+    public int getOrdinal() {
+      return this.ordinal;
+    }
+  }
+
+  @Test
+  void testIt(SessionFactoryScope scope) {
+    scope.inTransaction(
+        session -> {
+          session.persist(new StringEntity());
+        });
+  }
+
+  @MappedSuperclass
+  public abstract static class ParameterizedParent<L> {
+    public ParameterizedParent(MyEnum myEnum) {
+      this.myEnum = myEnum;
+    }
+
+    @Type(MyEnumUserType.class)
+    private MyEnum myEnum;
+  }
+
+  @Entity
+  public static class StringEntity extends ParameterizedParent<String> {
+    @Id
+    @GeneratedValue(strategy = GenerationType.SEQUENCE)
+    private Long id;
+
+    public StringEntity() {
+      super(MyEnum.STRING);
+    }
+  }
+
+  public static class MyEnumUserType implements UserType<MyEnum> {
+    @Override
+    public int getSqlType() {
+      return Types.SMALLINT;
+    }
+
+    @Override
+    public Class<MyEnum> returnedClass() {
+      return MyEnum.class;
+    }
+
+    @Override
+    public MyEnum nullSafeGet(
+        final ResultSet resultSet,
+        final int position,
+        final SharedSessionContractImplementor session,
+        final Object owner)
+        throws SQLException {
+      final int val = resultSet.getInt(position);
+      for (MyEnum element : MyEnum.values()) {
+        if (element.getOrdinal() == val) {
+          return element;
+        }
+      }
+      return null;
+    }
+
+    public void nullSafeSet(
+        final PreparedStatement statement,
+        final MyEnum value,
+        final int index,
+        final SharedSessionContractImplementor session)
+        throws SQLException {
+      if (value == null) {
+        statement.setNull(index, Types.SMALLINT);
+      } else {
+        statement.setInt(index, value.getOrdinal());
+      }
+    }
+
+    public MyEnum deepCopy(final MyEnum value) {
+      return value;
+    }
+
+    @Override
+    public boolean isMutable() {
+      return false;
+    }
+
+    @Override
+    public MyEnum assemble(final Serializable cached, final Object owner) {
+      return (MyEnum) cached;
+    }
+
+    @Override
+    public Serializable disassemble(final MyEnum value) {
+      return value;
+    }
+
+    @Override
+    public MyEnum replace(final MyEnum detached, final MyEnum managed, final Object owner) {
+      return detached;
+    }
+
+    @Override
+    public int hashCode(final MyEnum value) {
+      return value.hashCode();
+    }
+
+    @Override
+    public boolean equals(final MyEnum value1, final MyEnum value2) {
+      if ((value1 == null) && (value2 == null)) {
+        return true;
+      }
+      if ((null == value1) || (null == value2)) {
+        return false;
+      }
+      return value1.equals(value2);
+    }
+  }
+}
