### Eclipse Workspace Patch 1.0
#P hibernateGen
Index: src/org/hibernate/hql/ast/util/LiteralProcessor.java
===================================================================
RCS file: /cvs/repository/edms/hibernateGen/src/org/hibernate/hql/ast/util/LiteralProcessor.java,v
retrieving revision 1.1
diff -u -r1.1 LiteralProcessor.java
--- src/org/hibernate/hql/ast/util/LiteralProcessor.java	6 Jun 2008 18:32:55 -0000	1.1
+++ src/org/hibernate/hql/ast/util/LiteralProcessor.java	2 Sep 2008 23:17:01 -0000
@@ -1,4 +1,4 @@
-// $Id: LiteralProcessor.java,v 1.1 2008/06/06 18:32:55 chipm Exp $
+// $Id: LiteralProcessor.java 11258 2007-03-07 22:41:22Z steve.ebersole@jboss.com $
 package org.hibernate.hql.ast.util;
 
 import java.math.BigDecimal;
@@ -53,7 +53,7 @@
 	 * 
 	 * @see #EXACT, #APPROXIMATE
 	 */
-	public static int DECIMAL_LITERAL_FORMAT = EXACT;
+	public static int DECIMAL_LITERAL_FORMAT = LiteralProcessor.EXACT;
 
 	private static final Log log = LogFactory.getLog(LiteralProcessor.class);
 
@@ -68,7 +68,7 @@
 
 	public boolean isAlias(String alias)
 	{
-		FromClause from = walker.getCurrentFromClause();
+		FromClause from = this.walker.getCurrentFromClause();
 		while(from.isSubQuery())
 		{
 			if(from.containsClassAlias(alias))
@@ -84,16 +84,22 @@
 	public void processConstant(AST constant, boolean resolveIdent) throws SemanticException
 	{
 		// If the constant is an IDENT, figure out what it means...
-		boolean isIdent = (constant.getType() == IDENT || constant.getType() == WEIRD_IDENT);
-		if(resolveIdent && isIdent && isAlias(constant.getText()))
-		{ // IDENT is a class alias in the FROM.
+		boolean isIdent = (constant.getType() == HqlSqlTokenTypes.IDENT || constant.getType() == HqlSqlTokenTypes.WEIRD_IDENT);
+		if(resolveIdent && isIdent && this.isAlias(constant.getText()))
+		{ // IDENT
+																																						// is a
+																																						// class
+																																						// alias
+																																						// in
+																																						// the
+																																						// FROM.
 			IdentNode ident = (IdentNode) constant;
 			// Resolve to an identity column.
 			ident.resolve(false, true);
 		}
 		else
 		{ // IDENT might be the name of a class.
-			Queryable queryable = walker.getSessionFactoryHelper().findQueryableUsingImports(constant.getText());
+			Queryable queryable = this.walker.getSessionFactoryHelper().findQueryableUsingImports(constant.getText());
 			if(isIdent && queryable != null)
 			{
 				constant.setText(queryable.getDiscriminatorSQLValue());
@@ -101,7 +107,7 @@
 			// Otherwise, it's a literal.
 			else
 			{
-				processLiteral(constant);
+				this.processLiteral(constant);
 			}
 		}
 	}
@@ -110,7 +116,7 @@
 	public void lookupConstant(DotNode node) throws SemanticException
 	{
 		String text = ASTUtil.getPathText(node);
-		Queryable persister = walker.getSessionFactoryHelper().findQueryableUsingImports(text);
+		Queryable persister = this.walker.getSessionFactoryHelper().findQueryableUsingImports(text);
 		if(persister != null)
 		{
 			// the name of an entity class
@@ -124,7 +130,8 @@
 			}
 			else
 			{
-				setSQLValue(node, text, discrim); // the class discriminator value
+				this.setSQLValue(node, text, discrim); // the class discriminator
+																									// value
 			}
 		}
 		else
@@ -136,7 +143,7 @@
 			}
 			else
 			{
-				setConstantValue(node, text, value);
+				this.setConstantValue(node, text, value);
 			}
 		}
 	}
@@ -144,9 +151,9 @@
 
 	private void setSQLValue(DotNode node, String text, String value)
 	{
-		if(log.isDebugEnabled())
+		if(LiteralProcessor.log.isDebugEnabled())
 		{
-			log.debug("setSQLValue() " + text + " -> " + value);
+			LiteralProcessor.log.debug("setSQLValue() " + text + " -> " + value);
 		}
 		node.setFirstChild(null); // Chop off the rest of the tree.
 		node.setType(SqlTokenTypes.SQL_TOKEN);
@@ -157,9 +164,10 @@
 
 	private void setConstantValue(DotNode node, String text, Object value)
 	{
-		if(log.isDebugEnabled())
+		if(LiteralProcessor.log.isDebugEnabled())
 		{
-			log.debug("setConstantValue() " + text + " -> " + value + " " + value.getClass().getName());
+			LiteralProcessor.log.debug("setConstantValue() " + text + " -> " + value + " "
+																	+ value.getClass().getName());
 		}
 		node.setFirstChild(null); // Chop off the rest of the tree.
 		if(value instanceof String)
@@ -214,7 +222,7 @@
 		try
 		{
 			LiteralType literalType = (LiteralType) type;
-			Dialect dialect = walker.getSessionFactoryHelper().getFactory().getDialect();
+			Dialect dialect = this.walker.getSessionFactoryHelper().getFactory().getDialect();
 			node.setText(literalType.objectToSQLString(value, dialect));
 		}
 		catch(Exception e)
@@ -231,7 +239,7 @@
 		// TODO: something much better - look at the type of the other expression!
 		// TODO: Have comparisonExpression and/or arithmeticExpression rules
 		// complete the resolution of boolean nodes.
-		String replacement = (String) walker.getTokenReplacements().get(constant.getText());
+		String replacement = (String) this.walker.getTokenReplacements().get(constant.getText());
 		if(replacement != null)
 		{
 			constant.setText(replacement);
@@ -239,7 +247,7 @@
 		else
 		{
 			boolean bool = "true".equals(constant.getText().toLowerCase());
-			Dialect dialect = walker.getSessionFactoryHelper().getFactory().getDialect();
+			Dialect dialect = this.walker.getSessionFactoryHelper().getFactory().getDialect();
 			constant.setText(dialect.toBooleanValueString(bool));
 		}
 	}
@@ -247,13 +255,13 @@
 
 	private void processLiteral(AST constant)
 	{
-		String replacement = (String) walker.getTokenReplacements().get(constant.getText());
+		String replacement = (String) this.walker.getTokenReplacements().get(constant.getText());
 		if(replacement != null)
 		{
-			if(log.isDebugEnabled())
+			if(LiteralProcessor.log.isDebugEnabled())
 			{
-				log.debug("processConstant() : Replacing '" + constant.getText() + "' with '" + replacement
-									+ "'");
+				LiteralProcessor.log.debug("processConstant() : Replacing '" + constant.getText()
+																		+ "' with '" + replacement + "'");
 			}
 			constant.setText(replacement);
 		}
@@ -262,18 +270,20 @@
 
 	public void processNumeric(AST literal)
 	{
-		if(literal.getType() == NUM_INT || literal.getType() == NUM_LONG)
+		if(literal.getType() == HqlSqlTokenTypes.NUM_INT
+				|| literal.getType() == HqlSqlTokenTypes.NUM_LONG)
 		{
-			literal.setText(determineIntegerRepresentation(literal.getText(), literal.getType()));
+			literal.setText(this.determineIntegerRepresentation(literal.getText(), literal.getType()));
 		}
-		else if(literal.getType() == NUM_FLOAT || literal.getType() == NUM_DOUBLE)
+		else if(literal.getType() == HqlSqlTokenTypes.NUM_FLOAT
+						|| literal.getType() == HqlSqlTokenTypes.NUM_DOUBLE)
 		{
-			literal.setText(determineDecimalRepresentation(literal.getText(), literal.getType()));
+			literal.setText(this.determineDecimalRepresentation(literal.getText(), literal.getType()));
 		}
 		else
 		{
-			log.warn("Unexpected literal token type [" + literal.getType()
-								+ "] passed for numeric processing");
+			LiteralProcessor.log.warn("Unexpected literal token type [" + literal.getType()
+																+ "] passed for numeric processing");
 		}
 	}
 
@@ -282,7 +292,7 @@
 	{
 		try
 		{
-			if(type == NUM_INT)
+			if(type == HqlSqlTokenTypes.NUM_INT)
 			{
 				try
 				{
@@ -290,8 +300,9 @@
 				}
 				catch(NumberFormatException e)
 				{
-					log.trace("could not format incoming text [" + text
-										+ "] as a NUM_INT; assuming numeric overflow and attempting as NUM_LONG");
+					LiteralProcessor.log.trace("could not format incoming text ["
+																			+ text
+																			+ "] as a NUM_INT; assuming numeric overflow and attempting as NUM_LONG");
 				}
 			}
 			String literalValue = text;
@@ -305,8 +316,9 @@
 			}
 			catch(NumberFormatException x)
 			{
-				log.trace("could not format incoming text [" + text
-									+ "] as a NUM_LONG; assuming numeric overflow and attempting as a BigDecimal");
+				LiteralProcessor.log.trace("could not format incoming text ["
+																		+ text
+																		+ "] as a NUM_LONG; assuming numeric overflow and attempting as a BigInteger");
 				return new BigInteger(literalValue).toString();
 			}
 		}
@@ -320,14 +332,14 @@
 	public String determineDecimalRepresentation(String text, int type)
 	{
 		String literalValue = text;
-		if(type == NUM_FLOAT)
+		if(type == HqlSqlTokenTypes.NUM_FLOAT)
 		{
 			if(literalValue.endsWith("f") || literalValue.endsWith("F"))
 			{
 				literalValue = literalValue.substring(0, literalValue.length() - 1);
 			}
 		}
-		else if(type == NUM_DOUBLE)
+		else if(type == HqlSqlTokenTypes.NUM_DOUBLE)
 		{
 			if(literalValue.endsWith("d") || literalValue.endsWith("D"))
 			{
@@ -345,7 +357,7 @@
 			throw new HibernateException("Could not parse literal [" + text + "] as big-decimal", t);
 		}
 
-		return formatters[DECIMAL_LITERAL_FORMAT].format(number);
+		return LiteralProcessor.formatters[LiteralProcessor.DECIMAL_LITERAL_FORMAT].format(number);
 	}
 
 	private static interface DecimalFormatter
@@ -374,7 +386,7 @@
 				// - from the DecimalFormat docs:
 				// [significant digits] = [minimum integer digits] + [maximum fraction
 				// digits]
-				DecimalFormat jdkFormatter = new DecimalFormat(FORMAT_STRING);
+				DecimalFormat jdkFormatter = new DecimalFormat(ApproximateDecimalFormatter.FORMAT_STRING);
 				jdkFormatter.setMinimumIntegerDigits(1);
 				jdkFormatter.setMaximumFractionDigits(Integer.MAX_VALUE);
 				return jdkFormatter.format(number);
