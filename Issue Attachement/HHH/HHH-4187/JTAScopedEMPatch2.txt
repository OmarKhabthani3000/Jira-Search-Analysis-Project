Index: C:/workspace-NGP-DAL/HibernateExt-3.2-cr2-JTAScopedEM/ejb/src/java/org/hibernate/ejb/JTAEntityManagerContext.java
===================================================================
--- C:/workspace-NGP-DAL/HibernateExt-3.2-cr2-JTAScopedEM/ejb/src/java/org/hibernate/ejb/JTAEntityManagerContext.java	(revision 0)
+++ C:/workspace-NGP-DAL/HibernateExt-3.2-cr2-JTAScopedEM/ejb/src/java/org/hibernate/ejb/JTAEntityManagerContext.java	(revision 0)
@@ -0,0 +1,111 @@
+package org.hibernate.ejb;
+
+import java.util.Hashtable;
+import java.util.Map;
+
+import javax.persistence.EntityManager;
+import javax.transaction.Synchronization;
+import javax.transaction.Transaction;
+import javax.transaction.TransactionManager;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.hibernate.HibernateException;
+import org.hibernate.engine.SessionFactoryImplementor;
+import org.hibernate.util.JTAHelper;
+
+/**
+ * Scopes the notion of a current EntityManager to a JTA transaction. Implementation based on
+ * {@link org.hibernate.context.JTASessionContext} and leverages Hibernate's current session capability.
+ * Allows transitional use of the JPA API in containers that do not yet fully implement the EJB3 spec.
+ * 
+ * TODO Should probably get rid of this once EJB3 is pervasive.
+ * 
+ * @author James Olsen
+ */
+public class JTAEntityManagerContext {
+
+	private static final Log log = LogFactory.getLog(JTAEntityManagerContext.class);
+
+	private HibernateEntityManagerFactory hibernateEMFactory;
+	private transient Map currentEntityManagerMap = new Hashtable();
+
+	public JTAEntityManagerContext(HibernateEntityManagerFactory hibernateEMFactory) {
+		this.hibernateEMFactory = hibernateEMFactory;
+	}
+
+	public EntityManager currentEntityManager() throws HibernateException {
+		TransactionManager transactionManager = ((SessionFactoryImplementor) hibernateEMFactory.getSessionFactory())
+				.getTransactionManager();
+		if (transactionManager == null) {
+			throw new HibernateException("No TransactionManagerLookup specified");
+		}
+
+		Transaction txn = null;
+		try {
+			txn = transactionManager.getTransaction();
+			if (txn == null) {
+				throw new HibernateException("Unable to locate current JTA transaction");
+			}
+			if (!JTAHelper.isInProgress(txn.getStatus())) {
+				// We could register the EntityManager against the transaction even though it is
+				// not started, but we'd have no guarentee of ever getting the map
+				// entries cleaned up (aside from spawning threads).
+				throw new HibernateException("Current transaction is not in progress");
+			}
+		} catch (HibernateException e) {
+			throw e;
+		} catch (Throwable t) {
+			throw new HibernateException("Problem locating/validating JTA transaction", t);
+		}
+
+		EntityManager currentEntityManager = (EntityManager) currentEntityManagerMap.get(txn);
+
+		if (currentEntityManager == null) {
+			currentEntityManager = buildEntityManager();
+
+			try {
+				txn.registerSynchronization(buildCleanupSynch(txn));
+			} catch (Throwable t) {
+				try {
+					currentEntityManager.close();
+				} catch (Throwable ignore) {
+					log.debug("Unable to release generated current-session on failed synch registration", ignore);
+				}
+				throw new HibernateException("Unable to register cleanup Synchronization with TransactionManager");
+			}
+
+			currentEntityManagerMap.put(txn, currentEntityManager);
+		}
+
+		return currentEntityManager;
+	}
+
+	private EntityManager buildEntityManager() {
+		return hibernateEMFactory.createEntityManager();
+	}
+
+	private CleanupSynch buildCleanupSynch(Transaction txn) {
+		return new CleanupSynch(txn, this);
+	}
+
+	/**
+	 * JTA transaction synch used for cleanup of the internal EntityManager map.
+	 */
+	protected static class CleanupSynch implements Synchronization {
+		private Transaction txn;
+		private JTAEntityManagerContext context;
+
+		public CleanupSynch(Transaction txn, JTAEntityManagerContext context) {
+			this.txn = txn;
+			this.context = context;
+		}
+
+		public void beforeCompletion() {
+		}
+
+		public void afterCompletion(int i) {
+			context.currentEntityManagerMap.remove(txn);
+		}
+	}
+}
Index: C:/workspace-NGP-DAL/HibernateExt-3.2-cr2-JTAScopedEM/ejb/src/java/org/hibernate/ejb/EntityManagerFactoryImpl.java
===================================================================
--- C:/workspace-NGP-DAL/HibernateExt-3.2-cr2-JTAScopedEM/ejb/src/java/org/hibernate/ejb/EntityManagerFactoryImpl.java	(revision 10523)
+++ C:/workspace-NGP-DAL/HibernateExt-3.2-cr2-JTAScopedEM/ejb/src/java/org/hibernate/ejb/EntityManagerFactoryImpl.java	(working copy)
@@ -7,6 +7,7 @@
 import javax.persistence.spi.PersistenceUnitTransactionType;
 
 import org.hibernate.SessionFactory;
+import org.hibernate.engine.SessionFactoryImplementor;
 
 /**
  * @author Gavin King
@@ -18,6 +19,8 @@
 	private PersistenceUnitTransactionType transactionType;
 	private boolean discardOnClose;
 
+	private JTAEntityManagerContext jtaEMContext;
+
 	public EntityManagerFactoryImpl(
 			SessionFactory sessionFactory,
 			PersistenceUnitTransactionType transactionType,
@@ -26,8 +29,19 @@
 		this.sessionFactory = sessionFactory;
 		this.transactionType = transactionType;
 		this.discardOnClose = discardOnClose;
+
+		jtaEMContext = new JTAEntityManagerContext(this);
 	}
 
+	/**
+	 * Non standard Hibernate scope managed EntityManager.
+	 * TODO Should probably get rid of this and the {@link JTAEntityManagerContext} once EJB3 is pervasive.
+	 * @return An EntityManager scoped in the same way as Hibernate's current JTA session notion.
+	 */
+	public EntityManager getCurrentEntityManager() {
+		return jtaEMContext.currentEntityManager();
+	}
+	
 	public EntityManager createEntityManager() {
 		return createEntityManager( null );
 	}
Index: C:/workspace-NGP-DAL/HibernateExt-3.2-cr2-JTAScopedEM/ejb/src/java/org/hibernate/ejb/HibernateEntityManagerFactory.java
===================================================================
--- C:/workspace-NGP-DAL/HibernateExt-3.2-cr2-JTAScopedEM/ejb/src/java/org/hibernate/ejb/HibernateEntityManagerFactory.java	(revision 10523)
+++ C:/workspace-NGP-DAL/HibernateExt-3.2-cr2-JTAScopedEM/ejb/src/java/org/hibernate/ejb/HibernateEntityManagerFactory.java	(working copy)
@@ -3,6 +3,7 @@
 
 import java.io.Serializable;
 import javax.persistence.EntityManagerFactory;
+import javax.persistence.EntityManager;
 
 import org.hibernate.SessionFactory;
 
@@ -11,4 +12,5 @@
  */
 public interface HibernateEntityManagerFactory extends EntityManagerFactory, Serializable {
 	public SessionFactory getSessionFactory();
+	public EntityManager getCurrentEntityManager();
 }
Index: C:/workspace-NGP-DAL/HibernateExt-3.2-cr2-JTAScopedEM/ejb/src/java/org/hibernate/ejb/EntityManagerImpl.java
===================================================================
--- C:/workspace-NGP-DAL/HibernateExt-3.2-cr2-JTAScopedEM/ejb/src/java/org/hibernate/ejb/EntityManagerImpl.java	(revision 10523)
+++ C:/workspace-NGP-DAL/HibernateExt-3.2-cr2-JTAScopedEM/ejb/src/java/org/hibernate/ejb/EntityManagerImpl.java	(working copy)
@@ -37,6 +37,22 @@
 		postInit();
 	}
 
+	/**
+	 * Special constructor to support non standard Hibernate scope managed EntityManager.
+	 * TODO Should probably get rid of this and the {@link JTAEntityManagerContext} once EJB3 is pervasive.
+	 */
+	public EntityManagerImpl(
+			Session session, PersistenceContextType pcType,
+			PersistenceUnitTransactionType transactionType,
+			boolean discardOnClose, Map properties
+	) {
+		super( pcType, transactionType, properties );
+		this.session = session;
+		this.open = true;
+		this.discardOnClose = discardOnClose;
+		postInit();
+	}
+	
 	public Session getSession() {
 
 		if ( !open ) throw new IllegalStateException( "EntityManager is closed" );
