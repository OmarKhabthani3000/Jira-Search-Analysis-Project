Index: core/src/main/java/org/hibernate/loader/JoinWalker.java
===================================================================
--- core/src/main/java/org/hibernate/loader/JoinWalker.java	(revision 19258)
+++ core/src/main/java/org/hibernate/loader/JoinWalker.java	(working copy)
@@ -681,7 +681,16 @@
 	 * Extend the path by the given property name
 	 */
 	private static String subPath(String path, String property) {
-		if ( path==null || path.length()==0) {
+        if (property.equals("_identifierMapper"))
+        {
+            // IdentifierMapper properties don't represent a real path,
+            // they only name the association for a composite ID. They should
+            // never appear on a Criteria join as they are an internal
+            // Hibernate detail. See ComplexJoinAliasTest for the test case
+            // that required this fake path element to be removed.
+            return path;
+        }
+        else if ( path==null || path.length()==0) {
 			return property;
 		}
 		else {
@@ -921,7 +930,7 @@
 					final QueryableCollection queryableCollection = (QueryableCollection) oj.getJoinable();
 					if ( queryableCollection.hasOrdering() ) {
 						final String orderByString = queryableCollection.getSQLOrderByString( oj.getRHSAlias() );
-						buf.append( orderByString ).append(", ");
+						buf.append( orderByString ).append(",\n  ");
 					}
 				}
 				else {
Index: core/src/main/java/org/hibernate/loader/criteria/CriteriaJoinWalker.java
===================================================================
--- core/src/main/java/org/hibernate/loader/criteria/CriteriaJoinWalker.java	(revision 19258)
+++ core/src/main/java/org/hibernate/loader/criteria/CriteriaJoinWalker.java	(working copy)
@@ -187,7 +187,7 @@
 	protected String generateTableAlias(int n, String path, Joinable joinable) {
 		if ( joinable.consumesEntityAlias() ) {
 			final Criteria subcriteria = translator.getCriteria(path);
-			String sqlAlias = subcriteria==null ? null : translator.getSQLAlias(subcriteria);
+			String sqlAlias = translator.getSQLAlias(subcriteria);
 			if (sqlAlias!=null) {
 				userAliasList.add( subcriteria.getAlias() ); //alias may be null
 				return sqlAlias; //EARLY EXIT
Index: annotations/src/test/java/org/hibernate/test/criterion/ComplexJoinAliasTest.java
===================================================================
--- annotations/src/test/java/org/hibernate/test/criterion/ComplexJoinAliasTest.java	(revision 0)
+++ annotations/src/test/java/org/hibernate/test/criterion/ComplexJoinAliasTest.java	(revision 0)
@@ -0,0 +1,163 @@
+package org.hibernate.test.criterion;
+
+import java.util.Arrays;
+
+import javax.persistence.Column;
+import javax.persistence.Entity;
+import javax.persistence.EnumType;
+import javax.persistence.Enumerated;
+import javax.persistence.Id;
+import javax.persistence.IdClass;
+import javax.persistence.JoinColumn;
+import javax.persistence.ManyToOne;
+import javax.persistence.MappedSuperclass;
+import javax.persistence.Table;
+
+import org.hibernate.Criteria;
+import org.hibernate.Session;
+import org.hibernate.criterion.Restrictions;
+
+/**
+ * Hibernate generates the wrong alias on a Criteria query involving a join
+ * on a composite identifier. For example, in the test below without the fix
+ * to JoinWalker, it generates this SQL:
+ * 
+ * <code>
+ * select
+ *     this_.role_code as role1_0_1_,
+ *     this_.is_deleted as is2_0_1_,
+ *     this_.record_version as record3_0_1_,
+ *     complexjoi3_.code as code1_0_,
+ *     complexjoi3_.is_deleted as is2_1_0_,
+ *     complexjoi3_.record_version as record3_1_0_ 
+ * from
+ *     list_action_roles this_ 
+ * left outer join
+ *     roles complexjoi3_ 
+ *         on this_.role_code=complexjoi3_.code 
+ * where
+ *     this_.is_deleted=? 
+ *     and complexjoi1_.is_deleted=?
+ * </code>
+ * 
+ * Which results in this error from the SQL server:
+ * 
+ * <code>
+ * Unknown column 'complexjoi1_.is_deleted' in 'where clause'
+ * </code>
+ * 
+ * Analysis of the problem:
+ * 
+ * The entity persister class with the composite identifier has a fake
+ * property for it, called "_identifierMapper" (see HbmBinder.bindCompositeId()
+ * and similarly in Annotations). This property name ends up in the path
+ * used by JoinWalker.walkEntityTree() when it calls walkComponentTree().
+ * However that path is used by CriteriaJoinWalker.generateTableAlias()
+ * to look up the correct criteria (and hence the alias) from the
+ * translator, a CriteriaQueryTranslator.
+ * 
+ * The alias was created in CriteriaQueryTranslator.createCriteriaSQLAliasMap
+ * for a Criteria without this extra _identifierMapper path component.
+ * So when CriteriaJoinWalker tries to use the path with _identifierMapper
+ * to look up the criteria to find the correct alias to use, in
+ * generateTableAlias(), it doesn't find one, so it generates a new alias.
+ * 
+ * That new alias no longer matches the one that will be rendered out in
+ * the WHERE clause, so the WHERE clause will refer to table names using
+ * aliases that are not used anywhere else in the query, and the SQL server
+ * will fail to parse the statement.  
+ *
+ * The solution appears to be to exclude "_identifierMapper" components in
+ * the alias path when building it. I don't know what other implications
+ * that might have, but it seems like an implementation nastiness that
+ * shouldn't be exposed.
+ * 
+ * @link http://opensource.atlassian.com/projects/hibernate/browse/HHH-4630
+ * 
+ * @author Chris Wilson
+ */
+
+public class ComplexJoinAliasTest
+extends org.hibernate.test.annotations.TestCase
+{
+    @MappedSuperclass
+    private static abstract class VersionedRecord
+    implements java.io.Serializable
+    {
+        @Column(name="record_version", nullable=false) 
+        Long recordVersion;
+        
+        @Column(name="is_deleted", nullable=false, columnDefinition="smallint")
+        Boolean isDeleted;
+    }
+    
+    @Entity
+    @Table(name="list_action_roles")
+    @IdClass(ListActionRole.class)
+    public static class ListActionRole extends VersionedRecord
+    {
+        @Id
+        @Column(name="role_code", length=3)
+        @Enumerated(EnumType.STRING)
+        Role.Code roleCode;
+        
+        @ManyToOne(targetEntity=Role.class)
+        @JoinColumn(name="role_code", insertable=false, updatable=false)
+        Role role;
+        
+        @Override
+        public String toString()
+        {
+            return "ListActionRole.Id(roleCode=" + roleCode + ")";
+        }
+        
+        @Override
+        public int hashCode()
+        {
+            return toString().hashCode();
+        }    
+    }
+    
+    @Entity
+    @Table(name="roles")
+    public static class Role extends VersionedRecord
+    {
+        public enum Code
+        {
+            ADM, CEN, RPA, RPP, PRJ, HUB, RQS, OAD, ORP, ORQ
+        };
+
+        @Id
+        @Column(name="code", length=3)
+        @Enumerated(EnumType.STRING)
+        Code code;
+    }
+    
+    protected Class[] getMappings() {
+        return new Class[]{
+            ListActionRole.class,
+            Role.class
+        };
+    }
+
+    public void testTest() throws Exception
+    {
+        Session session = openSession();
+
+        Criteria listActionRoles = session.createCriteria(ListActionRole.class);
+        listActionRoles.add(Restrictions.eq("isDeleted", false));
+        
+        Criteria roles = listActionRoles.createCriteria("role");
+        roles.add(Restrictions.eq("isDeleted", false));
+
+        assertEquals(Arrays.asList(new ListActionRole[]{}),
+            listActionRoles.list());
+        
+        session.close();
+    }
+    
+    public static void main(String[] args)
+    {
+        junit.textui.TestRunner.run(ComplexJoinAliasTest.class);
+    }
+}
