### Eclipse Workspace Patch 1.0
#P hibernate-annotations-3.4.0
Index: src/java/org/hibernate/cfg/BinderHelper.java
===================================================================
--- src/java/org/hibernate/cfg/BinderHelper.java	(revision 17263)
+++ src/java/org/hibernate/cfg/BinderHelper.java	(working copy)
@@ -17,10 +17,13 @@
 import org.hibernate.MappingException;
 import org.hibernate.annotations.AnyMetaDef;
 import org.hibernate.annotations.AnyMetaDefs;
+import org.hibernate.annotations.ElementNode;
 import org.hibernate.annotations.MetaValue;
+import org.hibernate.annotations.Node;
 import org.hibernate.annotations.common.reflection.XAnnotatedElement;
 import org.hibernate.annotations.common.reflection.XClass;
 import org.hibernate.annotations.common.reflection.XPackage;
+import org.hibernate.annotations.common.reflection.XProperty;
 import org.hibernate.cfg.annotations.EntityBinder;
 import org.hibernate.cfg.annotations.Nullability;
 import org.hibernate.cfg.annotations.TableBinder;
@@ -553,4 +556,60 @@
 		log.info( "Binding Any Meta definition: {}", defAnn.name() );
 		mappings.addAnyMetaDef( defAnn );
 	}
+	
+	public static boolean isEmbeddedXML(XAnnotatedElement property){
+		if (property.isAnnotationPresent(org.hibernate.annotations.Node.class)){
+			Node node = property.getAnnotation(org.hibernate.annotations.Node.class);
+			return node.embedXML();
+		}
+       return true;		
+	}
+	
+	/**
+	 * Guess if an element of a collection si annotated to be used in @see EntityMode.Dom4j
+	 * @param property
+	 * @return false by default, true if the embedXML is true 
+	 */
+	public static boolean isElementNodeEmbeddedXML(XAnnotatedElement property){
+		if(property.isAnnotationPresent(org.hibernate.annotations.Node.class)){
+			Node node = property.getAnnotation(org.hibernate.annotations.Node.class);
+			ElementNode elementNode = node.element();
+			return elementNode.embedXML();
+		}
+		return false; 
+	}
+	
+	public static String getElementNodeName(XAnnotatedElement property){
+		if(property.isAnnotationPresent(org.hibernate.annotations.Node.class)){
+			Node node = property.getAnnotation(org.hibernate.annotations.Node.class);
+			ElementNode elementNode = node.element();
+			return elementNode.name();
+		}
+		return null; 
+	}
+	
+	public static String getNodeName(XAnnotatedElement property){
+		if(property.isAnnotationPresent(org.hibernate.annotations.Node.class)){
+			Node node = property.getAnnotation(org.hibernate.annotations.Node.class);
+			if(!"".equals(node.name())) return node.name();
+		}
+		return null;
+	}
+
+	public static boolean hasElementNodeName(XAnnotatedElement property) {
+		if(property!=null && property.isAnnotationPresent(org.hibernate.annotations.Node.class)){
+			Node node = property.getAnnotation(org.hibernate.annotations.Node.class);
+			ElementNode elementNode = node.element();
+			return ! "".equals(elementNode.name());
+		}
+		return false;
+	}
+
+	public static boolean hasNodeName(XAnnotatedElement property) {
+		if(property!=null && property.isAnnotationPresent(org.hibernate.annotations.Node.class)){
+			Node node = property.getAnnotation(org.hibernate.annotations.Node.class);
+			return ! "".equals(node.name());
+		}
+		return false;
+	}
 }
Index: src/java/org/hibernate/annotations/Node.java
===================================================================
--- src/java/org/hibernate/annotations/Node.java	(revision 0)
+++ src/java/org/hibernate/annotations/Node.java	(revision 0)
@@ -0,0 +1,20 @@
+package org.hibernate.annotations;
+
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.ElementType.TYPE;
+import java.lang.annotation.Retention;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+import java.lang.annotation.Target;
+
+/**
+ * Defines a node Node(name=, embedXml=true|false) for DOM4J
+ *
+ * @author Arturo Frappé Muñoz
+ */
+@Target({METHOD, FIELD, TYPE}) @Retention(RUNTIME)
+public @interface Node {
+	String name() default "";
+	boolean embedXML() default true;
+	ElementNode element() default @ElementNode();
+}
Index: src/test/org/hibernate/test/annotations/node/User.java
===================================================================
--- src/test/org/hibernate/test/annotations/node/User.java	(revision 0)
+++ src/test/org/hibernate/test/annotations/node/User.java	(revision 0)
@@ -0,0 +1,75 @@
+package org.hibernate.test.annotations.node;
+
+// Generated 19/08/2009 05:36:10 PM by Hibernate Tools 3.2.4.GA
+
+import java.util.ArrayList;
+import java.util.Collection;
+import javax.persistence.CascadeType;
+import javax.persistence.Column;
+import javax.persistence.Entity;
+import javax.persistence.FetchType;
+import javax.persistence.GeneratedValue;
+import javax.persistence.Id;
+import javax.persistence.OneToMany;
+import javax.persistence.Table;
+
+import org.hibernate.annotations.ElementNode;
+import org.hibernate.annotations.GenericGenerator;
+import org.hibernate.annotations.Node;
+
+/**
+ * User generated by hbm2java
+ */
+@Entity
+@org.hibernate.annotations.Entity(mutable = true, dynamicUpdate = false, dynamicInsert = false, selectBeforeUpdate = false)
+@Table(name = "USERS")
+@Node(name="user")
+public class User implements java.io.Serializable {
+
+	private long id;
+	private String username;
+	private Collection<Item> itemsForSale = new ArrayList<Item>(0);
+
+	public User() {
+	}
+
+	public User(String username, Collection<Item> itemsForSale) {
+		this.username = username;
+		this.itemsForSale = itemsForSale;
+	}
+
+	@GenericGenerator(name = "generator", strategy = "hilo")
+	@Id
+	@GeneratedValue(generator = "generator")
+	@Column(name = "USER_ID", nullable = false)
+	@Node(name="@id")
+	public long getId() {
+		return this.id;
+	}
+
+	public void setId(long id) {
+		this.id = id;
+	}
+
+	@Column(name = "USERNAME")
+	@Node(name="@username")
+	public String getUsername() {
+		return this.username;
+	}
+
+	public void setUsername(String username) {
+		this.username = username;
+	}
+
+	@OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY, mappedBy = "seller")
+	@Node(name="items-for-sale", embedXML=true,
+			element=@ElementNode(embedXML=true))
+	public Collection<Item> getItemsForSale() {
+		return this.itemsForSale;
+	}
+
+	public void setItemsForSale(Collection<Item> itemsForSale) {
+		this.itemsForSale = itemsForSale;
+	}
+
+}
Index: src/java/org/hibernate/cfg/AnnotationBinder.java
===================================================================
--- src/java/org/hibernate/cfg/AnnotationBinder.java	(revision 17263)
+++ src/java/org/hibernate/cfg/AnnotationBinder.java	(working copy)
@@ -1316,6 +1316,10 @@
 			RootClass rootClass = (RootClass) propertyHolder.getPersistentClass();
 			PropertyBinder propBinder = new PropertyBinder();
 			propBinder.setName( inferredData.getPropertyName() );
+			
+			boolean hasNodeName = BinderHelper.hasNodeName( inferredData.getProperty() );
+			if( hasNodeName )  propBinder.setNodeName( BinderHelper.getNodeName( inferredData.getProperty() ) );
+			
 			propBinder.setReturnedClassName( inferredData.getTypeName() );
 			propBinder.setLazy( false );
 			propBinder.setPropertyAccessorName( inferredData.getDefaultAccess() );
@@ -1652,6 +1656,8 @@
 
 				PropertyBinder propBinder = new PropertyBinder();
 				propBinder.setName( inferredData.getPropertyName() );
+				boolean hasNodeName = BinderHelper.hasNodeName( property );
+				if( hasNodeName )	propBinder.setNodeName( BinderHelper.getNodeName( property ) );
 				propBinder.setReturnedClassName( inferredData.getTypeName() );
 				propBinder.setLazy( lazy );
 				propBinder.setPropertyAccessorName( inferredData.getDefaultAccess() );
@@ -1775,6 +1781,8 @@
 
 		PropertyBinder binder = new PropertyBinder();
 		binder.setName( inferredData.getPropertyName() );
+		boolean hasNodeName = BinderHelper.hasNodeName( inferredData.getProperty() );
+		if( hasNodeName )  binder.setNodeName( BinderHelper.getNodeName( inferredData.getProperty() ) );
 		binder.setValue( comp );
 		binder.setProperty( inferredData.getProperty() );
 		binder.setPropertyAccessorName( inferredData.getDefaultAccess() );
@@ -1803,7 +1811,12 @@
 		else {
 			comp.setComponentClassName( comp.getOwner().getClassName() );
 		}
-		comp.setNodeName( inferredData.getPropertyName() );
+		boolean hasNodeName = BinderHelper.hasNodeName(inferredData.getProperty());
+		if(hasNodeName){
+			comp.setNodeName( BinderHelper.getNodeName(inferredData.getProperty()) );
+		} else {
+		    comp.setNodeName( inferredData.getPropertyName() );
+		}
 		String subpath = StringHelper.qualify( propertyHolder.getPath(), inferredData.getPropertyName() );
 		log.debug( "Binding component with path: {}", subpath );
 		PropertyHolder subHolder = PropertyHolderBuilder.buildPropertyHolder(
@@ -1905,6 +1918,8 @@
 		else {
 			PropertyBinder binder = new PropertyBinder();
 			binder.setName( inferredData.getPropertyName() );
+			boolean hasNodeName= BinderHelper.hasNodeName( inferredData.getProperty() );
+			if(hasNodeName)	binder.setNodeName( BinderHelper.getNodeName( inferredData.getProperty() ) );
 			binder.setValue( id );
 			binder.setPropertyAccessorName( inferredData.getDefaultAccess() );
 			binder.setProperty( inferredData.getProperty() );
@@ -1944,6 +1959,7 @@
 			value.setReferencedEntityName( targetEntity.getName() );
 		}
 		defineFetchingStrategy( value, inferredData.getProperty() );
+		value.setEmbedded( BinderHelper.isEmbeddedXML( inferredData.getProperty() ) );
 		//value.setFetchMode( fetchMode );
 		value.setIgnoreNotFound( ignoreNotFound );
 		value.setCascadeDeleteEnabled( cascadeOnDelete );
@@ -1981,6 +1997,10 @@
 		Ejb3Column.checkPropertyConsistency( columns, propertyHolder.getEntityName() + propertyName );
 		PropertyBinder binder = new PropertyBinder();
 		binder.setName( propertyName );
+		boolean hasNodeName = BinderHelper.hasNodeName( inferredData.getProperty() );
+		if(hasNodeName){
+		   binder.setNodeName( BinderHelper.getNodeName( inferredData.getProperty() ) );
+		}
 		binder.setValue( value );
 		//binder.setCascade(cascadeStrategy);
 		if ( isIdentifierMapper ) {
Index: src/java/org/hibernate/cfg/annotations/CollectionBinder.java
===================================================================
--- src/java/org/hibernate/cfg/annotations/CollectionBinder.java	(revision 17263)
+++ src/java/org/hibernate/cfg/annotations/CollectionBinder.java	(working copy)
@@ -441,6 +441,12 @@
 		//property building
 		PropertyBinder binder = new PropertyBinder();
 		binder.setName( propertyName );
+		boolean hasNodeName = BinderHelper.hasNodeName( property );
+		if(hasNodeName){
+		   binder.setNodeName( BinderHelper.getNodeName( property ) );
+		} else {
+			binder.setNodeName( propertyName );
+		}
 		binder.setValue( collection );
 		binder.setCascade( cascadeStrategy );
 		if ( cascadeStrategy != null && cascadeStrategy.indexOf( "delete-orphan" ) >= 0 ) {
@@ -625,7 +631,16 @@
 		collection.setElement( oneToMany );
 		oneToMany.setReferencedEntityName( collectionType.getName() );
 		oneToMany.setIgnoreNotFound( ignoreNotFound );
-
+        collection.setEmbedded( BinderHelper.isEmbeddedXML( property ) );
+        oneToMany.setEmbedded( BinderHelper.isElementNodeEmbeddedXML( property ) );
+        boolean hasElementNodeName = BinderHelper.hasElementNodeName( property );
+        if( hasElementNodeName ) 
+        	collection.setElementNodeName( BinderHelper.getElementNodeName( property ) );
+        boolean hasNodeName = BinderHelper.hasNodeName( property );
+        if(hasNodeName) 
+        	collection.setNodeName( BinderHelper.getNodeName( property ) );
+        
+        
 		String assocClass = oneToMany.getReferencedEntityName();
 		PersistentClass associatedClass = (PersistentClass) persistentClasses.get( assocClass );
 		String orderBy = buildOrderByClauseFromHql( hqlOrderBy, associatedClass, collection.getRole() );
Index: src/test/org/hibernate/test/annotations/node/NodeTest.java
===================================================================
--- src/test/org/hibernate/test/annotations/node/NodeTest.java	(revision 0)
+++ src/test/org/hibernate/test/annotations/node/NodeTest.java	(revision 0)
@@ -0,0 +1,67 @@
+/**
+ * 
+ */
+package org.hibernate.test.annotations.node;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.UnsupportedEncodingException;
+import java.math.BigDecimal;
+import java.util.ArrayList;
+
+import org.dom4j.Element;
+import org.dom4j.io.OutputFormat;
+import org.dom4j.io.XMLWriter;
+import org.hibernate.EntityMode;
+import org.hibernate.Session;
+import org.hibernate.Transaction;
+import org.hibernate.test.annotations.TestCase;
+
+/**
+ * Example taken from "Section 3.4.2 Representing data in XML" from the book "Java Persistence with Hibernate" by Bauer & King, Manning,  pages 150-151 
+ * @author Arturo Frappé Muñoz
+ * 
+ */
+public class NodeTest extends TestCase {
+
+	public void testNode() throws Exception {
+		Session s;
+		Transaction tx;
+		s = openSession();
+		User seller = new User();
+		seller.setUsername("johndoe");
+		seller.getItemsForSale().add(
+				new Item(new BigDecimal(99), "An item for auction", seller));
+		seller.getItemsForSale().add(
+				new Item(new BigDecimal(123), "An other item for auction",
+						seller));
+		s.persist(seller);
+		tx = s.beginTransaction();
+		tx.commit();
+		s.close();
+
+		s = openSession();
+
+		Session dom4jSession = s.getSession(EntityMode.DOM4J);
+		Element doc = (Element) dom4jSession.createQuery("from User")
+				.setMaxResults(1).uniqueResult();
+
+		OutputFormat format = OutputFormat.createPrettyPrint();
+		XMLWriter writer;
+
+		ByteArrayOutputStream out = new ByteArrayOutputStream();
+		writer = new XMLWriter(out, format);
+		writer.write(doc);
+		writer.flush();
+		
+        assertTrue("johndoe".equals(doc.attributeValue("username")));
+		log.info(out.toString());        
+		dom4jSession.close();
+		s.close();
+	}
+
+	@Override
+	protected Class<?>[] getMappings() {
+		return new Class[] { Item.class, User.class };
+	}
+}
Index: src/java/org/hibernate/annotations/ElementNode.java
===================================================================
--- src/java/org/hibernate/annotations/ElementNode.java	(revision 0)
+++ src/java/org/hibernate/annotations/ElementNode.java	(revision 0)
@@ -0,0 +1,25 @@
+/**
+ * 
+ */
+package org.hibernate.annotations;
+
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+/**
+ * Defines the properties of a contained element inside a collection.
+ * 
+ * @author Arturo Frappé Muñoz
+ * 
+ * 
+ * 
+ */
+@Target({METHOD, FIELD}) @Retention(RUNTIME)
+public @interface ElementNode {
+     String name() default "";
+     boolean embedXML() default false;
+}
Index: src/java/org/hibernate/cfg/OneToOneSecondPass.java
===================================================================
--- src/java/org/hibernate/cfg/OneToOneSecondPass.java	(revision 17263)
+++ src/java/org/hibernate/cfg/OneToOneSecondPass.java	(working copy)
@@ -87,6 +87,13 @@
 		);
 		PropertyBinder binder = new PropertyBinder();
 		binder.setName( propertyName );
+		boolean hasNodeName = BinderHelper.hasNodeName( targetEntity );
+		if(hasNodeName){
+		   binder.setNodeName( BinderHelper.getNodeName( targetEntity ) );
+		} else {
+			binder.setNodeName( propertyName );
+		}
+		
 		binder.setValue( value );
 		binder.setCascade( cascadeStrategy );
 		binder.setPropertyAccessorName( inferredData.getDefaultAccess() );
Index: src/test/org/hibernate/test/annotations/node/NodeTest.hbm.xml
===================================================================
--- src/test/org/hibernate/test/annotations/node/NodeTest.hbm.xml	(revision 0)
+++ src/test/org/hibernate/test/annotations/node/NodeTest.hbm.xml	(revision 0)
@@ -0,0 +1,37 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
+"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
+<hibernate-mapping package="org.hibernate.test.annotations.node">
+	<class name="Item" table="ITEM_ENTITY" node="item">
+	  <id name="id" type="long" column="ITEM_ID" node="@id">
+	    <generator class="hilo"/>
+	  </id>
+	  <property name="initialPrice"
+	            type="big_decimal"
+	            column="INIT_PRICE"
+	            node="item-details/@initial-price"/>
+	 <property name="description"
+	           type="string"
+	           column="DESCRIPTION"
+	           node="item-details/@description"/>
+	 <many-to-one name="seller"
+	              class="User"
+	              column="USER_ID"
+	              embed-xml="false"
+	              node="@seller-id"/>	              
+	</class>
+	<class name="User" table="USERS" node="user">
+	  <id name="id" type="long" column="USER_ID" node="@id">
+	    <generator class="hilo"/>
+	  </id>
+	  <property name="username"
+	            type="string"
+	            column="USERNAME"
+	            node="@username"/>
+	  <bag name="itemsForSale" inverse="true" cascade="all"
+	       embed-xml="true" node="items-for-sale">
+	       <key column="USER_ID"/>
+	       <one-to-many class="Item"/>
+	   </bag>
+	</class>
+</hibernate-mapping>
\ No newline at end of file
Index: src/test/org/hibernate/test/annotations/node/Item.java
===================================================================
--- src/test/org/hibernate/test/annotations/node/Item.java	(revision 0)
+++ src/test/org/hibernate/test/annotations/node/Item.java	(revision 0)
@@ -0,0 +1,84 @@
+package org.hibernate.test.annotations.node;
+
+// Generated 19/08/2009 05:36:10 PM by Hibernate Tools 3.2.4.GA
+
+import java.math.BigDecimal;
+import javax.persistence.Column;
+import javax.persistence.Entity;
+import javax.persistence.FetchType;
+import javax.persistence.GeneratedValue;
+import javax.persistence.Id;
+import javax.persistence.JoinColumn;
+import javax.persistence.ManyToOne;
+import javax.persistence.Table;
+import org.hibernate.annotations.GenericGenerator;
+import org.hibernate.annotations.Node;
+
+/**
+ * Item generated by hbm2java
+ */
+@Entity
+@org.hibernate.annotations.Entity(mutable = true, dynamicUpdate = false, dynamicInsert = false, selectBeforeUpdate = false)
+@Table(name = "ITEM_ENTITY")
+@Node(name="item")
+public class Item implements java.io.Serializable {
+
+	private long id;
+	private BigDecimal initialPrice;
+	private String description;
+	private User seller;
+
+	public Item() {
+	}
+
+	public Item(BigDecimal initialPrice, String description, User seller) {
+		this.initialPrice = initialPrice;
+		this.description = description;
+		this.seller = seller;
+	}
+
+	@GenericGenerator(name = "generator", strategy = "hilo")
+	@Id
+	@GeneratedValue(generator = "generator")
+	@Column(name = "ITEM_ID", nullable = false)
+	@Node(name="@id")
+	public long getId() {
+		return this.id;
+	}
+
+	public void setId(long id) {
+		this.id = id;
+	}
+
+	@Column(name = "INIT_PRICE")
+	@Node(name="item-details/@initial-price")
+	public BigDecimal getInitialPrice() {
+		return this.initialPrice;
+	}
+
+	public void setInitialPrice(BigDecimal initialPrice) {
+		this.initialPrice = initialPrice;
+	}
+
+	@Column(name = "DESCRIPTION")
+	@Node(name="item-details/@description")
+	public String getDescription() {
+		return this.description;
+	}
+
+	public void setDescription(String description) {
+		this.description = description;
+	}
+
+	@ManyToOne(fetch = FetchType.LAZY)
+	@JoinColumn(name = "USER_ID")
+	@Node(name="@seller-id",embedXML=false )
+	public User getSeller() {
+		return this.seller;
+	}
+
+	public void setSeller(User seller) {
+		this.seller = seller;
+	}
+
+}
Index: src/java/org/hibernate/cfg/annotations/EntityBinder.java
===================================================================
--- src/java/org/hibernate/cfg/annotations/EntityBinder.java	(revision 17263)
+++ src/java/org/hibernate/cfg/annotations/EntityBinder.java	(working copy)
@@ -154,7 +154,11 @@
 	public void bindEntity() {
 		persistentClass.setAbstract( annotatedClass.isAbstract() );
 		persistentClass.setClassName( annotatedClass.getName() );
-		persistentClass.setNodeName( name );
+		if( BinderHelper.hasNodeName( annotatedClass ) ){
+		   persistentClass.setNodeName( BinderHelper.getNodeName( annotatedClass ) );
+		} else {
+		   persistentClass.setNodeName( name );
+		}
 		//persistentClass.setDynamic(false); //no longer needed with the Entity name refactoring?
 		persistentClass.setEntityName( annotatedClass.getName() );
 		bindDiscriminatorValue();
Index: src/java/org/hibernate/cfg/annotations/PropertyBinder.java
===================================================================
--- src/java/org/hibernate/cfg/annotations/PropertyBinder.java	(revision 17263)
+++ src/java/org/hibernate/cfg/annotations/PropertyBinder.java	(working copy)
@@ -39,6 +39,7 @@
 	private boolean insertable = true;
 	private boolean updatable = true;
 	private String cascade;
+	private String nodeName;
 	/*
 	 * property can be null
 	 * prefer propertyName to property.getName() since some are overloaded
@@ -59,6 +60,10 @@
 		this.name = name;
 	}
 
+	public void setNodeName(String nodeName){
+		this.nodeName = nodeName;
+	}
+	
 	public void setReturnedClassName(String returnedClassName) {
 		this.returnedClassName = returnedClassName;
 	}
@@ -123,6 +128,7 @@
 		setValue( propertyValue );
 		Property prop = make();
 		holder.addProperty( prop, columns );
+		//if(nodeName!=null)	prop.setNodeName(nodeName);
 		return prop;
 	}
 
@@ -131,7 +137,12 @@
 		log.debug( "Building property " + name );
 		Property prop = new Property();
 		prop.setName( name );
-		prop.setNodeName( name );
+		if(nodeName!=null){
+			log.debug("Setting nodename " + nodeName);
+		   prop.setNodeName( nodeName );
+		} else {
+		   prop.setNodeName( name );	
+		}
 		prop.setValue( value );
 		prop.setLazy( lazy );
 		prop.setCascade( cascade );
