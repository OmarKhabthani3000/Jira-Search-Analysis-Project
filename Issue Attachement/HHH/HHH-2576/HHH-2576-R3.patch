### Eclipse Workspace Patch 1.0
#P hhh
Index: src/main/java/org/hibernate/loader/custom/sql/SQLCustomQuery.java
===================================================================
--- src/main/java/org/hibernate/loader/custom/sql/SQLCustomQuery.java (revision 17786)
+++ src/main/java/org/hibernate/loader/custom/sql/SQLCustomQuery.java (working copy)
@@ -129,7 +129,7 @@
 //
 //   String[] suffixes = BasicLoader.generateSuffixes(entityPersisters.length);
 
-   SQLQueryParser parser = new SQLQueryParser( sqlQuery, new ParserContext( aliasContext ) );
+   SQLQueryParser parser = new SQLQueryParser( sqlQuery, new ParserContext( aliasContext ), factory );
    this.sql = parser.process();
    this.namedParameterBindPoints.putAll( parser.getNamedParameters() );
 
Index: src/main/java/org/hibernate/loader/custom/sql/SQLQueryParser.java
===================================================================
--- src/main/java/org/hibernate/loader/custom/sql/SQLQueryParser.java (revision 17786)
+++ src/main/java/org/hibernate/loader/custom/sql/SQLQueryParser.java (working copy)
@@ -25,6 +25,7 @@
 package org.hibernate.loader.custom.sql;
 
 import org.hibernate.QueryException;
+import org.hibernate.engine.SessionFactoryImplementor;
 import org.hibernate.engine.query.ParameterParser;
 import org.hibernate.persister.collection.SQLLoadableCollection;
 import org.hibernate.persister.entity.SQLLoadable;
@@ -38,9 +39,15 @@
  * @author Gavin King
  * @author Max Andersen
  * @author Steve Ebersole
+ * @author Paul Benedict
  */
 public class SQLQueryParser {
 
+ private final String HIBERNATE_PLACEHOLDER_PREFIX = "h-";
+ private final String SCHEMA_PLACEHOLDER = "h-schema";
+ private final String CATALOG_PLACEHOLDER = "h-catalog";
+
+ private final SessionFactoryImplementor factory;
  private final String originalQueryString;
  private final ParserContext context;
 
@@ -57,9 +64,10 @@
    Map getPropertyResultsMapByAlias(String alias);
  }
 
- public SQLQueryParser(String queryString, ParserContext context) {
+ public SQLQueryParser(String queryString, ParserContext context, SessionFactoryImplementor factory) {
    this.originalQueryString = queryString;
    this.context = context;
+   this.factory = factory;
  }
 
  public Map getNamedParameters() {
@@ -71,7 +79,9 @@
  }
 
  public String process() {
-   return substituteParams( substituteBrackets( originalQueryString ) );
+   String processedSql = substituteBrackets( originalQueryString );
+   processedSql = substituteParams( processedSql );
+   return processedSql;
  }
 
  // TODO: should "record" how many properties we have reffered to - and if we 
@@ -98,40 +108,79 @@
      }
 
      String aliasPath = sqlQuery.substring( left + 1, right );
-     int firstDot = aliasPath.indexOf( '.' );
-     if ( firstDot == -1 ) {
-       if ( context.isEntityAlias( aliasPath ) ) {
-         // it is a simple table alias {foo}
-         result.append( aliasPath );
-         aliasesFound++;
+     boolean isPlaceholder = aliasPath.startsWith(HIBERNATE_PLACEHOLDER_PREFIX);
+
+     if ( isPlaceholder ) {
+       String placeholderName = aliasPath;
+
+       // Because some placeholders are stand-ins for qualified 
+       // SQL objects (like the schema name), a trailing period 
+       // tells this engine to also append the period to the 
+       // substituted value
+       boolean isTrailingQualified = placeholderName.endsWith(".");
+       if (isTrailingQualified) {
+         placeholderName = placeholderName.substring(0, placeholderName.length() - 1);
+       }
+                
+       // Schema replacement
+       if (SCHEMA_PLACEHOLDER.equals(placeholderName)) {
+         String schemaName = factory.getSettings().getDefaultSchemaName();
+         if ( schemaName != null ) {
+           result.append(schemaName);
+           if (isTrailingQualified) {
+             result.append(".");
+           }
+         }
        } 
+       // Catalog replacement
+       else if (CATALOG_PLACEHOLDER.equals(placeholderName)) {
+         String catalogName = factory.getSettings().getDefaultCatalogName();
+         if ( catalogName != null ) {
+           result.append(catalogName);
+           if (isTrailingQualified) {
+             result.append(".");
+           }
+         }
+       }
        else {
-         // passing through anything we do not know : to support jdbc escape sequences HB-898
-         result.append( '{' ).append(aliasPath).append( '}' );         
+         throw new QueryException( "Unknown placeholder ", placeholderName );
        }
      }
      else {
-       String aliasName = aliasPath.substring(0, firstDot);
-       boolean isCollection = context.isCollectionAlias( aliasName );
-       boolean isEntity = context.isEntityAlias( aliasName );
-       
-       if ( isCollection ) {
-         // The current alias is referencing the collection to be eagerly fetched
-         String propertyName = aliasPath.substring( firstDot + 1 );
-         result.append( resolveCollectionProperties( aliasName, propertyName ) );
-         aliasesFound++;
-       } 
-       else if ( isEntity ) {
-         // it is a property reference {foo.bar}
-         String propertyName = aliasPath.substring( firstDot + 1 );
-         result.append( resolveProperties( aliasName, propertyName ) );
-         aliasesFound++;
+       int firstDot = aliasPath.indexOf( '.' );
+       if ( firstDot == -1 ) {
+         if ( context.isEntityAlias( aliasPath ) ) {
+           // it is a simple table alias {foo}
+           result.append( aliasPath );
+           aliasesFound++;
+         } 
+         else {
+           // passing through anything we do not know : to support jdbc escape sequences HB-898
+           result.append( '{' ).append(aliasPath).append( '}' );         
+         }
        }
        else {
-         // passing through anything we do not know : to support jdbc escape sequences HB-898
-         result.append( '{' ).append(aliasPath).append( '}' );
+         String aliasName = aliasPath.substring(0, firstDot);
+         boolean isCollection = context.isCollectionAlias( aliasName );
+         boolean isEntity = context.isEntityAlias( aliasName );
+
+         if ( isCollection ) {
+           // The current alias is referencing the collection to be eagerly fetched
+           String propertyName = aliasPath.substring( firstDot + 1 );
+           result.append( resolveCollectionProperties( aliasName, propertyName ) );
+           aliasesFound++;
+         } 
+         else if ( isEntity ) {
+           // it is a property reference {foo.bar}
+           String propertyName = aliasPath.substring( firstDot + 1 );
+           result.append( resolveProperties( aliasName, propertyName ) );
+           aliasesFound++;
+         }
+         else {
+           // passing through anything we do not know : to support jdbc escape sequences HB-898
+           result.append( '{' ).append(aliasPath).append( '}' );
+         }
        }
- 
      }
    }
 
