Index: core/src/main/java/org/hibernate/criterion/SubqueryExpression.java
===================================================================
--- core/src/main/java/org/hibernate/criterion/SubqueryExpression.java	(revision 15151)
+++ core/src/main/java/org/hibernate/criterion/SubqueryExpression.java	(working copy)
@@ -24,13 +24,12 @@
  */
 package org.hibernate.criterion;
 
-import java.util.HashMap;
-
 import org.hibernate.Criteria;
 import org.hibernate.EntityMode;
 import org.hibernate.HibernateException;
 import org.hibernate.engine.QueryParameters;
 import org.hibernate.engine.SessionFactoryImplementor;
+import org.hibernate.engine.SessionImplementor;
 import org.hibernate.engine.TypedValue;
 import org.hibernate.impl.CriteriaImpl;
 import org.hibernate.loader.criteria.CriteriaJoinWalker;
@@ -42,7 +41,7 @@
  * @author Gavin King
  */
 public abstract class SubqueryExpression implements Criterion {
-	
+
 	private CriteriaImpl criteriaImpl;
 	private String quantifier;
 	private String op;
@@ -53,54 +52,71 @@
 	protected Type[] getTypes() {
 		return types;
 	}
-	
+
 	protected SubqueryExpression(String op, String quantifier, DetachedCriteria dc) {
 		this.criteriaImpl = dc.getCriteriaImpl();
 		this.quantifier = quantifier;
 		this.op = op;
 	}
-	
+
 	protected abstract String toLeftSqlString(Criteria criteria, CriteriaQuery outerQuery);
 
 	public String toSqlString(Criteria criteria, CriteriaQuery criteriaQuery)
-	throws HibernateException {
+			throws HibernateException {
 
 		final SessionFactoryImplementor factory = criteriaQuery.getFactory();
-		final OuterJoinLoadable persister = (OuterJoinLoadable) factory.getEntityPersister( criteriaImpl.getEntityOrClassName() );
+		final OuterJoinLoadable persister = (OuterJoinLoadable) factory.getEntityPersister(criteriaImpl.getEntityOrClassName());
 
-		createAndSetInnerQuery( criteriaQuery, factory );
-		
+		createAndSetInnerQuery(criteriaQuery, factory);
+
+		criteriaImpl.setSession(deriveRootSession(criteria));
+
 		CriteriaJoinWalker walker = new CriteriaJoinWalker(
 				persister,
 				innerQuery,
 				factory,
 				criteriaImpl,
 				criteriaImpl.getEntityOrClassName(),
-				new HashMap(),
+				criteriaImpl.getSession().getEnabledFilters(),
 				innerQuery.getRootSQLALias());
 
 		String sql = walker.getSQLString();
 
 		final StringBuffer buf = new StringBuffer()
-			.append( toLeftSqlString(criteria, criteriaQuery) );
-		if (op!=null) buf.append(' ').append(op).append(' ');
-		if (quantifier!=null) buf.append(quantifier).append(' ');
+				.append(toLeftSqlString(criteria, criteriaQuery));
+		if (op != null) {
+			buf.append(' ').append(op).append(' ');
+		}
+		if (quantifier != null) {
+			buf.append(quantifier).append(' ');
+		}
 		return buf.append('(').append(sql).append(')')
-			.toString();
+				.toString();
 	}
 
-	public TypedValue[] getTypedValues(Criteria criteria, CriteriaQuery criteriaQuery) 
-	throws HibernateException {
+	private SessionImplementor deriveRootSession(Criteria criteria) {
+		if (criteria instanceof CriteriaImpl) {
+			return ((CriteriaImpl) criteria).getSession();
+		} else if (criteria instanceof CriteriaImpl.Subcriteria) {
+			return deriveRootSession(((CriteriaImpl.Subcriteria) criteria).getParent());
+		} else {
+			//todo not sure what to do if it isn't a CriteriaImpl or subcriteria, will it ever be anything else?
+			return null;
+		}
+	}
+
+	public TypedValue[] getTypedValues(Criteria criteria, CriteriaQuery criteriaQuery)
+			throws HibernateException {
 		//the following two lines were added to ensure that this.params is not null, which
 		//can happen with two-deep nested subqueries
 		SessionFactoryImplementor factory = criteriaQuery.getFactory();
 		createAndSetInnerQuery(criteriaQuery, factory);
-		
+
 		Type[] ppTypes = params.getPositionalParameterTypes();
 		Object[] ppValues = params.getPositionalParameterValues();
 		TypedValue[] tv = new TypedValue[ppTypes.length];
-		for ( int i=0; i<ppTypes.length; i++ ) {
-			tv[i] = new TypedValue( ppTypes[i], ppValues[i], EntityMode.POJO );
+		for (int i = 0; i < ppTypes.length; i++) {
+			tv[i] = new TypedValue(ppTypes[i], ppValues[i], EntityMode.POJO);
 		}
 		return tv;
 	}
@@ -108,19 +124,19 @@
 	/**
 	 * Creates the inner query used to extract some useful information about
 	 * types, since it is needed in both methods.
+	 *
 	 * @param criteriaQuery
 	 * @param factory
 	 */
 	private void createAndSetInnerQuery(CriteriaQuery criteriaQuery, final SessionFactoryImplementor factory) {
-		if ( innerQuery == null ) {
+		if (innerQuery == null) {
 			//with two-deep subqueries, the same alias would get generated for
 			//both using the old method (criteriaQuery.generateSQLAlias()), so
 			//that is now used as a fallback if the main criteria alias isn't set
 			String alias;
-			if ( this.criteriaImpl.getAlias() == null ) {
+			if (this.criteriaImpl.getAlias() == null) {
 				alias = criteriaQuery.generateSQLAlias();
-			}
-			else {
+			} else {
 				alias = this.criteriaImpl.getAlias() + "_";
 			}
 
@@ -130,7 +146,7 @@
 					criteriaImpl.getEntityOrClassName(), //implicit polymorphism not supported (would need a union)
 					alias,
 					criteriaQuery
-				);
+			);
 
 			params = innerQuery.getQueryParameters();
 			types = innerQuery.getProjectedTypes();
Index: core/src/main/java/org/hibernate/engine/QueryParameters.java
===================================================================
--- core/src/main/java/org/hibernate/engine/QueryParameters.java	(revision 15151)
+++ core/src/main/java/org/hibernate/engine/QueryParameters.java	(working copy)
@@ -69,13 +69,13 @@
 	private boolean callable = false;
 	private boolean autodiscovertypes = false;
 	private boolean isNaturalKeyLookup;
-	
+
 	private final ResultTransformer resultTransformer; // why is all others non final ?
-	
+
 	private String processedSQL;
 	private Type[] processedPositionalParameterTypes;
 	private Object[] processedPositionalParameterValues;
-	
+
 	public QueryParameters() {
 		this( ArrayHelper.EMPTY_TYPE_ARRAY, ArrayHelper.EMPTY_OBJECT_ARRAY );
 	}
@@ -104,13 +104,13 @@
 	) {
 		this(
 			positionalParameterTypes,
-			postionalParameterValues, 
-			null, 
-			null, 
-			false, 
-			null, 
+			postionalParameterValues,
 			null,
+			null,
 			false,
+			null,
+			null,
+			false,
 			null
 		);
 	}
@@ -142,8 +142,8 @@
 				null,
 				false,
 				false,
-				null, 
 				null,
+				null,
 				collectionKeys,
 				null
 			);
@@ -169,7 +169,7 @@
 			rowSelection,
 			false,
 			cacheable,
-			cacheRegion, 
+			cacheRegion,
 			comment,
 			null,
 			transformer
@@ -189,7 +189,7 @@
 			//final boolean forceCacheRefresh,
 			final String comment,
 			final Serializable[] collectionKeys,
-			ResultTransformer transformer			
+			ResultTransformer transformer
 	) {
 		this.positionalParameterTypes = positionalParameterTypes;
 		this.positionalParameterValues = positionalParameterValues;
@@ -204,7 +204,7 @@
 		this.readOnly = readOnly;
 		this.resultTransformer = transformer;
 	}
-	
+
 	public QueryParameters(
 		final Type[] positionalParameterTypes,
 		final Object[] positionalParameterValues,
@@ -223,13 +223,13 @@
 		final ResultTransformer transformer
 	) {
 		this(
-			positionalParameterTypes, 
-			positionalParameterValues, 
-			namedParameters, 
-			lockModes, 
-			rowSelection, 
-			readOnly, 
-			cacheable, 
+			positionalParameterTypes,
+			positionalParameterValues,
+			namedParameters,
+			lockModes,
+			rowSelection,
+			readOnly,
+			cacheable,
 			cacheRegion,
 			comment,
 			collectionKeys,
@@ -259,7 +259,7 @@
 	public RowSelection getRowSelection() {
 		return rowSelection;
 	}
-	
+
 	public ResultTransformer getResultTransformer() {
 		return resultTransformer;
 	}
@@ -292,8 +292,8 @@
 		Printer print = new Printer(factory);
 		if (positionalParameterValues.length!=0) {
 			log.trace(
-					"parameters: " + 
-					print.toString(positionalParameterTypes, positionalParameterValues) 
+					"parameters: " +
+					print.toString(positionalParameterTypes, positionalParameterValues)
 				);
 		}
 		if (namedParameters!=null) {
@@ -322,7 +322,7 @@
 		int values = positionalParameterValues==null ? 0 : positionalParameterValues.length;
 		if (types!=values) {
 			throw new QueryException(
-					"Number of positional parameter types:" + types + 
+					"Number of positional parameter types:" + types +
 					" does not match number of positional parameters: " + values
 				);
 		}
@@ -385,19 +385,19 @@
 	}
 
 	public void setCallable(boolean callable) {
-		this.callable = callable;		
+		this.callable = callable;
 	}
 
 	public boolean isCallable() {
 		return callable;
 	}
-	
+
 	public boolean hasAutoDiscoverScalarTypes() {
 		return autodiscovertypes;
 	}
 
 	public void processFilters(String sql, SessionImplementor session) {
-		
+
 		if ( session.getEnabledFilters().size()==0 || sql.indexOf(ParserHelper.HQL_VARIABLE_PREFIX)<0 ) {
 			// HELLA IMPORTANT OPTIMIZATION!!!
 			processedPositionalParameterValues = getPositionalParameterValues();
@@ -405,7 +405,7 @@
 			processedSQL = sql;
 		}
 		else {
-			
+
 			Dialect dialect = session.getFactory().getDialect();
 			String symbols = new StringBuffer().append( ParserHelper.HQL_SEPARATORS )
 					.append( dialect.openQuote() )
@@ -413,11 +413,12 @@
 					.toString();
 			StringTokenizer tokens = new StringTokenizer( sql, symbols, true );
 			StringBuffer result = new StringBuffer();
-		
+
 			List parameters = new ArrayList();
 			List parameterTypes = new ArrayList();
-		
-			while ( tokens.hasMoreTokens() ) {
+
+			int positionalIndex = 0;
+			while (tokens.hasMoreTokens()) {
 				final String token = tokens.nextToken();
 				if ( token.startsWith( ParserHelper.HQL_VARIABLE_PREFIX ) ) {
 					String filterParameterName = token.substring( 1 );
@@ -442,15 +443,18 @@
 					}
 				}
 				else {
-					result.append( token );
+					if ("?".equals(token) && positionalIndex < getPositionalParameterValues().length) {
+						parameters.add(getPositionalParameterValues()[positionalIndex]);
+						parameterTypes.add(getPositionalParameterTypes()[positionalIndex]);
+						positionalIndex++;
+					}
+					result.append(token);
 				}
 			}
-			parameters.addAll( Arrays.asList( getPositionalParameterValues() ) );
-			parameterTypes.addAll( Arrays.asList( getPositionalParameterTypes() ) );
 			processedPositionalParameterValues = parameters.toArray();
 			processedPositionalParameterTypes = ( Type[] ) parameterTypes.toArray( new Type[0] );
 			processedSQL = result.toString();
-			
+
 		}
 	}
 
Index: testsuite/src/test/java/org/hibernate/test/filter/DynamicFilterTest.java
===================================================================
--- testsuite/src/test/java/org/hibernate/test/filter/DynamicFilterTest.java	(revision 15151)
+++ testsuite/src/test/java/org/hibernate/test/filter/DynamicFilterTest.java	(working copy)
@@ -13,16 +13,15 @@
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
-import org.hibernate.EntityMode;
-import org.hibernate.FetchMode;
-import org.hibernate.Hibernate;
-import org.hibernate.Session;
-import org.hibernate.Transaction;
+import org.hibernate.*;
 import org.hibernate.cache.CacheKey;
 import org.hibernate.cache.entry.CollectionCacheEntry;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.criterion.Restrictions;
+import org.hibernate.criterion.DetachedCriteria;
+import org.hibernate.criterion.Property;
+import org.hibernate.criterion.Subqueries;
 import org.hibernate.engine.SessionImplementor;
 import org.hibernate.impl.SessionFactoryImpl;
 import org.hibernate.junit.functional.FunctionalTestCase;
@@ -176,6 +175,83 @@
 		testData.release();
 	}
 
+	public void testHQLSubqueryWithFilters() {
+		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		// HQL subquery with filters test
+		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		log.info("Starting HQL subquery with filters tests");
+		TestData testData = new TestData();
+		testData.prepare();
+
+		Session session = openSession();
+		session.enableFilter("region").setParameter("region", "APAC");
+
+		log.info("query against Department with a subquery on Salesperson in the APAC reqion...");
+
+		List departments = session.createQuery("select d from Department as d where d.id in (select s.department from Salesperson s where s.name = ?)").setString(0, "steve").list();
+
+		assertEquals("Incorrect department count", 1, departments.size());
+
+		log.info("query against Department with a subquery on Salesperson in the FooBar reqion...");
+
+		session.enableFilter("region").setParameter("region", "Foobar");
+		departments = session.createQuery("select d from Department as d where d.id in (select s.department from Salesperson s where s.name = ?)").setString(0, "steve").list();
+
+		assertEquals("Incorrect department count", 0, departments.size());
+
+		log.info("query against Order with a subquery for line items with a subquery line items where the product name is Acme Hair Gel and the quantity is greater than 1 in a given region for a given buyer");
+		session.enableFilter("region").setParameter("region", "APAC");
+
+		List orders = session.createQuery("select o from Order as o where exists (select li.id from LineItem li, Product as p where p.id = li.product and li.quantity >= ? and p.name = ?) and o.buyer = ?")
+				.setLong(0, 1L).setString(1, "Acme Hair Gel").setString(2, "gavin").list();
+
+		assertEquals("Incorrect orders count", 1, orders.size());
+
+		log.info("query against Order with a subquery for line items with a subquery line items where the product name is Acme Hair Gel and the quantity is greater than 1 in a given region and the product is effective as of last month");
+
+		session.enableFilter("region").setParameter("region", "APAC");
+		session.enableFilter("effectiveDate").setParameter("asOfDate", testData.lastMonth.getTime());
+
+		orders = session.createQuery("select o from Order as o where exists (select li.id from LineItem li where li.quantity >= ? and li.product in (select p.id from Product p where p.name = ?)) and o.buyer = ?")
+				.setLong(0, 1L).setString(1, "Acme Hair Gel").setString(2, "gavin").list();
+
+		assertEquals("Incorrect orders count", 1, orders.size());
+
+
+		log.info("query against Order with a subquery for line items with a subquery line items where the product name is Acme Hair Gel and the quantity is greater than 1 in a given region and the product is effective as of 4 months ago");
+
+		session.enableFilter("region").setParameter("region", "APAC");
+		session.enableFilter("effectiveDate").setParameter("asOfDate", testData.fourMonthsAgo.getTime());
+
+		orders = session.createQuery("select o from Order as o where exists (select li.id from LineItem li where li.quantity >= ? and li.product in (select p.id from Product p where p.name = ?)) and o.buyer = ?")
+				.setLong(0, 1L).setString(1, "Acme Hair Gel").setString(2, "gavin").list();
+
+		assertEquals("Incorrect orders count", 0, orders.size());
+
+		log.info("query against Order with a subquery for line items with a subquery line items where the product name is Acme Hair Gel and the quantity is greater than 1 in a given region and the product is effective as of last month with named types");
+
+		session.enableFilter("region").setParameter("region", "APAC");
+		session.enableFilter("effectiveDate").setParameter("asOfDate", testData.lastMonth.getTime());
+
+		orders = session.createQuery("select o from Order as o where exists (select li.id from LineItem li where li.quantity >= :quantity and li.product in (select p.id from Product p where p.name = :name)) and o.buyer = :buyer")
+				.setLong("quantity", 1L).setString("name", "Acme Hair Gel").setString("buyer", "gavin").list();
+
+		assertEquals("Incorrect orders count", 1, orders.size());
+
+		log.info("query against Order with a subquery for line items with a subquery line items where the product name is Acme Hair Gel and the quantity is greater than 1 in a given region and the product is effective as of last month with mixed types");
+
+		session.enableFilter("region").setParameter("region", "APAC");
+		session.enableFilter("effectiveDate").setParameter("asOfDate", testData.lastMonth.getTime());
+
+		orders = session.createQuery("select o from Order as o where exists (select li.id from LineItem li where li.quantity >= ? and li.product in (select p.id from Product p where p.name = ?)) and o.buyer = :buyer")
+				.setLong(0, 1L).setString(1, "Acme Hair Gel").setString("buyer", "gavin").list();
+
+		assertEquals("Incorrect orders count", 1, orders.size());
+
+		session.close();
+		testData.release();
+	}
+
 	public void testCriteriaQueryFilters() {
 		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		// Criteria-query test
@@ -210,6 +286,87 @@
 		testData.release();
 	}
 
+	public void testCriteriaSubqueryWithFilters() {
+		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		// Criteria-subquery test
+		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		log.info("Starting Criteria-subquery filter tests");
+		TestData testData = new TestData();
+		testData.prepare();
+
+		Session session = openSession();
+		session.enableFilter("region").setParameter("region", "APAC");
+
+		log.info("Criteria query against Department with a subquery on Salesperson in the APAC reqion...");
+		DetachedCriteria salespersonSubquery = DetachedCriteria.forClass(Salesperson.class)
+				.add(Restrictions.eq("name", "steve"))
+				.setProjection(Property.forName("department"));
+
+		Criteria departmentsQuery = session.createCriteria(Department.class).add(Subqueries.propertyIn("id", salespersonSubquery));
+		List departments = departmentsQuery.list();
+
+		assertEquals("Incorrect department count", 1, departments.size());
+
+		log.info("Criteria query against Department with a subquery on Salesperson in the FooBar reqion...");
+
+		session.enableFilter("region").setParameter("region", "Foobar");
+		departments = departmentsQuery.list();
+
+		assertEquals("Incorrect department count", 0, departments.size());
+
+		log.info("Criteria query against Order with a subquery for line items with a subquery on product and sold by a given sales person...");
+		session.enableFilter("region").setParameter("region", "APAC");
+
+		DetachedCriteria lineItemSubquery = DetachedCriteria.forClass(LineItem.class)
+				.add(Restrictions.ge("quantity", 1L))
+				.createCriteria("product")
+				.add(Restrictions.eq("name", "Acme Hair Gel"))
+				.setProjection(Property.forName("id"));
+
+		List orders = session.createCriteria(Order.class)
+				.add(Subqueries.exists(lineItemSubquery))
+				.add(Restrictions.eq("buyer", "gavin"))
+				.list();
+
+		assertEquals("Incorrect orders count", 1, orders.size());
+
+		log.info("query against Order with a subquery for line items with a subquery line items where the product name is Acme Hair Gel and the quantity is greater than 1 in a given region and the product is effective as of last month");
+		session.enableFilter("region").setParameter("region", "APAC");
+		session.enableFilter("effectiveDate").setParameter("asOfDate", testData.lastMonth.getTime());
+
+		DetachedCriteria productSubquery = DetachedCriteria.forClass(Product.class)
+				.add(Restrictions.eq("name", "Acme Hair Gel"))
+				.setProjection(Property.forName("id"));
+
+		lineItemSubquery = DetachedCriteria.forClass(LineItem.class)
+				.add(Restrictions.ge("quantity", 1L))
+				.createCriteria("product")
+				.add(Subqueries.propertyIn("id", productSubquery))
+				.setProjection(Property.forName("id"));
+
+		orders = session.createCriteria(Order.class)
+				.add(Subqueries.exists(lineItemSubquery))
+				.add(Restrictions.eq("buyer", "gavin"))
+				.list();
+
+		assertEquals("Incorrect orders count", 1, orders.size());
+
+
+		log.info("query against Order with a subquery for line items with a subquery line items where the product name is Acme Hair Gel and the quantity is greater than 1 in a given region and the product is effective as of 4 months ago");
+		session.enableFilter("region").setParameter("region", "APAC");
+		session.enableFilter("effectiveDate").setParameter("asOfDate", testData.fourMonthsAgo.getTime());
+
+		orders = session.createCriteria(Order.class)
+				.add(Subqueries.exists(lineItemSubquery))
+				.add(Restrictions.eq("buyer", "gavin"))
+				.list();
+
+		assertEquals("Incorrect orders count", 0, orders.size());
+
+		session.close();
+		testData.release();
+	}
+
 	public void testGetFilters() {
 		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		// Get() test
