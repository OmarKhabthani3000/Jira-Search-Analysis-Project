Index: test/org/hibernate/test/dialect/DerbyDialectTestCase.java
===================================================================
--- test/org/hibernate/test/dialect/DerbyDialectTestCase.java	Thu Jun 18 14:53:18 MDT 2009
+++ test/org/hibernate/test/dialect/DerbyDialectTestCase.java	Thu Jun 18 14:53:18 MDT 2009
@@ -0,0 +1,113 @@
+package org.hibernate.test.dialect;
+
+import junit.framework.TestCase;
+import org.hibernate.dialect.DerbyDialect;
+
+/**
+ * User: evan
+ * Date: Jun 12, 2009
+ * Time: 2:30:53 PM
+ */
+public class DerbyDialectTestCase extends TestCase
+{
+    
+    public void testInsertLimitClause()
+    {
+        final DerbyDialect derbyDialect = new DerbyDialect();
+        final int limit = 50;
+
+        final String input = "SELECT * FROM tablename t WHERE t.cat = 5";
+
+        /*
+            SELECT * FROM (
+                SELECT ROW_NUMBER() OVER() AS rownum, myLargeTable.*
+                FROM myLargeTable
+            ) AS tmp
+            WHERE rownum <= 5;
+        */
+//        final String expected = "SELECT * FROM (SELCT ROW_NUMBER() OVER() AS hib_rownum, tablename.* FROM tablename) as hib_tmp WHERE hib_rownum <= 50";
+
+        /*
+            SELECT * FROM (
+                SELECT ROW_NUMBER() OVER () AS R, g.*
+                FROM (select * from APP.CHANNEL where id>294912 ) as g
+            ) AS TR
+            WHERE R <= 10;
+        */
+
+/*
+        final String expected =
+                "SELECT * FROM (" +
+                    "SELECT ROW_NUMBER() OVER() AS hib_rownum, hib_rownum_select.* " +
+                    "FROM (SELECT * FROM tablename t WHERE t.cat = 5) as hib_rownum_select" +
+                ") as hib_rownum_tmp " +
+                "WHERE hib_rownum <= " + limit;
+*/
+
+        final String expected = "SELECT * FROM tablename t WHERE t.cat = 5 FETCH FIRST " + limit + " ROWS ONLY";
+
+        final String actual = derbyDialect.getLimitString(input, 0, limit);
+
+        assertEquals(expected, actual);
+    }
+
+    public void testInsertLimitWithOffsetClause()
+    {
+        final DerbyDialect derbyDialect = new DerbyDialect();
+        final int limit = 50;
+        final int offset = 200;
+
+//        final String expected =
+//                "SELECT * FROM (" +
+//                    "SELECT ROW_NUMBER() OVER() AS hib_rownum, hib_rownum_select.* " +
+//                    "FROM (SELECT * FROM tablename t WHERE t.cat = 5) as hib_rownum_select" +
+//                ") as hib_rownum_tmp " +
+//                "WHERE hib_rownum > " + offset + " AND hib_rownum <= " + (offset+limit);
+
+        final String input = "SELECT * FROM tablename t WHERE t.cat = 5";
+        final String expected = "SELECT * FROM tablename t WHERE t.cat = 5 OFFSET " + offset + " ROWS FETCH NEXT " + limit + " ROWS ONLY";
+        final String actual = derbyDialect.getLimitString(input, offset, limit);
+
+        assertEquals(expected, actual);
+    }
+
+
+    public void testInsertLimitWithForUpdateClause()
+    {
+        final DerbyDialect derbyDialect = new DerbyDialect();
+        final int limit = 50;
+        final int offset = 200;
+                
+        final String input = "SELECT c11 AS col1, c12 AS col2, c13 FROM t1 FOR UPDATE of c11,c13";
+        final String expected = "SELECT c11 AS col1, c12 AS col2, c13 FROM t1 OFFSET " + offset + " ROWS FETCH NEXT " + limit + " ROWS ONLY FOR UPDATE of c11,c13";
+        final String actual = derbyDialect.getLimitString(input, offset, limit);
+
+        assertEquals(expected, actual);
+    }
+
+    public void testInsertLimitWithWithClause()
+    {
+        final DerbyDialect derbyDialect = new DerbyDialect();
+        final int limit = 50;
+        final int offset = 200;
+
+        final String input = "SELECT c11 AS col1, c12 AS col2, c13 FROM t1 WHERE flight_id BETWEEN 'AA1111' AND 'AA1112' WITH RR";
+        final String expected = "SELECT c11 AS col1, c12 AS col2, c13 FROM t1 WHERE flight_id BETWEEN 'AA1111' AND 'AA1112' OFFSET " + offset + " ROWS FETCH NEXT " + limit + " ROWS ONLY WITH RR";
+        final String actual = derbyDialect.getLimitString(input, offset, limit);
+
+        assertEquals(expected, actual);
+    }
+
+    public void testInsertLimitWithForUpdateAndWithClauses()
+    {
+        final DerbyDialect derbyDialect = new DerbyDialect();
+        final int limit = 50;
+        final int offset = 200;
+
+        final String input = "SELECT c11 AS col1, c12 AS col2, c13 FROM t1 WHERE flight_id BETWEEN 'AA1111' AND 'AA1112' FOR UPDATE of c11,c13 WITH RR";
+        final String expected = "SELECT c11 AS col1, c12 AS col2, c13 FROM t1 WHERE flight_id BETWEEN 'AA1111' AND 'AA1112' OFFSET " + offset + " ROWS FETCH NEXT " + limit + " ROWS ONLY FOR UPDATE of c11,c13 WITH RR";
+        final String actual = derbyDialect.getLimitString(input, offset, limit);
+
+        assertEquals(expected, actual);
+    }
+}
Index: src/org/hibernate/dialect/DerbyDialect.java
===================================================================
--- src/org/hibernate/dialect/DerbyDialect.java	(revision 10250)
+++ src/org/hibernate/dialect/DerbyDialect.java	Thu Jun 18 14:56:53 MDT 2009
@@ -20,7 +20,7 @@
 /**
  * @author Simon Johnston
  *
- * Hibernate Dialect for Cloudscape 10 - aka Derby. This implements both an 
+ * Hibernate Dialect for Cloudscape 10 - aka Derby. This implements both an
  * override for the identity column generator as well as for the case statement
  * issue documented at:
  * http://www.jroller.com/comments/kenlars99/Weblog/cloudscape_soon_to_be_derby
@@ -60,18 +60,148 @@
 	}
 
 	public boolean supportsLimit() {
-		return false;
+		return true;
 	}
 
 	public boolean supportsLimitOffset() {
+		return true;
+	}
+
+    /**
+     * This implementation uses directly passed in values for offset and limit.
+     * @return false
+     */
+    public boolean supportsVariableLimit()
+    {
-		return false;
-	}
+        return false;
+    }
 
+    public String getLimitString(String querySelect, final int offset, final int limit)
+    {
+        final String sql = addFetchFirstClause(querySelect, offset, limit);
+//        final String sql = addRowNumberOverClause(querySelect, offset, limit); //alternate limit claus syntax
+        return sql;
+    }
+
+    /**
+     * From Derby 10.5 Docs:
+     * <p>
+     * Query<br/>
+     * [ORDER BY clause]<br/>
+     * [result offset clause]<br/>
+     * [fetch first clause]<br/>
+     * [FOR UPDATE clause]<br/>
+     * [WITH {RR|RS|CS|UR}]<br/>
+     * <br/>
+     * @param querySelect
+     * @param offset
+     * @param limit
+     * @return
+     */
+    private String addFetchFirstClause(final String querySelect, final int offset, final int limit)
+    {
+        StringBuffer sb = new StringBuffer(querySelect.length() + 50);
+
+        final String normalizedSelect = querySelect.toLowerCase().trim();
+        final int forUpdateIndex = normalizedSelect.lastIndexOf("for update");
+        int withClauseIndex = -1;
+
+
+        if(hasForUpdateClause(forUpdateIndex)) {
+            sb.append(querySelect.substring(0,forUpdateIndex-1));
+        }
+        else if(hasWithClause(normalizedSelect)) {
+            withClauseIndex = getWithIndex(querySelect);
+            sb.append(querySelect.substring(0, withClauseIndex-1));
+        }
+        else {
+            sb.append(querySelect);
+        }
+
+        if(offset == 0) {
+            sb.append(" FETCH FIRST ");
+        }
+        else {
+            sb.append(" OFFSET ")
+              .append(offset)
+              .append(" ROWS FETCH NEXT ");
+        }
+
+        sb.append(limit)
+          .append(" ROWS ONLY");
+
+        if(hasForUpdateClause(forUpdateIndex)) {
+            sb.append(' ');
+            sb.append(querySelect.substring(forUpdateIndex));
+        }
+        else if (hasWithClause(normalizedSelect))
+        {
+            sb.append(' ');
+            withClauseIndex = getWithIndex(querySelect);
+            sb.append(querySelect.substring(withClauseIndex));
+        }
+
+        return sb.toString();
+    }
+
+    private boolean hasForUpdateClause(int forUpdateIndex)
+    {
+        return forUpdateIndex >= 0;
+    }
+
+    private boolean hasWithClause(String normalizedSelect)
+    {
+        return normalizedSelect.startsWith("with ", normalizedSelect.length()-7);
+    }
+
+    private int getWithIndex(String querySelect)
+    {
+        int i = querySelect.lastIndexOf("with ");
+        if(i < 0) {
+            i = querySelect.lastIndexOf("WITH ");
+        }
+        return i;
+    }
+
+    private String addRowNumberOverClause(String querySelect, int offset, int limit)
+    {
+
+        //84SELECT * FROM (SELECT ROW_NUMBER() OVER() AS hib_rownum, hib_rownum_select.* FROM (
+        //59) as hib_rownum_select) as hib_rownum_tmp WHERE hib_rownum
+        //18> AND hib_rownum
+        final int origsize = querySelect.length();
+        final int addlChars = (offset == 0) ? 144 : 162;
+        final int newsize = origsize + addlChars;
+
+        StringBuffer sb = new StringBuffer(newsize)
+            .append(querySelect)
+            .insert(origsize,") as hib_rownum_select" +
+                    ") as hib_rownum_tmp " +
+                    "WHERE hib_rownum " )
+            .insert(0,"SELECT * FROM (" +
+                       "SELECT ROW_NUMBER() OVER() AS hib_rownum, hib_rownum_select.* " +
+                       "FROM (");
+
+        if(offset > 0) {
+            sb.append("> ")
+              .append(offset)
+              .append(" AND hib_rownum ");
+        }
+
+        sb.append("<= ")
+          .append(limit+offset);
+
+        final String sql = sb.toString();
+        return sql;
+    }
+
+
-	public String getQuerySequencesString() {
-	   return null ;
-	}
+    public String getQuerySequencesString() {
+        return null ;
+    }
 
+
-	/**
+    /**
 	 * A specialized function template to emulate the ANSI trim function on Derby DB
 	 * since it does not support the full trim specification.  However, we cannot even
 	 * fully emulate it because there is not standard 'replace' function either. :(
