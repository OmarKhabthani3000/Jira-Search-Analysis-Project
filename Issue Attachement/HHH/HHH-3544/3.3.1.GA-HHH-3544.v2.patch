Index: core/src/main/java/org/hibernate/action/EntityIdentityInsertAction.java
===================================================================
--- core/src/main/java/org/hibernate/action/EntityIdentityInsertAction.java	(revision 15933)
+++ core/src/main/java/org/hibernate/action/EntityIdentityInsertAction.java	(working copy)
@@ -55,6 +55,10 @@
 		this.isDelayed = isDelayed;
 		delayedEntityKey = isDelayed ? generateDelayedEntityKey() : null;
 	}
+	
+	public Object[] getState() {
+		return state;
+	}
 
 	public void execute() throws HibernateException {
 		
Index: core/src/main/java/org/hibernate/engine/ActionQueue.java
===================================================================
--- core/src/main/java/org/hibernate/engine/ActionQueue.java	(revision 15933)
+++ core/src/main/java/org/hibernate/engine/ActionQueue.java	(working copy)
@@ -30,9 +30,11 @@
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.IdentityHashMap;
 import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 
 import org.slf4j.Logger;
@@ -44,14 +46,22 @@
 import org.hibernate.action.CollectionRecreateAction;
 import org.hibernate.action.CollectionRemoveAction;
 import org.hibernate.action.CollectionUpdateAction;
+import org.hibernate.action.EntityAction;
 import org.hibernate.action.EntityDeleteAction;
 import org.hibernate.action.EntityIdentityInsertAction;
 import org.hibernate.action.EntityInsertAction;
 import org.hibernate.action.EntityUpdateAction;
 import org.hibernate.action.Executable;
 import org.hibernate.cache.CacheException;
+import org.hibernate.persister.entity.EntityPersister;
+import org.hibernate.proxy.HibernateProxy;
+import org.hibernate.type.EntityType;
+import org.hibernate.type.ForeignKeyDirection;
+import org.hibernate.type.OneToOneType;
 import org.hibernate.type.Type;
 
+import com.sun.org.apache.bcel.internal.generic.GETSTATIC;
+
 /**
  * Responsible for maintaining the queue of actions related to events.
  * </p>
@@ -155,15 +165,133 @@
 	 * @throws HibernateException error executing queued insertion actions.
 	 */
 	public void executeInserts() throws HibernateException {
+		orderInserts();
 		executeActions( insertions );
 	}
 
+	// fix for http://opensource.atlassian.com/projects/hibernate/browse/HHH-3544
+	private void orderInserts() {
+		int originalInsertionsSize = insertions.size();
+		IdentityHashMap insertionDependencyGraph = new IdentityHashMap();
+		
+		for ( Iterator actionItr = insertions.iterator(); actionItr.hasNext(); ) {
+			EntityAction action = ( EntityAction ) actionItr.next();
+			ArrayList dependencies = new ArrayList();
+			insertionDependencyGraph.put(action, dependencies );
+			
+			String entityName = action.getEntityName();
+			Object[] state = null;
+			if (action instanceof EntityInsertAction) {
+				state = ((EntityInsertAction)action).getState();
+			} else if (action instanceof EntityIdentityInsertAction) {
+				state = ((EntityIdentityInsertAction)action).getState();
+			}
+			Type[] propertyTypes = action.getPersister().getPropertyTypes();
+			
+			for (int i = 0; i < propertyTypes.length; i++) {
+				Type propertyType = propertyTypes[i];
+				
+				if ( propertyType.isEntityType()) {
+					EntityType entityType = (EntityType) propertyType;
+					
+					if (entityType.isReferenceToPrimaryKey() && ForeignKeyDirection.FOREIGN_KEY_FROM_PARENT.equals(entityType.getForeignKeyDirection())) {
+
+						if (state[i] != null && !(state[i] instanceof HibernateProxy)) { // we are not interested in null or already persistent entities.
+							// get the actual entity name - e.g. consider subclasses.
+							EntityPersister stateEntityPersister = session.getEntityPersister(entityType.getAssociatedEntityName(), state[i]);
+							String stateEntityName = stateEntityPersister.getEntityName();
+							
+							Serializable stateId = ForeignKeys.getEntityIdentifierIfNotUnsaved( stateEntityName, state[i], session );
+							//TODO: we could check if the field is nullable to explicitly nullify the data and schedule an update so that we can minimize the dependencies 
+							
+							//only add dependencies if the dependency is also in the insertions - e.g. it is going to be inserted as well
+							for (Iterator dependencyActionItr = insertions.iterator(); dependencyActionItr.hasNext();) {
+								EntityAction dependencyAction = ( EntityAction ) dependencyActionItr.next();
+								
+								if (stateEntityPersister.isIdentifierAssignedByInsert()) {
+									if (dependencyAction instanceof EntityIdentityInsertAction) {
+										if (((EntityIdentityInsertAction)dependencyAction).getEntityName().equals(stateEntityName) &&
+												((EntityIdentityInsertAction)dependencyAction).getDelayedEntityKey() != null &&
+												((EntityIdentityInsertAction)dependencyAction).getDelayedEntityKey().getIdentifier() != null &&
+												((EntityIdentityInsertAction)dependencyAction).getDelayedEntityKey().getIdentifier().equals(stateId)) {
+											dependencies.add(dependencyAction);
+										}
+									}
+								} else {
+									if (dependencyAction.getEntityName().equals(stateEntityName) && dependencyAction.getId() != null && dependencyAction.getId().equals(stateId)) {
+										dependencies.add(dependencyAction);
+									}
+								}
+							}
+						}
+					}
+				}
+			}
+		}
+		
+
+		ArrayList newInsertions = new ArrayList();
+		IdentityHashMap processedInsertionsMap = new IdentityHashMap();
+		
+		while (!insertions.isEmpty()) {
+			boolean atleastOneActionProcessed = false;
+			
+			for (Iterator insertionIterator = insertions.iterator(); insertionIterator.hasNext();) {
+				EntityAction action = (EntityAction)insertionIterator.next();
+				ArrayList dependentActions = (ArrayList)insertionDependencyGraph.get(action);
+	
+				if (dependentActions.isEmpty()) {
+					newInsertions.add(action);
+					processedInsertionsMap.put(action, Boolean.TRUE);
+					insertionIterator.remove();
+					atleastOneActionProcessed = true;
+				} else {
+					boolean allDependentActionsAreProcessed = true;
+					for (Iterator dependentActionIterator = dependentActions.iterator(); dependentActionIterator.hasNext();) {
+						EntityAction dependentAction = (EntityAction)dependentActionIterator.next();
+						if (!processedInsertionsMap.containsKey(dependentAction)) {
+							allDependentActionsAreProcessed = false;
+							break;
+						}
+					}
+					
+					if (allDependentActionsAreProcessed) {
+						newInsertions.add(action);
+						processedInsertionsMap.put(action, Boolean.TRUE);
+						insertionIterator.remove();
+						atleastOneActionProcessed = true;
+					} else {
+						// postpone the add
+					}
+				}
+			}
+			
+			if (!atleastOneActionProcessed) {
+				break;
+			}
+		}
+
+		// add any leftovers - probably interdependent not-null entities.
+		for (Iterator insertionIterator = insertions.iterator(); insertionIterator.hasNext();) {
+			EntityAction action = (EntityAction)insertionIterator.next();
+			newInsertions.add(action);
+		}
+		
+		insertions.clear();
+		insertions.addAll(newInsertions);
+		
+		if (insertions.size() != originalInsertionsSize) {
+			throw new AssertionFailure( "Exception sorting the insert actions");			
+		}
+	}
+	
 	/**
 	 * Perform all currently queued actions.
 	 *
 	 * @throws HibernateException error executing queued actions.
 	 */
 	public void executeActions() throws HibernateException {
+		orderInserts();
 		executeActions( insertions );
 		executeActions( updates );
 		executeActions( collectionRemovals );
Index: core/src/main/java/org/hibernate/engine/EntityEntry.java
===================================================================
--- core/src/main/java/org/hibernate/engine/EntityEntry.java	(revision 15933)
+++ core/src/main/java/org/hibernate/engine/EntityEntry.java	(working copy)
@@ -221,7 +221,7 @@
 	}
 	
 	public boolean isNullifiable(boolean earlyInsert, SessionImplementor session) {
-		return getStatus() == Status.SAVING || (
+		return /*getStatus() == Status.SAVING || */(
 				earlyInsert ?
 						!isExistsInDatabase() :
 						session.getPersistenceContext().getNullifiableEntityKeys()
Index: core/src/main/java/org/hibernate/engine/ForeignKeys.java
===================================================================
--- core/src/main/java/org/hibernate/engine/ForeignKeys.java	(revision 15933)
+++ core/src/main/java/org/hibernate/engine/ForeignKeys.java	(working copy)
@@ -64,10 +64,10 @@
 		 * been inserted in the database, where the foreign key
 		 * points toward that entity
 		 */
-		public void nullifyTransientReferences(final Object[] values, final Type[] types) 
+		public void nullifyTransientReferences(final Object[] values, final Type[] types, final EntityPersister persister) 
 		throws HibernateException {
 			for ( int i = 0; i < types.length; i++ ) {
-				values[i] = nullifyTransientReferences( values[i], types[i] );
+				values[i] = nullifyTransientReferences( values[i], types[i], persister.getPropertyNullability()[i] );
 			}
 		}
 	
@@ -77,7 +77,7 @@
 		 * otherwise. This is how Hibernate avoids foreign key constraint
 		 * violations.
 		 */
-		private Object nullifyTransientReferences(final Object value, final Type type) 
+		private Object nullifyTransientReferences(final Object value, final Type type, boolean propertyNullability) 
 		throws HibernateException {
 			if ( value == null ) {
 				return null;
@@ -89,11 +89,11 @@
 				}
 				else {
 					String entityName = entityType.getAssociatedEntityName();
-					return isNullifiable(entityName, value) ? null : value;
+					return isNullifiable(entityName, value, propertyNullability) ? null : value;
 				}
 			}
 			else if ( type.isAnyType() ) {
-				return isNullifiable(null, value) ? null : value;
+				return isNullifiable(null, value, propertyNullability) ? null : value;
 			}
 			else if ( type.isComponentType() ) {
 				AbstractComponentType actype = (AbstractComponentType) type;
@@ -101,7 +101,7 @@
 				Type[] subtypes = actype.getSubtypes();
 				boolean substitute = false;
 				for ( int i = 0; i < subvalues.length; i++ ) {
-					Object replacement = nullifyTransientReferences( subvalues[i], subtypes[i] );
+					Object replacement = nullifyTransientReferences( subvalues[i], subtypes[i], false );
 					if ( replacement != subvalues[i] ) {
 						substitute = true;
 						subvalues[i] = replacement;
@@ -119,7 +119,7 @@
 		 * Determine if the object already exists in the database, 
 		 * using a "best guess"
 		 */
-		private boolean isNullifiable(final String entityName, Object object) 
+		private boolean isNullifiable(final String entityName, Object object, boolean propertyNullability) 
 		throws HibernateException {
 			
 			if (object==LazyPropertyInitializer.UNFETCHED_PROPERTY) return false; //this is kinda the best we can do...
@@ -160,6 +160,9 @@
 				return isTransient(entityName, object, null, session);
 			}
 			else {
+				if (entityEntry.getStatus() == Status.SAVING && propertyNullability) {
+					return true;
+				}
 				return entityEntry.isNullifiable(isEarlyInsert, session);
 			}
 	
Index: core/src/main/java/org/hibernate/event/def/AbstractSaveEventListener.java
===================================================================
--- core/src/main/java/org/hibernate/event/def/AbstractSaveEventListener.java	(revision 15933)
+++ core/src/main/java/org/hibernate/event/def/AbstractSaveEventListener.java	(working copy)
@@ -309,7 +309,7 @@
 		);
 
 		new ForeignKeys.Nullifier( entity, false, useIdentityColumn, source )
-				.nullifyTransientReferences( values, types );
+				.nullifyTransientReferences( values, types, persister );
 		new Nullability( source ).checkNullability( values, persister, false );
 
 		if ( useIdentityColumn ) {
Index: core/src/main/java/org/hibernate/event/def/DefaultDeleteEventListener.java
===================================================================
--- core/src/main/java/org/hibernate/event/def/DefaultDeleteEventListener.java	(revision 15933)
+++ core/src/main/java/org/hibernate/event/def/DefaultDeleteEventListener.java	(working copy)
@@ -268,7 +268,7 @@
 		cascadeBeforeDelete( session, persister, entity, entityEntry, transientEntities );
 
 		new ForeignKeys.Nullifier( entity, true, false, session )
-				.nullifyTransientReferences( entityEntry.getDeletedState(), propTypes );
+				.nullifyTransientReferences( entityEntry.getDeletedState(), propTypes, persister );
 		new Nullability( session ).checkNullability( entityEntry.getDeletedState(), persister, true );
 		persistenceContext.getNullifiableEntityKeys().add( key );
 
