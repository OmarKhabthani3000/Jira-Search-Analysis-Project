diff -r C:\workspace\Hibernate32\src/org/hibernate/action/EntityAction.java C:\workspace\hibernate-3.2\src/org/hibernate/action/EntityAction.java
27,30d26
< 	public final String getEntityName(){
< 		return this.entityName;
< 	}
< 	
64c60
< 	public final Object getInstance() {
---
> 	protected final Object getInstance() {
diff -r C:\workspace\Hibernate32\src/org/hibernate/action/EntityInsertAction.java C:\workspace\hibernate-3.2\src/org/hibernate/action/EntityInsertAction.java
175,179c175
< 	
< 	public final Object[] getState(){
< 		return this.state;
< 	}
< 	
---
> 
180a177,183
> 
> 
> 
> 
> 
> 
> 
diff -r C:\workspace\Hibernate32\src/org/hibernate/cfg/Environment.java C:\workspace\hibernate-3.2\src/org/hibernate/cfg/Environment.java
447,451d446
< 	 * Enable ordering of inserts statements by primary key value
< 	 */
< 	public static final String ORDER_INSERTS = "hibernate.order_inserts";
< 	
< 	/**
diff -r C:\workspace\Hibernate32\src/org/hibernate/cfg/Settings.java C:\workspace\hibernate-3.2\src/org/hibernate/cfg/Settings.java
64d63
< 	private boolean orderInsertsEnabled;	
227,230d225
< 	public boolean isOrderInsertsEnabled() {
< 		return orderInsertsEnabled;
< 	}
< 	
406,409d400
< 	void setOrderInsertsEnabled(boolean orderInsertsEnabled) {
< 		this.orderInsertsEnabled = orderInsertsEnabled;
< 	}
< 	
diff -r C:\workspace\Hibernate32\src/org/hibernate/cfg/SettingsFactory.java C:\workspace\hibernate-3.2\src/org/hibernate/cfg/SettingsFactory.java
206,209d205
< 
< 		boolean orderInserts = PropertiesHelper.getBoolean(Environment.ORDER_INSERTS, properties);
< 		log.info( "Order SQL inserts by group entity: " + enabledDisabled(orderInserts) );
< 		settings.setOrderInsertsEnabled(orderInserts);
diff -r C:\workspace\Hibernate32\src/org/hibernate/engine/ActionQueue.java C:\workspace\hibernate-3.2\src/org/hibernate/engine/ActionQueue.java
26,28d25
< import java.util.HashMap;
< import java.util.Iterator;
< import java.util.Map;
313,316d309
< 		if ( session.getFactory().getSettings().isOrderInsertsEnabled() ) {
< 			//sort the insertion
< 			insertSort(insertions);
< 		}
347d339
< 	
457,548c449
< 	
< 	/**
< 	 * Sort insert action queue, move the same insert actions together 
< 	 *  
< 	 * The purpose of this method is to sort insert action. Move the same insert actions together. 
< 	 * The original order is generated by cascade order. Because different entity which prepared
< 	 * to insert has foriegn key constraint. This mothod should keep the foriegn key constraint.
< 	 * 
< 	 * ArrayList nameList is used to save insertion entity name and the cascade order of 
< 	 * insertion entity. 
< 	 * 
< 	 * Each entity name in nameList has a entry of hashMap positionToAction which is 
< 	 * 			name position in name list -----> arrayList
< 	 * the object in this arrayList have the same entity name.
< 	 * 
< 	 * 1. get first object from insertion list.
< 	 * 2. check if entityName not include in nameList. if true, insert name into nameList,
< 	 *    and create a entry of positionToAction map 
< 	 *    if false, go 3
< 	 * 3. get last position of the entity name locate in nameList.
< 	 * 4. compare the state array in this insertion entity with the objects exist in positionToAction
< 	 *    map. if it find a target object, that means this entity must insert after target object. 
< 	 *    then compare the last position with target object's position. If the target object position
< 	 *    bigger than last position, create a new name entry in nameList, and create a positionToAction
< 	 *    map entry as well. Or else go 5.
< 	 * 5. add the entity into arrayList of last position map entry.
< 	 * 6. loop to 1 until insertion list empty.
< 	 * 7. Iterater nameList and get the appropariate action list in positionToAction map, 
< 	 *    insert those action into original insertion list. 
< 	 *  
< 	 * @param insertion EntityInsertAction arrayList, it has the original cascade order.
< 	 */
< 	private void insertSort(ArrayList insertion){
< 		Map positionToAction = new HashMap();
< 		List nameList = new ArrayList();
< 		loopInsertion:
< 		while( !insertion.isEmpty() ){
< 			 
< 			EntityInsertAction eia = (EntityInsertAction)insertion.remove(0);
< 			String thisEntityName = eia.getEntityName();
< 			
< 			//if entityName not include in nameList add the name into nameList
< 			//, and add a ArrayList for this name
< 			if(!nameList.contains(thisEntityName)){
< 				ArrayList actionQueue = new ArrayList();
< 				actionQueue.add(eia);
< 				nameList.add(thisEntityName);
< 				positionToAction.put(
< 						new Integer(nameList.indexOf(thisEntityName)), actionQueue);
< 			}else{
< 				int lastPos = nameList.lastIndexOf(thisEntityName);
< 				
< 				//check if each of the state included in this action reference to the 
< 				//action which already existed in the list
< 				Object[] states = eia.getState();
< 				
< 				for (int i = 0; i < states.length; i++){
< 					for (int j = 0; j < nameList.size(); j++){
< 						ArrayList tmpList = (ArrayList)positionToAction.get(j);
< 						for ( int k = 0; k < tmpList.size(); k++){
< 							
< 							//if find any dependency object and
< 							//if dependency object after the last position, 
< 							//add a new name into nameList
< 							if (((EntityInsertAction)tmpList.get(k)).getInstance() == states[i]
< 							          && j > lastPos){
< 								ArrayList actionQueue = new ArrayList();
< 								actionQueue.add(eia);
< 								nameList.add(thisEntityName);
< 								positionToAction.put(
< 										new Integer(nameList.lastIndexOf(thisEntityName)), actionQueue);
< 								continue loopInsertion;
< 							}
< 						}
< 					}
< 				}
< 				
< 				ArrayList actionQueue = (ArrayList)positionToAction
< 						.get(new Integer(lastPos));
< 				actionQueue.add(eia);
< 			}
< 		}
< 		
< 		//iterater positionToAction map and move entityInsertAction back to insertion list
< 		for (int p = 0; p < nameList.size(); p++){
< 			ArrayList actionQueue = (ArrayList)positionToAction.get(p);
< 			for (Iterator it2 = actionQueue.iterator(); it2.hasNext();){
< 				insertion.add(it2.next());
< 			}
< 		}
< 	}
< 	
---
> 

