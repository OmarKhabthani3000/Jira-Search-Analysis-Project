package org.hibernate.engine.query;

import java.io.Serializable;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.hibernate.HibernateException;
import org.hibernate.engine.QueryParameters;
import org.hibernate.engine.SessionFactoryImplementor;
import org.hibernate.engine.SessionImplementor;
import org.hibernate.engine.TypedValue;
import org.hibernate.exception.JDBCExceptionHelper;
import org.hibernate.QueryException;
import org.hibernate.loader.custom.SQLCustomQuery;
import org.hibernate.mapping.Value;
import org.hibernate.pretty.Formatter;
import org.hibernate.type.Type;
import org.hibernate.util.ArrayHelper;

/**
 * Defines a query execution plan for a native-SQL query.
 *
 * @author <a href="mailto:steve@hibernate.org">Steve Ebersole </a>
 */
public class NativeSQLQueryPlan implements Serializable {
	private final String sourceQuery;
	private final SQLCustomQuery customQuery;
	private static final Log log = LogFactory.getLog(NativeSQLQueryPlan.class);
	
	public NativeSQLQueryPlan(NativeSQLQuerySpecification specification, SessionFactoryImplementor factory) {
		this.sourceQuery = specification.getQueryString();

		customQuery = new SQLCustomQuery(
				specification.getSqlQueryReturns(),
		        specification.getSqlQueryScalarReturns(),
		        specification.getQueryString(),
		        specification.getQuerySpaces(),
		        factory
		);
	}
	
	private String format(SessionImplementor session, String sql) {
		if ( session.getFactory().getSettings().isFormatSqlEnabled() ) {
			return new Formatter(sql).format();
		}
		else {
			return sql;
		}
	}

	private int[] getNamedParameterLocs(String name) throws QueryException {
		Object loc = customQuery.getNamedParameterBindPoints().get(name);
		if (loc == null) {
			throw new QueryException(
					"Named parameter does not appear in Query: " + 
					name, 
					customQuery.getSQL()
			);
		}
		if (loc instanceof Integer) {
			return new int[] { ( (Integer) loc ).intValue() };
		}
		else {
			return ArrayHelper.toIntArray( (List) loc );
		}
	}

	/**
	 * Bind positional parameter values to the <tt>PreparedStatement</tt>
	 * (these are parameters specified by a JDBC-style ?).
	 */
	private int bindPositionalParameters(
	        final PreparedStatement st,
	        final QueryParameters queryParameters,
	        final int start,
	        final SessionImplementor session) throws SQLException, HibernateException {

		final Object[] values = queryParameters.getFilteredPositionalParameterValues();
		final Type[] types = queryParameters.getFilteredPositionalParameterTypes();
		int span = 0;
		for ( int i = 0; i < values.length; i++ ) {
			types[i].nullSafeSet( st, values[i], start + span, session );
			span += types[i].getColumnSpan( session.getFactory() );
		}
		return span;
	}

	/**
	 * Bind named parameters to the <tt>PreparedStatement</tt>. This has an empty
	 * implementation on this superclass and should be implemented by subclasses
	 * (queries) which allow named parameters.
	 */
	private int bindNamedParameters(final PreparedStatement ps,
			  final Map namedParams,
			  final int start,
			  final SessionImplementor session)
	throws SQLException, HibernateException {
	
		if ( namedParams != null ) {
			// assumes that types are all of span 1
			Iterator iter = namedParams.entrySet().iterator();
			int result = 0;
			while ( iter.hasNext() ) {
				Map.Entry e = ( Map.Entry ) iter.next();
				String name = ( String ) e.getKey();
				TypedValue typedval = ( TypedValue ) e.getValue();
				int[] locs = getNamedParameterLocs( name );
				for ( int i = 0; i < locs.length; i++ ) {
					if ( log.isDebugEnabled() ) {
						log.debug( 
								"bindNamedParameters() " +
								typedval.getValue() + " -> " + name +
								" [" + ( locs[i] + start ) + "]" 
							);
					}
					typedval.getType().nullSafeSet( ps, typedval.getValue(), locs[i] + start, session );
				}
				result += locs.length;
			}
			return result;
		}
		else {
			return 0;
		}
	}	

    public int performExecuteUpdate(QueryParameters queryParameters,
	            SessionImplementor session) throws HibernateException {

	        int result = 0;
	        try {
	            Connection connection = session.connection();
	            try {
				queryParameters.processFilters( this.customQuery.getSQL(), session );
				String sql = queryParameters.getFilteredSQL();

			        if (log.isTraceEnabled()) {
	      		      log.trace("executeUpdate: " + sql);
			            queryParameters.traceParameters(session.getFactory());
	      		  }
				  if ( session.getFactory().getSettings().isShowSqlEnabled() ) {
					System.out.println( "Hibernate: " + format(session, sql));
				  }

	                PreparedStatement ps = connection
	                        .prepareStatement(sql);
	                try {
				int col = 1;
				col += bindPositionalParameters( ps, queryParameters, col, session );
				col += bindNamedParameters( ps, queryParameters.getNamedParameters(), col, session );
	                    result = ps.executeUpdate();
	                } finally {
	                    ps.close();
	                }
	            } finally {
	                connection.close();
	            }
	        } catch (SQLException sqle) {
	            throw JDBCExceptionHelper.convert(session.getFactory()
	                    .getSQLExceptionConverter(), sqle,
	                    "could not execute update query", this.sourceQuery);
	        }

        return result;
    }
    
	public String getSourceQuery() {
		return sourceQuery;
	}

	public SQLCustomQuery getCustomQuery() {
		return customQuery;
	}
}
