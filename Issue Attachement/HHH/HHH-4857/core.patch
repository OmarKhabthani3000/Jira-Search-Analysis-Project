Index: core/src/main/java/org/hibernate/cfg/Configuration.java
===================================================================
--- core/src/main/java/org/hibernate/cfg/Configuration.java	(revision 18690)
+++ core/src/main/java/org/hibernate/cfg/Configuration.java	(working copy)
@@ -36,6 +36,7 @@
 import java.lang.reflect.Array;
 import java.net.URL;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -66,6 +67,12 @@
 import org.hibernate.MappingNotFoundException;
 import org.hibernate.SessionFactory;
 import org.hibernate.SessionFactoryObserver;
+import org.hibernate.cache.CollectionRegion;
+import org.hibernate.cache.EntityRegion;
+import org.hibernate.cache.access.AccessType;
+import org.hibernate.cache.access.CollectionRegionAccessStrategy;
+import org.hibernate.cache.access.EntityRegionAccessStrategy;
+import org.hibernate.cache.impl.CacheDataDescriptionImpl;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.dialect.MySQLDialect;
 import org.hibernate.dialect.function.SQLFunction;
@@ -103,6 +110,7 @@
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.id.PersistentIdentifierGenerator;
 import org.hibernate.impl.SessionFactoryImpl;
+import org.hibernate.impl.SessionImpl;
 import org.hibernate.mapping.AuxiliaryDatabaseObject;
 import org.hibernate.mapping.Collection;
 import org.hibernate.mapping.ForeignKey;
@@ -114,10 +122,14 @@
 import org.hibernate.mapping.SimpleValue;
 import org.hibernate.mapping.Table;
 import org.hibernate.mapping.UniqueKey;
+import org.hibernate.persister.PersisterFactory;
+import org.hibernate.persister.collection.CollectionPersister;
+import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.proxy.EntityNotFoundDelegate;
 import org.hibernate.secure.JACCConfiguration;
 import org.hibernate.tool.hbm2ddl.DatabaseMetadata;
 import org.hibernate.tool.hbm2ddl.TableMetadata;
+import org.hibernate.type.AssociationType;
 import org.hibernate.type.SerializationException;
 import org.hibernate.type.Type;
 import org.hibernate.util.ArrayHelper;
@@ -184,6 +196,8 @@
 	protected final SettingsFactory settingsFactory;
 
 	private SessionFactoryObserver sessionFactoryObserver;
+	private static SessionFactoryImpl initialSessionFact;
+	private static Object initialSessionFactMutex = "";
 
 	protected void reset() {
 		classes = new HashMap();
@@ -1315,22 +1329,60 @@
 	 * @see org.hibernate.SessionFactory
 	 */
 	public SessionFactory buildSessionFactory() throws HibernateException {
+		return buildSessionFactory(false);
+	}
+	
+	/**
+	 * Instantiate a new <tt>SessionFactory</tt>, using the properties and
+	 * mappings in this configuration. The <tt>SessionFactory</tt> will be
+	 * immutable, so changes made to the <tt>Configuration</tt> after
+	 * building the <tt>SessionFactory</tt> will not affect it.
+	 *
+	 * @return a new factory for <tt>Session</tt>s
+	 * @see org.hibernate.SessionFactory
+	 */
+	public SessionFactory buildSessionFactory(boolean shared) throws HibernateException {
 		log.debug( "Preparing to build session factory with filters : " + filterDefinitions );
 		secondPassCompile();
 		validate();
+		
 		Environment.verifyProperties( properties );
 		Properties copy = new Properties();
 		copy.putAll( properties );
 		PropertiesHelper.resolvePlaceHolders( copy );
 		Settings settings = buildSettings( copy );
+		if (shared){
+			synchronized (initialSessionFactMutex) {
+				if (initialSessionFact == null){
+					initialSessionFact = new SessionFactoryImpl(this,
+						mapping, settings, getInitializedEventListeners(),sessionFactoryObserver);
+				}
+			}
+		}
+		
+		if (!shared){
+			SessionFactoryImpl impl = new SessionFactoryImpl(
+					this,
+					mapping,
+					settings,
+					getInitializedEventListeners(),
+					sessionFactoryObserver
+				);
+			return impl;
+		}
+		else{
+			SessionFactoryImpl impl = new SessionFactoryImpl(
+					this,
+					mapping,
+					settings,
+					getInitializedEventListeners(),
+					sessionFactoryObserver,
+					initialSessionFact
+				);
+			return impl;
+		}
 
-		return new SessionFactoryImpl(
-				this,
-				mapping,
-				settings,
-				getInitializedEventListeners(),
-				sessionFactoryObserver
-			);
+
 	}
 
 	private EventListeners getInitializedEventListeners() {
Index: core/src/main/java/org/hibernate/impl/SessionFactoryImpl.java
===================================================================
--- core/src/main/java/org/hibernate/impl/SessionFactoryImpl.java	(revision 18690)
+++ core/src/main/java/org/hibernate/impl/SessionFactoryImpl.java	(working copy)
@@ -183,6 +183,16 @@
 	        Settings settings,
 	        EventListeners listeners,
 			SessionFactoryObserver observer) throws HibernateException {
+			this(cfg, mapping, settings, listeners, observer, null);
+	}
+	
+	public SessionFactoryImpl(
+			Configuration cfg,
+	        Mapping mapping,
+	        Settings settings,
+	        EventListeners listeners,
+			SessionFactoryObserver observer,
+			SessionFactoryImpl initialSessionFact) throws HibernateException {
 
 		log.info("building session factory");
 
@@ -235,97 +245,113 @@
 		///////////////////////////////////////////////////////////////////////
 		// Prepare persisters and link them up with their cache
 		// region/access-strategy
+		if (initialSessionFact == null){
+			final String cacheRegionPrefix = settings.getCacheRegionPrefix() == null ? "" : settings.getCacheRegionPrefix() + ".";
 
-		final String cacheRegionPrefix = settings.getCacheRegionPrefix() == null ? "" : settings.getCacheRegionPrefix() + ".";
+			entityPersisters = new HashMap();
+			Map entityAccessStrategies = new HashMap();
+			Map classMeta = new HashMap();
+			classes = cfg.getClassMappings();
+			while ( classes.hasNext() ) {
+				final PersistentClass model = (PersistentClass) classes.next();
+				model.prepareTemporaryTables( mapping, settings.getDialect() );
+				final String cacheRegionName = cacheRegionPrefix + model.getRootClass().getCacheRegionName();
+				// cache region is defined by the root-class in the hierarchy...
+				EntityRegionAccessStrategy accessStrategy = ( EntityRegionAccessStrategy ) entityAccessStrategies.get( cacheRegionName );
+				if ( accessStrategy == null && settings.isSecondLevelCacheEnabled() ) {
+					final AccessType accessType = AccessType.parse( model.getCacheConcurrencyStrategy() );
+					if ( accessType != null ) {
+						log.trace( "Building cache for entity data [" + model.getEntityName() + "]" );
+						EntityRegion entityRegion = settings.getRegionFactory().buildEntityRegion( cacheRegionName, properties, CacheDataDescriptionImpl.decode( model ) );
+						accessStrategy = entityRegion.buildAccessStrategy( accessType );
+						entityAccessStrategies.put( cacheRegionName, accessStrategy );
+						allCacheRegions.put( cacheRegionName, entityRegion );
+					}
+				}
+				EntityPersister cp = PersisterFactory.createClassPersister( model, accessStrategy, this, mapping );
+				entityPersisters.put( model.getEntityName(), cp );
+				classMeta.put( model.getEntityName(), cp.getClassMetadata() );
+			}
+			classMetadata = Collections.unmodifiableMap(classMeta);
 
-		entityPersisters = new HashMap();
-		Map entityAccessStrategies = new HashMap();
-		Map classMeta = new HashMap();
-		classes = cfg.getClassMappings();
-		while ( classes.hasNext() ) {
-			final PersistentClass model = (PersistentClass) classes.next();
-			model.prepareTemporaryTables( mapping, settings.getDialect() );
-			final String cacheRegionName = cacheRegionPrefix + model.getRootClass().getCacheRegionName();
-			// cache region is defined by the root-class in the hierarchy...
-			EntityRegionAccessStrategy accessStrategy = ( EntityRegionAccessStrategy ) entityAccessStrategies.get( cacheRegionName );
-			if ( accessStrategy == null && settings.isSecondLevelCacheEnabled() ) {
+			Map tmpEntityToCollectionRoleMap = new HashMap();
+			collectionPersisters = new HashMap();
+			Iterator collections = cfg.getCollectionMappings();
+			while ( collections.hasNext() ) {
+				Collection model = (Collection) collections.next();
+				final String cacheRegionName = cacheRegionPrefix + model.getCacheRegionName();
 				final AccessType accessType = AccessType.parse( model.getCacheConcurrencyStrategy() );
-				if ( accessType != null ) {
-					log.trace( "Building cache for entity data [" + model.getEntityName() + "]" );
-					EntityRegion entityRegion = settings.getRegionFactory().buildEntityRegion( cacheRegionName, properties, CacheDataDescriptionImpl.decode( model ) );
-					accessStrategy = entityRegion.buildAccessStrategy( accessType );
+				CollectionRegionAccessStrategy accessStrategy = null;
+				if ( accessType != null && settings.isSecondLevelCacheEnabled() ) {
+					log.trace( "Building cache for collection data [" + model.getRole() + "]" );
+					CollectionRegion collectionRegion = settings.getRegionFactory().buildCollectionRegion( cacheRegionName, properties, CacheDataDescriptionImpl.decode( model ) );
+					accessStrategy = collectionRegion.buildAccessStrategy( accessType );
 					entityAccessStrategies.put( cacheRegionName, accessStrategy );
-					allCacheRegions.put( cacheRegionName, entityRegion );
+					allCacheRegions.put( cacheRegionName, collectionRegion );
 				}
+				CollectionPersister persister = PersisterFactory.createCollectionPersister( cfg, model, accessStrategy, this) ;
+				collectionPersisters.put( model.getRole(), persister.getCollectionMetadata() );
+				Type indexType = persister.getIndexType();
+				if ( indexType != null && indexType.isAssociationType() && !indexType.isAnyType() ) {
+					String entityName = ( ( AssociationType ) indexType ).getAssociatedEntityName( this );
+					Set roles = ( Set ) tmpEntityToCollectionRoleMap.get( entityName );
+					if ( roles == null ) {
+						roles = new HashSet();
+						tmpEntityToCollectionRoleMap.put( entityName, roles );
+					}
+					roles.add( persister.getRole() );
+				}
+				Type elementType = persister.getElementType();
+				if ( elementType.isAssociationType() && !elementType.isAnyType() ) {
+					String entityName = ( ( AssociationType ) elementType ).getAssociatedEntityName( this );
+					Set roles = ( Set ) tmpEntityToCollectionRoleMap.get( entityName );
+					if ( roles == null ) {
+						roles = new HashSet();
+						tmpEntityToCollectionRoleMap.put( entityName, roles );
+					}
+					roles.add( persister.getRole() );
+				}
 			}
-			EntityPersister cp = PersisterFactory.createClassPersister( model, accessStrategy, this, mapping );
-			entityPersisters.put( model.getEntityName(), cp );
-			classMeta.put( model.getEntityName(), cp.getClassMetadata() );
-		}
-		classMetadata = Collections.unmodifiableMap(classMeta);
-
-		Map tmpEntityToCollectionRoleMap = new HashMap();
-		collectionPersisters = new HashMap();
-		Iterator collections = cfg.getCollectionMappings();
-		while ( collections.hasNext() ) {
-			Collection model = (Collection) collections.next();
-			final String cacheRegionName = cacheRegionPrefix + model.getCacheRegionName();
-			final AccessType accessType = AccessType.parse( model.getCacheConcurrencyStrategy() );
-			CollectionRegionAccessStrategy accessStrategy = null;
-			if ( accessType != null && settings.isSecondLevelCacheEnabled() ) {
-				log.trace( "Building cache for collection data [" + model.getRole() + "]" );
-				CollectionRegion collectionRegion = settings.getRegionFactory().buildCollectionRegion( cacheRegionName, properties, CacheDataDescriptionImpl.decode( model ) );
-				accessStrategy = collectionRegion.buildAccessStrategy( accessType );
-				entityAccessStrategies.put( cacheRegionName, accessStrategy );
-				allCacheRegions.put( cacheRegionName, collectionRegion );
+			collectionMetadata = Collections.unmodifiableMap(collectionPersisters);
+			Iterator itr = tmpEntityToCollectionRoleMap.entrySet().iterator();
+			while ( itr.hasNext() ) {
+				final Map.Entry entry = ( Map.Entry ) itr.next();
+				entry.setValue( Collections.unmodifiableSet( ( Set ) entry.getValue() ) );
 			}
-			CollectionPersister persister = PersisterFactory.createCollectionPersister( cfg, model, accessStrategy, this) ;
-			collectionPersisters.put( model.getRole(), persister.getCollectionMetadata() );
-			Type indexType = persister.getIndexType();
-			if ( indexType != null && indexType.isAssociationType() && !indexType.isAnyType() ) {
-				String entityName = ( ( AssociationType ) indexType ).getAssociatedEntityName( this );
-				Set roles = ( Set ) tmpEntityToCollectionRoleMap.get( entityName );
-				if ( roles == null ) {
-					roles = new HashSet();
-					tmpEntityToCollectionRoleMap.put( entityName, roles );
-				}
-				roles.add( persister.getRole() );
+			collectionRolesByEntityParticipant = Collections.unmodifiableMap( tmpEntityToCollectionRoleMap );
+			
+			//Named Queries:
+			namedQueries = new HashMap( cfg.getNamedQueries() );
+			namedSqlQueries = new HashMap( cfg.getNamedSQLQueries() );
+			sqlResultSetMappings = new HashMap( cfg.getSqlResultSetMappings() );
+			imports = new HashMap( cfg.getImports() );
+			
+			// after *all* persisters and named queries are registered
+			Iterator iter = entityPersisters.values().iterator();
+			while ( iter.hasNext() ) {
+				( (EntityPersister) iter.next() ).postInstantiate();
 			}
-			Type elementType = persister.getElementType();
-			if ( elementType.isAssociationType() && !elementType.isAnyType() ) {
-				String entityName = ( ( AssociationType ) elementType ).getAssociatedEntityName( this );
-				Set roles = ( Set ) tmpEntityToCollectionRoleMap.get( entityName );
-				if ( roles == null ) {
-					roles = new HashSet();
-					tmpEntityToCollectionRoleMap.put( entityName, roles );
-				}
-				roles.add( persister.getRole() );
+			iter = collectionPersisters.values().iterator();
+			while ( iter.hasNext() ) {
+				( (CollectionPersister) iter.next() ).postInstantiate();
 			}
 		}
-		collectionMetadata = Collections.unmodifiableMap(collectionPersisters);
-		Iterator itr = tmpEntityToCollectionRoleMap.entrySet().iterator();
-		while ( itr.hasNext() ) {
-			final Map.Entry entry = ( Map.Entry ) itr.next();
-			entry.setValue( Collections.unmodifiableSet( ( Set ) entry.getValue() ) );
+		else{
+			collectionPersisters = new HashMap();
+			entityPersisters = initialSessionFact.entityPersisters;
+			allCacheRegions.putAll(initialSessionFact.allCacheRegions);
+			classMetadata = initialSessionFact.classMetadata;
+			collectionPersisters.putAll(initialSessionFact.collectionPersisters);
+			collectionMetadata = initialSessionFact.collectionMetadata;
+			collectionRolesByEntityParticipant = initialSessionFact.collectionRolesByEntityParticipant;
+			
+			//Named Queries:
+			namedQueries = new HashMap( cfg.getNamedQueries() );
+			namedSqlQueries = new HashMap( cfg.getNamedSQLQueries() );
+			sqlResultSetMappings = new HashMap( cfg.getSqlResultSetMappings() );
+			imports = new HashMap( cfg.getImports() );
 		}
-		collectionRolesByEntityParticipant = Collections.unmodifiableMap( tmpEntityToCollectionRoleMap );
 
-		//Named Queries:
-		namedQueries = new HashMap( cfg.getNamedQueries() );
-		namedSqlQueries = new HashMap( cfg.getNamedSQLQueries() );
-		sqlResultSetMappings = new HashMap( cfg.getSqlResultSetMappings() );
-		imports = new HashMap( cfg.getImports() );
-
-		// after *all* persisters and named queries are registered
-		Iterator iter = entityPersisters.values().iterator();
-		while ( iter.hasNext() ) {
-			( (EntityPersister) iter.next() ).postInstantiate();
-		}
-		iter = collectionPersisters.values().iterator();
-		while ( iter.hasNext() ) {
-			( (CollectionPersister) iter.next() ).postInstantiate();
-		}
-
 		//JNDI + Serialization:
 
 		name = settings.getSessionFactoryName();
