Index: U:/workspaces/atn-Standart/Hibernate Core/src/org/hibernate/event/def/AbstractSaveEventListener.java
===================================================================
--- U:/workspaces/atn-Standart/Hibernate Core/src/org/hibernate/event/def/AbstractSaveEventListener.java	(revision 14771)
+++ U:/workspaces/atn-Standart/Hibernate Core/src/org/hibernate/event/def/AbstractSaveEventListener.java	(working copy)
@@ -89,6 +89,91 @@
 	 * @return The id used to save the entity; may be null depending on the
 	 *         type of id generator used and the requiresImmediateIdAccess value
 	 */
+	protected IDAttachResult attachGeneratedId(
+			Object entity,
+			String entityName,
+			Object anything,
+			EventSource source,
+			boolean requiresImmediateIdAccess) {
+		EntityPersister persister = source.getEntityPersister( entityName, entity );
+		Serializable generatedId = persister.getIdentifierGenerator().generate( source, entity );
+		boolean immediateAccess = true;
+		boolean useIdentityColumn = false;
+		if ( generatedId == null ) {
+			throw new IdentifierGenerationException( "null id generated for:" + entity.getClass() );
+		}
+		else if ( generatedId == IdentifierGeneratorFactory.SHORT_CIRCUIT_INDICATOR ) {
+			return new IDAttachResult(source.getIdentifier( entity ));
+		}
+		else if ( generatedId == IdentifierGeneratorFactory.POST_INSERT_INDICATOR ) {
+			generatedId = null;
+			immediateAccess = requiresImmediateIdAccess;
+			useIdentityColumn = true;
+//			return performSave( entity, null, persister, true, anything, source, requiresImmediateIdAccess );
+		}
+		else {
+			if ( log.isDebugEnabled() ) {
+				log.debug(
+						"generated identifier: " +
+								persister.getIdentifierType().toLoggableString( generatedId, source.getFactory() ) +
+								", using strategy: " +
+								persister.getIdentifierGenerator().getClass().getName()
+						//TODO: define toString()s for generators
+				);
+			}
+//			return performSave( entity, generatedId, persister, false, anything, source, true );
+		}
+
+		EntityKey key = null;
+		if ( !useIdentityColumn ) {
+			key = atachIdToEntity(entity, generatedId, persister, source);
+		}
+
+		return new IDAttachResult(generatedId, key, immediateAccess, useIdentityColumn);
+//		return performSave( entity, generatedId, persister, useIdentityColumn, anything, source, immediateAccess );
+	}
+
+	/**
+	 * Prepares the save call using the given requested id.
+	 *
+	 * @param entity The entity to be saved.
+	 * @param requestedId The id to which to associate the entity.
+	 * @param entityName The name of the entity being saved.
+	 * @param anything Generally cascade-specific information.
+	 * @param source The session which is the source of this save event.
+	 *
+	 * @return The id used to save the entity.
+	 */
+	protected IDAttachResult attachRequestedId(
+			Object entity,
+			Serializable requestedId,
+			String entityName,
+			Object anything,
+			EventSource source)
+	{
+		EntityPersister persister = source.getEntityPersister( entityName, entity );
+		EntityKey key = atachIdToEntity(entity, requestedId, persister, source);
+
+		boolean useIdentityColumn = false;
+		boolean immediateAccess = true;
+		return new IDAttachResult(requestedId, key, immediateAccess, useIdentityColumn);
+	}
+
+	/**
+	 * Prepares the save call using a newly generated id.
+	 *
+	 * @param entity The entity to be saved
+	 * @param entityName The entity-name for the entity to be saved
+	 * @param anything Generally cascade-specific information.
+	 * @param source The session which is the source of this save event.
+	 * @param requiresImmediateIdAccess does the event context require
+	 * access to the identifier immediately after execution of this method (if
+	 * not, post-insert style id generators may be postponed if we are outside
+	 * a transaction).
+	 *
+	 * @return The id used to save the entity; may be null depending on the
+	 *         type of id generator used and the requiresImmediateIdAccess value
+	 */
 	protected Serializable saveWithGeneratedId(
 			Object entity,
 			String entityName,
@@ -97,6 +182,8 @@
 			boolean requiresImmediateIdAccess) {
 		EntityPersister persister = source.getEntityPersister( entityName, entity );
 		Serializable generatedId = persister.getIdentifierGenerator().generate( source, entity );
+		boolean immediateAccess = true;
+		boolean useIdentityColumn = false;
 		if ( generatedId == null ) {
 			throw new IdentifierGenerationException( "null id generated for:" + entity.getClass() );
 		}
@@ -104,10 +191,12 @@
 			return source.getIdentifier( entity );
 		}
 		else if ( generatedId == IdentifierGeneratorFactory.POST_INSERT_INDICATOR ) {
-			return performSave( entity, null, persister, true, anything, source, requiresImmediateIdAccess );
+			generatedId = null;
+			immediateAccess = requiresImmediateIdAccess;
+			useIdentityColumn = true;
+//			return performSave( entity, null, persister, true, anything, source, requiresImmediateIdAccess );
 		}
 		else {
-
 			if ( log.isDebugEnabled() ) {
 				log.debug(
 						"generated identifier: " +
@@ -117,9 +206,62 @@
 						//TODO: define toString()s for generators
 				);
 			}
+//			return performSave( entity, generatedId, persister, false, anything, source, true );
+		}
+		return performSave( entity, generatedId, persister, useIdentityColumn, anything, source, immediateAccess );
+	}
+
+	/**
+	 * Ppepares the save call by checking the session caches for a pre-existing
+	 * entity and performing any lifecycle callbacks.
+	 * @param attachResult
+	 *
+	 * @param entity The entity to be saved.
+	 * @param id The id by which to save the entity.
+	 * @param persister The entity's persister instance.
+	 * @param useIdentityColumn Is an identity column being used?
+	 * @param anything Generally cascade-specific information.
+	 * @param source The session from which the event originated.
+	 * @param requiresImmediateIdAccess does the event context require
+	 * access to the identifier immediately after execution of this method (if
+	 * not, post-insert style id generators may be postponed if we are outside
+	 * a transaction).
+	 *
+	 * @return The id used to save the entity; may be null depending on the
+	 *         type of id generator used and the requiresImmediateIdAccess value
+	 */
+	protected Serializable saveWithAttachedID(
+			IDAttachResult attachResult,
+			Object entity,
+			String entityName,
+			Object anything,
+			EventSource source
+			)
+	{
+		EntityPersister persister = source.getEntityPersister( entityName, entity );
+
+		Serializable id = attachResult.getId();
 
-			return performSave( entity, generatedId, persister, false, anything, source, true );
+		if ( log.isTraceEnabled() ) {
+			log.trace(
+					"saving " +
+							MessageHelper.infoString( persister, id, source.getFactory() )
+			);
 		}
+
+		if ( invokeSaveLifecycle( entity, persister, source ) ) {
+			return id; //EARLY EXIT
+		}
+
+		return performSaveOrReplicate(
+				entity,
+				attachResult.getKey(),
+				persister,
+				attachResult.isUseIdentityColumn(),
+				anything,
+				source,
+				attachResult.isRequiresImmediateAccess()
+		);
 	}
 
 	/**
@@ -158,19 +300,8 @@
 
 		EntityKey key;
 		if ( !useIdentityColumn ) {
-			key = new EntityKey( id, persister, source.getEntityMode() );
-			Object old = source.getPersistenceContext().getEntity( key );
-			if ( old != null ) {
-				if ( source.getPersistenceContext().getEntry( old ).getStatus() == Status.DELETED ) {
-					source.forceFlush( source.getPersistenceContext().getEntry( old ) );
-				}
-				else {
-					throw new NonUniqueObjectException( id, persister.getEntityName() );
-				}
-			}
-			persister.setIdentifier( entity, id, source.getEntityMode() );
-		}
-		else {
+			key = atachIdToEntity(entity, id, persister, source);
+		}	else {
 			key = null;
 		}
 
@@ -189,6 +320,23 @@
 		);
 	}
 
+	private EntityKey atachIdToEntity(Object entity, Serializable id, EntityPersister persister, EventSource source)
+	{
+		EntityKey key;
+		key = new EntityKey( id, persister, source.getEntityMode() );
+		Object old = source.getPersistenceContext().getEntity( key );
+		if ( old != null ) {
+			if ( source.getPersistenceContext().getEntry( old ).getStatus() == Status.DELETED ) {
+				source.forceFlush( source.getPersistenceContext().getEntry( old ) );
+			}
+			else {
+				throw new NonUniqueObjectException( id, persister.getEntityName() );
+			}
+		}
+		persister.setIdentifier( entity, id, source.getEntityMode() );
+		return key;
+	}
+
 	protected boolean invokeSaveLifecycle(Object entity, EntityPersister persister, EventSource source) {
 		// Sub-insertions should occur before containing insertion so
 		// Try to do the callback now
Index: U:/workspaces/atn-Standart/Hibernate Core/src/org/hibernate/event/def/DefaultMergeEventListener.java
===================================================================
--- U:/workspaces/atn-Standart/Hibernate Core/src/org/hibernate/event/def/DefaultMergeEventListener.java	(revision 14771)
+++ U:/workspaces/atn-Standart/Hibernate Core/src/org/hibernate/event/def/DefaultMergeEventListener.java	(working copy)
@@ -4,10 +4,10 @@
 import java.io.Serializable;
 import java.util.Iterator;
 import java.util.Map;
+import java.util.WeakHashMap;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
-
 import org.hibernate.AssertionFailure;
 import org.hibernate.HibernateException;
 import org.hibernate.ObjectDeletedException;
@@ -29,6 +29,7 @@
 import org.hibernate.proxy.HibernateProxy;
 import org.hibernate.proxy.LazyInitializer;
 import org.hibernate.type.ForeignKeyDirection;
+import org.hibernate.type.Type;
 import org.hibernate.type.TypeFactory;
 import org.hibernate.util.IdentityMap;
 
@@ -38,10 +39,15 @@
  *
  * @author Gavin King
  */
-public class DefaultMergeEventListener extends AbstractSaveEventListener 
+public class DefaultMergeEventListener extends AbstractSaveEventListener
 	implements MergeEventListener {
 
+	private static final String BEFORECASCADEHASH = "BEFORECASCADEHASH";
+	private static final String ENTITYCOPYIDHASH = "ENTITYCOPYIDHASH";
 	private static final Log log = LogFactory.getLog(DefaultMergeEventListener.class);
+	//<MergeEvent, Map>
+	private static final WeakHashMap eventToBeforeCascade = new WeakHashMap();
+	private static final WeakHashMap eventToEntityCopyID = new WeakHashMap();
 	
 	protected Map getMergeMap(Object anything) {
 		return IdentityMap.invert( (Map) anything );
@@ -76,7 +82,38 @@
 		}
 	}
 
-	/** 
+	private boolean hasTransientParentsInBeforeCascade(MergeEvent event, Object entity, Map copyCache, EventSource source)
+	{
+		EntityPersister persister = source.getEntityPersister( event.getEntityName(), entity );
+
+		Object[] values = persister.getPropertyValuesToInsert( entity, copyCache, source );
+		Type[] types = persister.getPropertyTypes();
+
+//		ForeignKeys.Nullifier nullifier = new ForeignKeys.Nullifier( entity, false, false, source );
+		for ( int i = 0; i < types.length; i++ ) {
+			if (types[i].isEntityType()) {
+				//if some value is in copyCache, it was in merge
+				//if it is in cascadeMap, it means, it is in cascadebeforeSave cycle, and
+				//it's childs should not be saved now!
+				if (values[i] != null &&
+						copyCache.containsKey(values[i]) &&
+						getIdentityCascadeMap(event).containsKey(values[i])) {
+//					if (nullifier.referenceWillBeNullifyied(copyCache.get(values[i]), types[i])) {
+						return true;
+//					}
+				}
+			}
+		}
+		//if some of the not null parents is in copyCache, and is still
+		//transient, that means it is in beforeCascade. Which means, we
+		//have to skip this child for now!
+
+		//new Nullability( source ).checkNullability( values, persister, false );
+
+		return false;
+	}
+
+	/**
 	 * Handle the given merge event.
 	 *
 	 * @param event The merge event to be handled.
@@ -104,13 +141,28 @@
 			else {
 				entity = original;
 			}
-			
-			if ( copyCache.containsKey(entity) &&
-					source.getContextEntityIdentifier( copyCache.get( entity ) ) != null ) {
-				log.trace("already merged");
+
+			if ( copyCache.containsKey(entity) 
+					&& (source.getContextEntityIdentifier( copyCache.get( entity ) ) != null 
+							|| getIdentityCascadeMap(event).containsKey(entity))) {
+//					) {
+				Object entityCopy = copyCache.get(entity);
+				Map identityIdMap = getIdentityIdMap(event);
+				if (identityIdMap.containsKey(entityCopy) && !hasTransientParentsInBeforeCascade(event, entity, copyCache, source)) {
+					log.trace("already merged, but not saved, saving");
+					IDAttachResult attachResult = (IDAttachResult) identityIdMap.get(entityCopy);
+					EntityPersister persister = source.getEntityPersister( event.getEntityName(), entity );
+					final String entityName = persister.getEntityName();
+					saveWithAttachedID(attachResult, entityCopy, entityName, copyCache, source);
+					identityIdMap.remove(entityCopy);
+				} else {
+					log.trace("already merged");
+				}
 				event.setResult(entity);
-			}
-			else {
+//			} else if (hasTransientParentsInBeforeCascade(event, entity, copyCache, source)) {
+//				log.trace("entity has more parents in before cascade, skipping for now");
+//				event.setResult(entity);
+			}	else {
 				event.setEntity( entity );
 				int entityState = -1;
 
@@ -138,7 +190,7 @@
 				if ( entityState == -1 ) {
 					entityState = getEntityState( entity, event.getEntityName(), entry, source );
 				}
-				
+
 				switch (entityState) {
 					case DETACHED:
 						entityIsDetached(event, copyCache);
@@ -151,15 +203,15 @@
 						break;
 					default: //DELETED
 						throw new ObjectDeletedException(
-								"deleted instance passed to merge", 
-								null, 
+								"deleted instance passed to merge",
+								null,
 								getLoggableName( event.getEntityName(), entity )
-							);			
+							);
 				}
 			}
-			
+
 		}
-		
+
 	}
 
 	protected void entityIsPersistent(MergeEvent event, Map copyCache) {
@@ -164,25 +216,25 @@
 
 	protected void entityIsPersistent(MergeEvent event, Map copyCache) {
 		log.trace("ignoring persistent instance");
-		
+
 		//TODO: check that entry.getIdentifier().equals(requestedId)
-		
+
 		final Object entity = event.getEntity();
 		final EventSource source = event.getSession();
 		final EntityPersister persister = source.getEntityPersister( event.getEntityName(), entity );
-		
+
 		copyCache.put(entity, entity); //before cascade!
-		
+
 		cascadeOnMerge(source, persister, entity, copyCache);
 		copyValues(persister, entity, entity, source, copyCache);
-		
+
 		event.setResult(entity);
 	}
-	
+
 	protected void entityIsTransient(MergeEvent event, Map copyCache) {
-		
+
 		log.trace("merging transient instance");
-		
+
 		final Object entity = event.getEntity();
 		final EventSource source = event.getSession();
 
@@ -188,10 +240,11 @@
 
 		final EntityPersister persister = source.getEntityPersister( event.getEntityName(), entity );
 		final String entityName = persister.getEntityName();
-		
+
 		final Serializable id = persister.hasIdentifierProperty() ?
 				persister.getIdentifier( entity, source.getEntityMode() ) :
 		        null;
+
 		if ( copyCache.containsKey( entity ) ) {
 			persister.setIdentifier( copyCache.get( entity ), id, source.getEntityMode() );
 		}
@@ -200,6 +253,23 @@
 			//TODO: should this be Session.instantiate(Persister, ...)?
 		}
 		final Object copy = copyCache.get( entity );
+				
+//		final Object copy = persister.instantiate( id, source.getEntityMode() );  //TODO: should this be Session.instantiate(Persister, ...)?
+//		copyCache.put(entity, copy); //before cascade!
+
+		Map map = getIdentityCascadeMap(event);
+		map.put(entity, new Object());
+
+		//generate ID for the new copy
+		final Serializable requestedId = event.getRequestedId();
+		IDAttachResult attachResult = null;
+		if (requestedId==null) {
+			attachResult = attachGeneratedId( copy, entityName, copyCache, source, false );
+		}
+		else {
+			attachResult = attachRequestedId( copy, requestedId, entityName, copyCache, source );
+		}
+
 
 		// cascade first, so that all unsaved objects get their
 		// copy created before we actually copy
@@ -206,31 +276,63 @@
 		//cascadeOnMerge(event, persister, entity, copyCache, Cascades.CASCADE_BEFORE_MERGE);
 		super.cascadeBeforeSave(source, persister, entity, copyCache);
 		copyValues(persister, entity, copy, source, copyCache, ForeignKeyDirection.FOREIGN_KEY_FROM_PARENT);
-		
-		//this bit is only *really* absolutely necessary for handling 
-		//requestedId, but is also good if we merge multiple object 
+
+		map.remove(entity);
+
+		//this bit is only *really* absolutely necessary for handling
+		//requestedId, but is also good if we merge multiple object
 		//graphs, since it helps ensure uniqueness
-		final Serializable requestedId = event.getRequestedId();
-		if (requestedId==null) {
-			saveWithGeneratedId( copy, entityName, copyCache, source, false );
+//		final Serializable requestedId = event.getRequestedId();
+//		if (requestedId==null) {
+//			saveWithGeneratedId( copy, entityName, copyCache, source, false );
+//		}
+//		else {
+//			saveWithRequestedId( copy, requestedId, entityName, copyCache, source );
+//		}
+		if (attachResult.performSave()) {
+			if (!hasTransientParentsInBeforeCascade(event, entity, copyCache, source)) {
+				saveWithAttachedID(attachResult, copy, entityName, copyCache, source);
+			} else {
+				//we need to be saved later, but we have the ID already.
+				Map idMap = getIdentityIdMap(event);
+				idMap.put(copy, attachResult);
+			}
 		}
-		else {
-			saveWithRequestedId( copy, requestedId, entityName, copyCache, source );
-		}
-		
-		// cascade first, so that all unsaved objects get their 
+
+
+		// cascade first, so that all unsaved objects get their
 		// copy created before we actually copy
 		super.cascadeAfterSave(source, persister, entity, copyCache);
 		copyValues(persister, entity, copy, source, copyCache, ForeignKeyDirection.FOREIGN_KEY_TO_PARENT);
-		
+
+
 		event.setResult(copy);
+	}
 
+	private Map getIdentityCascadeMap(MergeEvent event)
+	{
+		Map map = (IdentityMap) eventToBeforeCascade.get(BEFORECASCADEHASH);
+		if (map == null) {
+			map = IdentityMap.instantiate(5);
+			eventToBeforeCascade.put(BEFORECASCADEHASH, map);
+		}
+		return map;
+	}
+
+	private Map getIdentityIdMap(MergeEvent event)
+	{
+		Map map = (IdentityMap) eventToEntityCopyID.get(ENTITYCOPYIDHASH);
+		if (map == null) {
+			map = IdentityMap.instantiate(5);
+			eventToEntityCopyID.put(ENTITYCOPYIDHASH, map);
+		}
+		return map;
 	}
 
 	protected void entityIsDetached(MergeEvent event, Map copyCache) {
-		
+
 		log.trace("merging detached instance");
-		
+
 		final Object entity = event.getEntity();
 		final EventSource source = event.getSession();
 
@@ -236,7 +338,7 @@
 
 		final EntityPersister persister = source.getEntityPersister( event.getEntityName(), entity );
 		final String entityName = persister.getEntityName();
-			
+
 		Serializable id = event.getRequestedId();
 		if ( id == null ) {
 			id = persister.getIdentifier( entity, source.getEntityMode() );
@@ -248,10 +350,10 @@
 				throw new HibernateException( "merge requested with id not matching id of passed entity" );
 			}
 		}
-		
+
 		String previousFetchProfile = source.getFetchProfile();
 		source.setFetchProfile("merge");
-		//we must clone embedded composite identifiers, or 
+		//we must clone embedded composite identifiers, or
 		//we will get back the same instance that we pass in
 		final Serializable clonedIdentifier = (Serializable) persister.getIdentifierType()
 				.deepCopy( id, source.getEntityMode(), source.getFactory() );
@@ -257,12 +359,12 @@
 				.deepCopy( id, source.getEntityMode(), source.getFactory() );
 		final Object result = source.get(entityName, clonedIdentifier);
 		source.setFetchProfile(previousFetchProfile);
-		
+
 		if ( result == null ) {
-			//TODO: we should throw an exception if we really *know* for sure  
+			//TODO: we should throw an exception if we really *know* for sure
 			//      that this is a detached instance, rather than just assuming
 			//throw new StaleObjectStateException(entityName, id);
-			
+
 			// we got here because we assumed that an instance
 			// with an assigned id was detached, when it was
 			// really persistent
@@ -270,7 +372,7 @@
 		}
 		else {
 			copyCache.put(entity, result); //before cascade!
-	
+
 			final Object target = source.getPersistenceContext().unproxy(result);
 			if ( target == entity ) {
 				throw new AssertionFailure("entity was not detached");
@@ -289,15 +391,15 @@
 				}
 				throw new StaleObjectStateException( entityName, id );
 			}
-	
-			// cascade first, so that all unsaved objects get their 
+
+			// cascade first, so that all unsaved objects get their
 			// copy created before we actually copy
 			cascadeOnMerge(source, persister, entity, copyCache);
 			copyValues(persister, entity, target, source, copyCache);
-			
+
 			//copyValues works by reflection, so explicitly mark the entity instance dirty
 			markInterceptorDirty( entity, target );
-			
+
 			event.setResult(result);
 		}
 
@@ -357,15 +459,15 @@
 			return entry.isExistsInDatabase();
 		}
 	}
-	
+
 	protected void copyValues(
-		final EntityPersister persister, 
-		final Object entity, 
-		final Object target, 
+		final EntityPersister persister,
+		final Object entity,
+		final Object target,
 		final SessionImplementor source,
 		final Map copyCache
 	) {
-		
+
 		final Object[] copiedValues = TypeFactory.replace(
 				persister.getPropertyValues( entity, source.getEntityMode() ),
 				persister.getPropertyValues( target, source.getEntityMode() ),
@@ -371,7 +473,7 @@
 				persister.getPropertyValues( target, source.getEntityMode() ),
 				persister.getPropertyTypes(),
 				source,
-				target, 
+				target,
 				copyCache
 			);
 
@@ -380,8 +482,8 @@
 
 	protected void copyValues(
 			final EntityPersister persister,
-			final Object entity, 
-			final Object target, 
+			final Object entity,
+			final Object target,
 			final SessionImplementor source,
 			final Map copyCache,
 			final ForeignKeyDirection foreignKeyDirection) {
@@ -417,7 +519,7 @@
 		persister.setPropertyValues( target, copiedValues, source.getEntityMode() );
 	}
 
-	/** 
+	/**
 	 * Perform any cascades needed as part of this copy event.
 	 *
 	 * @param source The merge event being processed.
@@ -449,11 +551,11 @@
 	protected Boolean getAssumedUnsaved() {
 		return Boolean.FALSE;
 	}
-	
+
 	/**
 	 * Cascade behavior is redefined by this subclass, disable superclass behavior
 	 */
-	protected void cascadeAfterSave(EventSource source, EntityPersister persister, Object entity, Object anything) 
+	protected void cascadeAfterSave(EventSource source, EntityPersister persister, Object entity, Object anything)
 	throws HibernateException {
 	}
 
@@ -460,7 +562,7 @@
 	/**
 	 * Cascade behavior is redefined by this subclass, disable superclass behavior
 	 */
-	protected void cascadeBeforeSave(EventSource source, EntityPersister persister, Object entity, Object anything) 
+	protected void cascadeBeforeSave(EventSource source, EntityPersister persister, Object entity, Object anything)
 	throws HibernateException {
 	}
 
Index: U:/workspaces/atn-Standart/Hibernate Core/src/org/hibernate/event/def/IDAttachResult.java
===================================================================
--- U:/workspaces/atn-Standart/Hibernate Core/src/org/hibernate/event/def/IDAttachResult.java	(revision 0)
+++ U:/workspaces/atn-Standart/Hibernate Core/src/org/hibernate/event/def/IDAttachResult.java	(revision 0)
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2006 Whitestein Technologies AG, Poststrasse 22, CH-6300 Zug, Switzerland.
+ * All rights reserved. The use of this file in source or binary form requires a written license from Whitestein Technologies AG.
+ *
+ */
+package org.hibernate.event.def;
+
+import java.io.Serializable;
+
+import org.hibernate.engine.EntityKey;
+
+public class IDAttachResult
+{
+
+	private EntityKey key;
+	private boolean immediateAccess;
+	private boolean useIdentityColumn;
+	private Serializable id;
+	private boolean performSave;
+
+	public IDAttachResult(Serializable id)
+	{
+		this.id = id;
+		this.performSave = false;
+	}
+
+	public IDAttachResult(Serializable generatedId, EntityKey key, boolean immediateAccess, boolean useIdentityColumn)
+	{
+		this.id = generatedId;
+		this.key = key;
+		this.immediateAccess = immediateAccess;
+		this.useIdentityColumn = useIdentityColumn;
+		this.performSave = true;
+	}
+
+	public boolean isRequiresImmediateAccess()
+	{
+		return immediateAccess;
+	}
+
+	public EntityKey getKey()
+	{
+		return key;
+	}
+
+	public boolean isUseIdentityColumn()
+	{
+		return useIdentityColumn;
+	}
+
+	public boolean performSave() {
+		return performSave;
+	}
+
+	public Serializable getId()
+	{
+		return id;
+	}
+}
