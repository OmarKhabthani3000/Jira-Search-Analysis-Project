Here's a testcase that reproduces the issue:

	/**
	 * Test that setting a transaction timeout will cause an Exception to occur
	 * if the transaction timeout is exceeded.
	 */
	@Test
	public void testTimeout() throws Exception {
		final int TIMEOUT = 2;
		final int WAIT = TIMEOUT + 1;
		Session s = openSession();
		// Get the transaction and set the timeout BEFORE calling begin()
		Transaction t = s.getTransaction();
		t.setTimeout( TIMEOUT );
		t.begin();
		// Sleep for an amount of time that exceeds the transaction timeout
		Thread.sleep( WAIT * 1000 );
        try {
        	// Do something with the transaction and try to commit it
        	s.persist( new User( "john", "test" ) );
        	t.commit();
            fail( "Transaction should have timed out" );
        } 
        catch ( TransactionException e ) {
        	// Insure that the Exception is "transaction timeout expired"
        	String exceptionActual = e.toString();
			String exceptionExpected = "org.hibernate.TransactionException: transaction timeout expired";
			if ( !exceptionActual.contains( exceptionExpected ) ) {
        		String msg = String.format( "Transaction failed for the wrong reason.  Expected [%s] but received [%s]",
        				exceptionExpected, exceptionActual );
        		fail( msg );
        				
        	}
        } 
	}


To fix the issue, change AbstractBatchImpl.buildBatchStatement() so it calls StatementPreparer.prepareStatement():

	private PreparedStatement buildBatchStatement(String sql, boolean callable) {
		return jdbcCoordinator.getStatementPreparer().prepareStatement( sql, callable );
	}
