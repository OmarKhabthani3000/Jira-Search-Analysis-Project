Index: D:/workspaces/hibernate/org.hibernate.eclipse.console/src/org/hibernate/eclipse/hqleditor/HQLWordDetector.java
===================================================================
--- D:/workspaces/hibernate/org.hibernate.eclipse.console/src/org/hibernate/eclipse/hqleditor/HQLWordDetector.java	(revision 7708)
+++ D:/workspaces/hibernate/org.hibernate.eclipse.console/src/org/hibernate/eclipse/hqleditor/HQLWordDetector.java	(working copy)
@@ -26,7 +26,7 @@
 public class HQLWordDetector implements IWordDetector {
 
     public boolean isWordStart( char c ) {
-        String[] reservedWords = HQLCodeScanner.getHQLKeywords();
+        String[] reservedWords = HQLCodeScanner.getHQLFunctionNames();
         for (int i = 0; i < reservedWords.length; i++) {
             if ( (reservedWords[i].charAt(0) == c)
               || (reservedWords[i].toUpperCase().charAt(0) == c) ) {
@@ -38,7 +38,7 @@
     }
 
     public boolean isWordPart( char c ) {
-        String[] keywords = HQLCodeScanner.getHQLKeywords();
+        String[] keywords = HQLCodeScanner.getHQLFunctionNames();
         for (int i = 0; i < keywords.length; i++) {
             if ( (keywords[i].indexOf(c) != -1)
               || (keywords[i].toUpperCase().indexOf(c) != -1) ) {
Index: D:/workspaces/hibernate/org.hibernate.eclipse.console/src/org/hibernate/eclipse/hqleditor/HQLLexerRule.java
===================================================================
--- D:/workspaces/hibernate/org.hibernate.eclipse.console/src/org/hibernate/eclipse/hqleditor/HQLLexerRule.java	(revision 7708)
+++ D:/workspaces/hibernate/org.hibernate.eclipse.console/src/org/hibernate/eclipse/hqleditor/HQLLexerRule.java	(working copy)
@@ -21,64 +21,195 @@
  */
 package org.hibernate.eclipse.hqleditor;
 
-import java.io.IOException;
-import java.io.Reader;
+import java.io.InputStream;
 
+import org.eclipse.jface.text.TextAttribute;
 import org.eclipse.jface.text.rules.ICharacterScanner;
 import org.eclipse.jface.text.rules.IRule;
 import org.eclipse.jface.text.rules.IToken;
+import org.eclipse.jface.text.rules.Token;
+import org.eclipse.swt.SWT;
+import org.hibernate.eclipse.hqleditor.preferences.HQLPreferenceConstants;
 import org.hibernate.hql.antlr.HqlBaseLexer;
 import org.hibernate.hql.antlr.HqlSqlTokenTypes;
 
-import antlr.Token;
 import antlr.TokenStreamException;
 
 public class HQLLexerRule implements IRule {
+	
+	private class ScannerInputStream extends InputStream{
+		private ICharacterScanner scanner;
+		private int lastChar = -1;
+		
+		public ScannerInputStream(ICharacterScanner scanner){
+			this.scanner = scanner;
+		}
+		
+		@Override
+		public int read() {
+			lastChar = scanner.read();
+			return lastChar;
+		}
+		
+		public int getLastChar(){
+			return lastChar;
+		}
+	}
 
-	private final IToken hqlToken;
+    final IToken hqlToken;
+    final IToken idenToken;
 
-	public HQLLexerRule(IToken hqlToken) {
-		this.hqlToken = hqlToken;
-	}
+	public HQLLexerRule(HQLColors colorProvider) {
+        hqlToken 	= new Token( new TextAttribute( colorProvider.getColor( HQLPreferenceConstants.HQL_KEYWORD_COLOR ), null, SWT.BOLD));
+        idenToken	= new Token( new TextAttribute( colorProvider.getColor( HQLPreferenceConstants.HQL_IDENTIFIER_COLOR ))); 
+    }
 
 	public IToken evaluate(final ICharacterScanner scanner) {
-		HqlBaseLexer lexer = new HqlBaseLexer(new Reader() {
+		
+		ScannerInputStream sis = new ScannerInputStream(scanner);
+		
+		HqlBaseLexer lexer = new HqlBaseLexer(sis);
+		
+		try {
+			antlr.Token token = lexer.nextToken();
+			switch (token.getType()) {
+			//case HqlSqlTokenTypes.IDENT:
+			case HqlSqlTokenTypes.ID_LETTER:
+				checkRedundantRead(scanner, sis.getLastChar());
+				return idenToken;
+			case HqlSqlTokenTypes.AND:
+			case HqlSqlTokenTypes.BETWEEN:
+			case HqlSqlTokenTypes.BOTH:
+			case HqlSqlTokenTypes.CASE:
+			case HqlSqlTokenTypes.CLASS:
+			case HqlSqlTokenTypes.DELETE:
+			case HqlSqlTokenTypes.DESCENDING:
+			case HqlSqlTokenTypes.DISTINCT:
+			case HqlSqlTokenTypes.ELEMENTS:
+			case HqlSqlTokenTypes.ELSE:
+			case HqlSqlTokenTypes.EMPTY:
+			case HqlSqlTokenTypes.END:
+			case HqlSqlTokenTypes.ESCAPE:
+			case HqlSqlTokenTypes.EXISTS:
+			case HqlSqlTokenTypes.FALSE:
+			case HqlSqlTokenTypes.FETCH:
+			case HqlSqlTokenTypes.FROM:
+			case HqlSqlTokenTypes.FULL:
+			case HqlSqlTokenTypes.GROUP:
+			case HqlSqlTokenTypes.HAVING:
+			case HqlSqlTokenTypes.IN:
+			case HqlSqlTokenTypes.INDICES:
+			case HqlSqlTokenTypes.INNER:
+			case HqlSqlTokenTypes.INSERT:
+			case HqlSqlTokenTypes.INTO:
+			case HqlSqlTokenTypes.IS:
+			case HqlSqlTokenTypes.JOIN:
+			case HqlSqlTokenTypes.LEADING:
+			case HqlSqlTokenTypes.LEFT:				
+			case HqlSqlTokenTypes.LIKE:
+			case HqlSqlTokenTypes.MEMBER:
+			case HqlSqlTokenTypes.NEW:
+			case HqlSqlTokenTypes.NOT:
+			case HqlSqlTokenTypes.NULL:
+			case HqlSqlTokenTypes.OBJECT:
+			case HqlSqlTokenTypes.OF:
+			case HqlSqlTokenTypes.ON:
+			case HqlSqlTokenTypes.OR:
+			case HqlSqlTokenTypes.ORDER:
+			case HqlSqlTokenTypes.OUTER:
+			case HqlSqlTokenTypes.PROPERTIES:
+			case HqlSqlTokenTypes.RIGHT:
+			case HqlSqlTokenTypes.SELECT:
+			case HqlSqlTokenTypes.SET:
+			case HqlSqlTokenTypes.SOME:
+			case HqlSqlTokenTypes.THEN:
+			case HqlSqlTokenTypes.TRAILING:
+			case HqlSqlTokenTypes.TRUE:
+			case HqlSqlTokenTypes.UNION:
+			case HqlSqlTokenTypes.UPDATE:
+			case HqlSqlTokenTypes.VERSIONED:
+			case HqlSqlTokenTypes.WHEN:
+			case HqlSqlTokenTypes.WHERE:
+			case HqlSqlTokenTypes.WITH:				
 
-			public void close() throws IOException {
-				// noop				
+			//new cases
+			case HqlSqlTokenTypes.ALL:
+			case HqlSqlTokenTypes.ANY:
+			case HqlSqlTokenTypes.AS:
+			case HqlSqlTokenTypes.ASCENDING:
+			case HqlSqlTokenTypes.AVG:
+			//case HqlSqlTokenTypes.CLOSE:			//')'
+			//case HqlSqlTokenTypes.CLOSE_BRACKET:	//']'
+			//case HqlSqlTokenTypes.COLON:
+			//case HqlSqlTokenTypes.COMMA:
+			//case HqlSqlTokenTypes.CONCAT:
+			case HqlSqlTokenTypes.COUNT:
+			//case HqlSqlTokenTypes.DIV:			
+			//case HqlSqlTokenTypes.EQ:
+			//case HqlSqlTokenTypes.ESCqs:
+			case HqlSqlTokenTypes.EXPONENT:
+			case HqlSqlTokenTypes.FLOAT_SUFFIX:
+			//case HqlSqlTokenTypes.GE:
+			//case HqlSqlTokenTypes.GT:
+			//case HqlSqlTokenTypes.LE:
+			case HqlSqlTokenTypes.LITERAL_ascending:
+			case HqlSqlTokenTypes.LITERAL_by:
+			case HqlSqlTokenTypes.LITERAL_descending:
+			case HqlSqlTokenTypes.MAX:
+			case HqlSqlTokenTypes.MIN:
+			//case HqlSqlTokenTypes.MINUS:
+			//case HqlSqlTokenTypes.NE:
+			//case HqlSqlTokenTypes.OPEN:				//'('
+			//case HqlSqlTokenTypes.OPEN_BRACKET:		//'['
+			case HqlSqlTokenTypes.PARAM:
+			//case HqlSqlTokenTypes.PLUS:
+			//case HqlSqlTokenTypes.SQL_NE:
+			//case HqlSqlTokenTypes.STAR:
+			case HqlSqlTokenTypes.SUM:
+				checkRedundantRead(scanner, sis.getLastChar());
+				return hqlToken;
+				
+			case HqlSqlTokenTypes.DOT:
+				scanner.unread();
+				return hqlToken;
 			}
-
-			public int read(char[] cbuf, int off, int len) throws IOException {
-				int pos = 0;
-				int lastRead = ICharacterScanner.EOF;
-				while(pos<off && (lastRead=scanner.read())!=ICharacterScanner.EOF) {
-					pos++;
+			
+			if (token.getText() != null){
+				if (token.getText().length() > 1 ){
+					checkRedundantRead(scanner, sis.getLastChar());
 				}
-				
-				while(pos-off<len && (lastRead=scanner.read())!=ICharacterScanner.EOF) {
-					cbuf[pos-off] = (char) lastRead;
-					pos++;
-				}
-				
-				if(lastRead==ICharacterScanner.EOF) {
-					return -1;
-				} else {
-					return len;
-				}				
+				for (int i= 0; i < token.getText().length(); i++)
+					scanner.unread();
 			}
-			
-		});
-		try {
-			Token token = lexer.nextToken();
-			if(token.getType()==HqlSqlTokenTypes.IDENT) {
-				return hqlToken;
-			} 
 		}
 		catch (TokenStreamException e) {
 			// undefined
 		}
-		
-		return org.eclipse.jface.text.rules.Token.UNDEFINED;		
+		return Token.UNDEFINED;
 	}
+	
+	private void checkRedundantRead(ICharacterScanner scanner, int lastRead){
+		switch (lastRead) {
+		case '/':
+		case '*':
+		case '+':
+		case '-':
+		case ',':
+		case ':':
+		case '=':
+		case '<':
+		case '>':
+		case '(':
+		case ')':
+		case '[':
+		case ']':
+		case '?':
+		case '|':
+		case ' ':
+		case '\r':
+		case '\n':
+			scanner.unread();
+		}
+	}
 
 }
Index: D:/workspaces/hibernate/org.hibernate.eclipse.console/src/org/hibernate/eclipse/hqleditor/HQLCodeScanner.java
===================================================================
--- D:/workspaces/hibernate/org.hibernate.eclipse.console/src/org/hibernate/eclipse/hqleditor/HQLCodeScanner.java	(revision 7708)
+++ D:/workspaces/hibernate/org.hibernate.eclipse.console/src/org/hibernate/eclipse/hqleditor/HQLCodeScanner.java	(working copy)
@@ -40,71 +40,6 @@
 
 public class HQLCodeScanner extends RuleBasedScanner {
 
-    /** Defines the HQL keywords. Based on hql.g antlr grammer in 2005 ;) */
-    private static String[] hqlKeywords = {
-    	"between", //$NON-NLS-1$
-    	"class", //$NON-NLS-1$
-    	"delete", //$NON-NLS-1$
-    	"desc", //$NON-NLS-1$
-    	"distinct", //$NON-NLS-1$
-    	"elements", //$NON-NLS-1$
-    	"escape", //$NON-NLS-1$
-    	"exists", //$NON-NLS-1$
-    	"false", //$NON-NLS-1$
-    	"fetch", //$NON-NLS-1$
-    	"from", //$NON-NLS-1$
-    	"full", //$NON-NLS-1$
-    	"group", //$NON-NLS-1$
-    	"having", //$NON-NLS-1$
-    	"in", //$NON-NLS-1$
-    	"indices", //$NON-NLS-1$
-    	"inner", //$NON-NLS-1$
-    	"insert", //$NON-NLS-1$
-    	"into", //$NON-NLS-1$
-    	"is", //$NON-NLS-1$
-    	"join", //$NON-NLS-1$
-    	"left", //$NON-NLS-1$
-    	"like", //$NON-NLS-1$
-    	"new", //$NON-NLS-1$
-    	"not", //$NON-NLS-1$
-    	"null", //$NON-NLS-1$
-    	"or", //$NON-NLS-1$
-    	"order", //$NON-NLS-1$
-    	"outer", //$NON-NLS-1$
-    	"properties", //$NON-NLS-1$
-    	"right", //$NON-NLS-1$
-    	"select", //$NON-NLS-1$
-    	"set", //$NON-NLS-1$
-    	"some", //$NON-NLS-1$
-    	"true", //$NON-NLS-1$
-    	"union", //$NON-NLS-1$
-    	"update", //$NON-NLS-1$
-    	"versioned", //$NON-NLS-1$
-    	"where", //$NON-NLS-1$
-    	"and",
-    	"or",
-
-   		// -- SQL tokens --
-   		// These aren't part of HQL, but usefull when you have SQL in the editor
-    	"case", //$NON-NLS-1$
-    	"end", //$NON-NLS-1$
-    	"else", //$NON-NLS-1$
-    	"then", //$NON-NLS-1$
-    	"when", //$NON-NLS-1$
-    	"on", //$NON-NLS-1$
-    	"with", //$NON-NLS-1$
-
-    	// -- EJBQL tokens --
-    	"both", //$NON-NLS-1$
-    	"empty", //$NON-NLS-1$
-    	"leading", //$NON-NLS-1$
-    	"member", //$NON-NLS-1$
-    	"object", //$NON-NLS-1$
-    	"of", //$NON-NLS-1$
-    	"trailing", //$NON-NLS-1$
-        };
-    
-   
     /** built-in function names. Various normal builtin functions in SQL/HQL. Maybe sShould try and do this dynamically based on dialect */
     private static String[] builtInFunctions = {
 		    // standard sql92 functions
@@ -210,7 +145,6 @@
     static {
     	// for performance in search.
     	Arrays.sort(builtInFunctions);
-    	Arrays.sort(hqlKeywords);
     }
     
     static public class HQLWhiteSpaceDetector implements IWhitespaceDetector {
@@ -224,12 +158,6 @@
     public HQLCodeScanner( HQLColors colorProvider ) {
         final IToken commentToken    = new Token( new TextAttribute( colorProvider.getColor( HQLPreferenceConstants.HQL_COMMENT_COLOR )));
         final IToken stringToken     = new Token( new TextAttribute( colorProvider.getColor( HQLPreferenceConstants.HQL_QUOTED_LITERAL_COLOR )));
-        final IToken keywordToken    = new Token( new TextAttribute( colorProvider.getColor( HQLPreferenceConstants.HQL_KEYWORD_COLOR ), null, SWT.BOLD)) {
-        	public Object getData() {
-        		// TODO Auto-generated method stub
-        		return super.getData();
-        	}
-        };
         final IToken functionToken   = new Token( new TextAttribute( colorProvider.getColor( HQLPreferenceConstants.HQL_KEYWORD_COLOR )));
         final IToken otherToken      = new Token( new TextAttribute( colorProvider.getColor( HQLPreferenceConstants.HQL_DEFAULT_COLOR )));        
         
@@ -241,9 +169,8 @@
         rules.add( new SingleLineRule( "'", "'", stringToken, '\\' )); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
         rules.add( new WhitespaceRule( new HQLWhiteSpaceDetector() ));
 
-        //rules.add( new HQLLexerRule( hqlToken )); // TODO: need to categorize tokens into types.
+        rules.add( new HQLLexerRule( colorProvider ));
         WordRule wordRule = new WordRule( new HQLWordDetector(), otherToken );
-        addWordRules( keywordToken, wordRule, getHQLKeywords() );
         addWordRules( functionToken, wordRule, getHQLFunctionNames() );
         
         rules.add( wordRule );
@@ -257,10 +184,6 @@
             wordRule.addWord( reservedWords[i].toUpperCase(), token );
         }
 	}
-
-    public static String[] getHQLKeywords() {
-        return hqlKeywords;
-    }
     
     public static String[] getHQLFunctionNames() {
         return builtInFunctions;
