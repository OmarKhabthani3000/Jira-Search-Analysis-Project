Index: /media/hdb5/home/sorin/Projects/hibernate-tools/trunk/src/main/java/org/hibernate/cfg/JDBCBinder.java
===================================================================
--- /media/hdb5/home/sorin/Projects/hibernate-tools/trunk/src/main/java/org/hibernate/cfg/JDBCBinder.java       (revision 341)
+++ /media/hdb5/home/sorin/Projects/hibernate-tools/trunk/src/main/java/org/hibernate/cfg/JDBCBinder.java       (revision 328)
@@ -1,927 +1,928 @@
-/*
- * Created on 2004-11-23
- *
- */
-package org.hibernate.cfg;
-
-
-import java.sql.SQLException;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.hibernate.DuplicateMappingException;
-import org.hibernate.FetchMode;
-import org.hibernate.MappingException;
-import org.hibernate.cfg.reveng.DatabaseCollector;
-import org.hibernate.cfg.reveng.JDBCReader;
-import org.hibernate.cfg.reveng.JDBCToHibernateTypeHelper;
-import org.hibernate.cfg.reveng.MappingsDatabaseCollector;
-import org.hibernate.cfg.reveng.ReverseEngineeringStrategy;
-import org.hibernate.cfg.reveng.TableIdentifier;
-import org.hibernate.connection.ConnectionProvider;
-import org.hibernate.engine.Mapping;
-import org.hibernate.engine.Versioning;
-import org.hibernate.mapping.Collection;
-import org.hibernate.mapping.Column;
-import org.hibernate.mapping.Component;
-import org.hibernate.mapping.DependantValue;
-import org.hibernate.mapping.ForeignKey;
-import org.hibernate.mapping.KeyValue;
-import org.hibernate.mapping.ManyToOne;
-import org.hibernate.mapping.MetaAttribute;
-import org.hibernate.mapping.OneToMany;
-import org.hibernate.mapping.PersistentClass;
-import org.hibernate.mapping.Property;
-import org.hibernate.mapping.RootClass;
-import org.hibernate.mapping.Selectable;
-import org.hibernate.mapping.SimpleValue;
-import org.hibernate.mapping.Table;
-import org.hibernate.mapping.Value;
-import org.hibernate.type.Type;
-import org.hibernate.type.TypeFactory;
-import org.hibernate.util.JoinedIterator;
-import org.hibernate.util.StringHelper;
-
-
-/**
- * @author max
- *
- */
-public class JDBCBinder {
-
-       private Settings settings;
-       private ConnectionProvider connectionProvider;
-       private static final Log log = LogFactory.getLog(JDBCBinder.class);
-       
-       private final Mappings mappings;
-       
-       private final JDBCMetaDataConfiguration cfg;
-       private ReverseEngineeringStrategy revengStrategy;
-
-       /**
-        * @param mappings
-        * @param configuration
-        */
-       public JDBCBinder(JDBCMetaDataConfiguration cfg, Settings settings, Mappings mappings, ReverseEngineeringStrategy revengStrategy) {
-              this.cfg = cfg;
-              this.settings = settings;
-              this.mappings = mappings;
-              this.revengStrategy = revengStrategy;
-       }
-
-       /**
-        * 
-        */
-       public void readFromDatabase(String catalog, String schema, Mapping mapping) {
-              
-              this.connectionProvider = settings.getConnectionProvider();
-                            
-              try {
-                     
-                     Map oneToManyCandidates = readDatabaseSchema(catalog, schema); 
-                     
-                     createPersistentClasses(oneToManyCandidates, mapping); //move this to a different step!
-              } 
-              catch (SQLException e) {
-                     throw settings.getSQLExceptionConverter().convert(e, "Reading from database", null);
-              } 
-              finally        {
-                            if(connectionProvider!=null) connectionProvider.close();
-              }
-              
-       }
-
-       /**
-        * Read JDBC Metadata from the database. Does not create any classes or other ORM releated structures.
-        * 
-        * @deprecated should use readDatabaseSchema(DatabaseCollector, catalog, schema)
-        * @param catalog
-        * @param schema
-        * @return 
-        * @throws SQLException
-        */
-       public Map readDatabaseSchema(String catalog, String schema) throws SQLException {
-               // use default from settings if nothing else specified.
-            catalog = catalog!=null ? catalog : settings.getDefaultCatalogName();
-            schema = schema!=null ? schema : settings.getDefaultSchemaName();
-            
-            JDBCReader reader = JDBCReaderFactory.newJDBCReader(cfg.getProperties(),settings,revengStrategy);
-            DatabaseCollector dbs = new MappingsDatabaseCollector(mappings); 
-            reader.readDatabaseSchema(dbs, catalog, schema);
-            return dbs.getOneToManyCandidates();
-       }
-
-
-       
-       /**
-        * @param manyToOneCandidates
-        * @param mappings2
-        */
-       private void createPersistentClasses(Map manyToOneCandidates, Mapping mapping) {
-              
-              for (Iterator iter = mappings.iterateTables(); iter.hasNext();) {
-                     Table table = (Table) iter.next();
-                     if(table.getColumnSpan()==0) {
-                            log.warn("Cannot create persistent class for " + table + " as no columns were found.");
-                            continue;
-                     }
-                     // TODO: this naively just create an entity per table
-                     // should have an opt-out option to mark some as helper tables, subclasses etc.
-                     /*if(table.getPrimaryKey()==null || table.getPrimaryKey().getColumnSpan()==0) {
-                         log.warn("Cannot create persistent class for " + table + " as no primary key was found.");
-                continue;
-                // TODO: just create one big embedded composite id instead.
-            }*/
-                     
-                     if(revengStrategy.isManyToManyTable(table)) {
-                            log.debug( "Ignoring " + table + " as class since rev.eng. says it is a many-to-many" );
-                            continue;
-                     }                           
-                            
-                     RootClass rc = new RootClass();
-                     TableIdentifier tableIdentifier = TableIdentifier.create(table);
-                     String className = revengStrategy.tableToClassName( tableIdentifier );
-                     rc.setEntityName( className );
-                     rc.setClassName( className );                       
-                     rc.setProxyInterfaceName( rc.getEntityName() ); // TODO: configurable ?
-                     rc.setLazy(true);
-                     
-                     rc.setMetaAttributes( safeMeta(revengStrategy.tableToMetaAttributes( tableIdentifier )) );
-                     
-                     
-                     rc.setDiscriminatorValue( rc.getEntityName() );
-                     rc.setTable(table);
-                     try {
-                            mappings.addClass(rc);
-                     } catch(DuplicateMappingException dme) {
-                            // TODO: detect this and generate a "permutation" of it ?
-                            PersistentClass class1 = mappings.getClass(dme.getName());
-                            Table table2 = class1.getTable();
-                            throw new JDBCBinderException("Duplicate class name '" + rc.getEntityName() + "' generated for '" + table + "'. Same name where generated for '" + table2 + "'"); 
-                     }
-                     mappings.addImport( rc.getEntityName(), rc.getEntityName() );
-                     
-                     Set processed = new HashSet();
-            
-                     bindPrimaryKeyToProperties(table, rc, processed, mapping);
-                     bindColumnsToVersioning(table, rc, processed, mapping);
-                     bindOutgoingForeignKeys(table, rc, processed);
-                     bindColumnsToProperties(table, rc, processed, mapping);
-                     List incomingForeignKeys = (List) manyToOneCandidates.get( rc.getEntityName() );
-                     bindIncomingForeignKeys(rc, processed, incomingForeignKeys, mapping);
-              }
-              
-       }
-              
-       private Map safeMeta(Map map) {
-              if(map==null) {
-                     return new HashMap();
-              } else {
-                     return map;
-              }
-       }
-
-       // bind collections.
-       private void bindIncomingForeignKeys(PersistentClass rc, Set processed, List foreignKeys, Mapping mapping) {
-              if(foreignKeys!=null) {
-                     for (Iterator iter = foreignKeys.iterator(); iter.hasNext();) {
-                            ForeignKey foreignKey = (ForeignKey) iter.next();
-                                                        
-                            if(revengStrategy.excludeForeignKeyAsCollection(
-                                          foreignKey.getName(), 
-                                          TableIdentifier.create(foreignKey.getTable() ), 
-                                          foreignKey.getColumns(), 
-                                          TableIdentifier.create(foreignKey.getReferencedTable() ),
-                                          foreignKey.getReferencedColumns())) {
-                                   log.debug("Rev.eng excluded one-to-many for foreignkey " + foreignKey.getName());
-                            } else {
-                                                                      
-                                   Property property = bindOneToMany(rc, foreignKey, processed, mapping);
-                                   rc.addProperty(property);
-                            }
-                     }
-              }
-       }
-
-    /**
-     * @param table
-     * @param fk
-     * @param columnsToBind 
-     * @param processedColumns
-     * @param rc
-     * @param propName 
-     */
-    private Property bindManyToOne(String propertyName, Table table, ForeignKey fk, Set processedColumns) {
-        ManyToOne value = new ManyToOne(table);
-        value.setReferencedEntityName( fk.getReferencedEntityName() );
-              Iterator columns = fk.getColumnIterator();
-        while ( columns.hasNext() ) {       
-                     Column fkcolumn = (Column) columns.next();
-            checkColumn(fkcolumn);
-            value.addColumn(fkcolumn);
-            processedColumns.add(fkcolumn);
-              }
-        value.setFetchMode(FetchMode.SELECT);        
-        return makeProperty(TableIdentifier.create( table ), propertyName, value, true, true, value.getFetchMode()!=FetchMode.JOIN, null, null);
-     }
-
-       /**
-        * @param rc
-        * @param processed
-        * @param table
-        * @param object
-        */
-       private Property bindOneToMany(PersistentClass rc, ForeignKey foreignKey, Set processed, Mapping mapping) {
-              
-              Table collectionTable = foreignKey.getTable();
-
-              Collection collection = new org.hibernate.mapping.Set(rc); // MASTER TODO: allow overriding collection type
-
-              collection.setCollectionTable(collectionTable); // CHILD+
-              
-              
-              
-              boolean manyToMany = revengStrategy.isManyToManyTable( collectionTable );
-              if(manyToMany) {
-                     log.debug("Rev.eng said here is a many-to-many");
-                     // TODO: handle "the other side should influence the name"
-              }
-        
-
-
-        if(manyToMany) {
-               
-               ManyToOne element = new ManyToOne( collection.getCollectionTable() );
-               //TODO: find the other foreignkey and choose the other side.
-               Iterator foreignKeyIterator = foreignKey.getTable().getForeignKeyIterator();
-               List keys = new ArrayList();
-               while ( foreignKeyIterator.hasNext() ) {
-                            Object next = foreignKeyIterator.next();
-                            if(next!=foreignKey) {
-                                   keys.add(next);                      
-                            }
-                     }
-               
-               if(keys.size()>1) {
-                      throw new JDBCBinderException("more than one other foreign key to choose from!"); // todo: handle better ?
-               }
-               
-               ForeignKey fk = (ForeignKey) keys.get( 0 );
-
-               String tableToClassName = bindCollection( rc, foreignKey, fk, collection );
-                             
-                     element.setReferencedEntityName( tableToClassName );
-                     element.addColumn( fk.getColumn( 0 ) );
-                     collection.setElement( element );
-                     
-        } else {
-               String tableToClassName = bindCollection( rc, foreignKey, null, collection );
-            
-               OneToMany oneToMany = new OneToMany( collection.getOwner() );
-               
-                     oneToMany.setReferencedEntityName( tableToClassName ); // Child
-               mappings.addSecondPass( new JDBCCollectionSecondPass(mappings, collection) );
-               
-               collection.setElement(oneToMany);
-        }
-              // bind keyvalue
-              KeyValue referencedKeyValue;
-              String propRef = collection.getReferencedPropertyName();
-              if (propRef==null) {
-                     referencedKeyValue = collection.getOwner().getIdentifier();
-              }
-              else {
-                     referencedKeyValue = (KeyValue) collection.getOwner()
-                            .getProperty(propRef)
-                            .getValue();
-              }
-
-              SimpleValue keyValue = new DependantValue( collectionTable, referencedKeyValue );
-              //key.setCascadeDeleteEnabled( "cascade".equals( subnode.attributeValue("on-delete") ) );
-              Iterator columnIterator = foreignKey.getColumnIterator();        
-              while ( columnIterator.hasNext() ) {
-                     Column fkcolumn = (Column) columnIterator.next();
-                     if(fkcolumn.getSqlTypeCode()!=null) { // TODO: user defined foreign ref columns does not have a type set.
-                            guessAndAlignType(collectionTable, fkcolumn, mapping, false); // needed to ensure foreign key columns has same type as the "property" column.
-                     }
-                     keyValue.addColumn( fkcolumn );
-              }
-              
-              collection.setKey(keyValue);
-              
-              mappings.addCollection(collection);
-              
-              return makeProperty(TableIdentifier.create( rc.getTable() ), StringHelper.unqualify( collection.getRole() ), collection, true, true, true, "all", null); // TODO: cascade isn't all by default
-              
-       }
-
-       private String bindCollection(PersistentClass rc, ForeignKey fromForeignKey, ForeignKey toForeignKey, Collection collection) {
-              ForeignKey targetKey = fromForeignKey;
-              String collectionRole = null;
-              boolean collectionLazy = false;
-              boolean collectionInverse = false;
-              TableIdentifier foreignKeyTable = null;
-              String tableToClassName;
-              
-              if(toForeignKey!=null) {
-                     targetKey = toForeignKey;
-              }
-              
-              boolean uniqueReference = isUniqueReference(targetKey); // TODO: need to look one step further for many-to-many!
-              foreignKeyTable = TableIdentifier.create( targetKey.getTable() );
-              TableIdentifier foreignKeyReferencedTable = TableIdentifier.create( targetKey.getReferencedTable() );
-              
-              if(toForeignKey==null) {
-              
-                     collectionRole = revengStrategy.foreignKeyToCollectionName(
-                                   fromForeignKey.getName(),                           
-                                   foreignKeyTable,       
-                                   fromForeignKey.getColumns(), 
-                                   foreignKeyReferencedTable, 
-                                   fromForeignKey.getReferencedColumns(), 
-                                   uniqueReference
-                     );
-              
-                     tableToClassName = revengStrategy.tableToClassName( foreignKeyTable );
-              } else {
-                     
-                     collectionRole = revengStrategy.foreignKeyToManyToManyName( 
-                                   fromForeignKey, TableIdentifier.create( fromForeignKey.getTable()), toForeignKey, uniqueReference );
-                     
-                     tableToClassName = revengStrategy.tableToClassName( foreignKeyReferencedTable );
-              }
-
-              collectionInverse = revengStrategy.isForeignKeyCollectionInverse(targetKey.getName(),                       
-                            foreignKeyTable,       
-                            targetKey.getColumns(), 
-                            foreignKeyReferencedTable, 
-                            targetKey.getReferencedColumns());
-              
-              collectionLazy = revengStrategy.isForeignKeyCollectionLazy(targetKey.getName(),                             
-                            foreignKeyTable,       
-                            targetKey.getColumns(), 
-                            foreignKeyReferencedTable, 
-                            targetKey.getReferencedColumns());
-              
-              collectionRole = makeUnique(rc,collectionRole);
-              
-              String fullRolePath = StringHelper.qualify(rc.getEntityName(), collectionRole);
-              if (mappings.getCollection(fullRolePath)!=null) {
-                  log.debug(fullRolePath + " found twice!");
-              }
-              
-              collection.setRole(fullRolePath);  // Master.setOfChildren+           
-              collection.setInverse(collectionInverse); // TODO: allow overriding this
-              collection.setLazy(collectionLazy); 
-              collection.setFetchMode(FetchMode.SELECT);
-              
-              
-              return tableToClassName;
-       }
-
-       /** return true if this foreignkey is the only reference from this table to the same foreign table */
-    private boolean isUniqueReference(ForeignKey foreignKey) {
-              
-       Iterator foreignKeyIterator = foreignKey.getTable().getForeignKeyIterator();
-       while ( foreignKeyIterator.hasNext() ) {
-                     ForeignKey element = (ForeignKey) foreignKeyIterator.next();
-                     if(element!=foreignKey && element.getReferencedTable().equals(foreignKey.getReferencedTable())) {
-                            return false;
-                     }
-              }
-              return true;
-       }
-
-       private void bindPrimaryKeyToProperties(Table table, RootClass rc, Set processed, Mapping mapping) {
-              SimpleValue id = null;
-              String idPropertyname = null;
-              
-              List keyColumns = null;
-              if (table.getPrimaryKey()!=null) {
-                     keyColumns = table.getPrimaryKey().getColumns();
-              } 
-              else {
-                     log.debug("No primary key found for " + table + ", using all properties as the identifier.");
-                     keyColumns = new ArrayList();
-                     Iterator iter = table.getColumnIterator();
-                     while (iter.hasNext() ) {
-                            Column col = (Column) iter.next();
-                            keyColumns.add(col);
-                     }
-              }
-
-              final TableIdentifier tableIdentifier = TableIdentifier.create(table);
-              
-              String tableIdentifierStrategyName = null;
-              
-              boolean naturalId;
-              
-              if (keyColumns.size()>1) {
-                     tableIdentifierStrategyName = "assigned";
-                     naturalId = true;
-                     
-                     id = handleCompositeKey(rc, processed, keyColumns, mapping);
-                     idPropertyname = revengStrategy.tableToIdentifierPropertyName(tableIdentifier);
-                     if(idPropertyname==null) {
-                            idPropertyname = "id";
-                     }
-              } 
-              else {
-                     tableIdentifierStrategyName = revengStrategy.getTableIdentifierStrategyName(tableIdentifier);
-                     naturalId = "assigned".equals( tableIdentifierStrategyName );
-                     Column pkc = (Column) keyColumns.get(0);
-                     checkColumn(pkc);
-                     
-                     id = bindColumnToSimpleValue(table, pkc, mapping, !naturalId);
-
-                     idPropertyname = revengStrategy.tableToIdentifierPropertyName(tableIdentifier);
-                     if(idPropertyname==null) {
-                            idPropertyname = revengStrategy.columnToPropertyName(tableIdentifier, pkc.getName() );
-                     }
-                     
-                     processed.add(pkc);
-              } 
-              id.setIdentifierGeneratorStrategy(tableIdentifierStrategyName);
-              id.setIdentifierGeneratorProperties(revengStrategy.getTableIdentifierProperties(tableIdentifier));
-              if(naturalId) {
-                     id.setNullValue("undefined");
-              }
-              
-              
-              Property property = makeProperty(tableIdentifier, makeUnique(rc,idPropertyname), id, true, true, false, null, null);
-              rc.setIdentifierProperty(property);            
-              rc.setIdentifier(id);
-                     
-       }
-
-       /**
-        * bind many-to-ones
-        * @param table
-        * @param rc
-        * @param primaryKey
-        */
-       private void bindOutgoingForeignKeys(Table table, RootClass rc, Set processedColumns) {
-              
-              // Iterate the outgoing foreign keys and create many-to-one's 
-              for(Iterator iterator = table.getForeignKeyIterator(); iterator.hasNext();) {
-                     ForeignKey foreignKey = (ForeignKey) iterator.next();
-                     
-                     boolean mutable = true;
-            if ( contains( foreignKey.getColumnIterator(), processedColumns ) ) {
-                            if ( !cfg.preferBasicCompositeIds() ) continue; //it's in the pk, so skip this one
-                            mutable = false;       
-            }
-            
-            if(revengStrategy.excludeForeignKeyAsManytoOne(foreignKey.getName(), 
-                             TableIdentifier.create(foreignKey.getTable() ), 
-                             foreignKey.getColumns(), 
-                             TableIdentifier.create(foreignKey.getReferencedTable() ),
-                             foreignKey.getReferencedColumns())) {
-               // TODO: if many-to-one is excluded should the column be marked as processed so it won't show up at all ?
-               log.debug("Rev.eng excluded many-to-one for foreignkey " + foreignKey.getName());
-            } else {
-               boolean isUnique = isUniqueReference(foreignKey);
-               String propertyName = revengStrategy.foreignKeyToEntityName(
-                             foreignKey.getName(), 
-                             TableIdentifier.create(foreignKey.getTable() ), 
-                             foreignKey.getColumns(), 
-                             TableIdentifier.create(foreignKey.getReferencedTable() ),
-                             foreignKey.getReferencedColumns(), 
-                             isUnique
-               );
-               
-               Property property = bindManyToOne(
-                             makeUnique(rc, propertyName), 
-                             table, 
-                             foreignKey,
-                             processedColumns
-               );
-               property.setUpdateable(mutable);
-               property.setInsertable(mutable);
-               
-               rc.addProperty(property);
-            }
-              }
-       }
-              
-       /**
-        * @param table
-        * @param rc
-        * @param primaryKey
-        */
-       private void bindColumnsToProperties(Table table, RootClass rc, Set processedColumns, Mapping mapping) {
-                     
-              for (Iterator iterator = table.getColumnIterator(); iterator.hasNext();) {
-                     Column column = (Column) iterator.next();
-                     if ( !processedColumns.contains(column) ) {
-                            checkColumn(column);
-                            
-                            String propertyName = revengStrategy.columnToPropertyName(TableIdentifier.create(table), column.getName() );
-                            
-                            Property property = bindBasicProperty( 
-                                          makeUnique(rc,propertyName), 
-                                          table, 
-                                          column, 
-                                          processedColumns,
-                                          mapping
-                                   );
-                                                        
-                            rc.addProperty(property);
-                     }                    
-              }
-       }
-       
-       private void bindColumnsToVersioning(Table table, RootClass rc, Set processed, Mapping mapping) {
-              TableIdentifier identifier = TableIdentifier.create(table);
-              
-              String optimisticLockColumnName = revengStrategy.getOptimisticLockColumnName(identifier);
-              
-              if(optimisticLockColumnName!=null) {
-                     Column column = table.getColumn(new Column(optimisticLockColumnName));
-                     if(column==null) {
-                            log.warn("Column " + column + " wanted for <version>/<timestamp> not found in " + identifier);
-                     } else {
-                            bindVersionProperty(table, identifier, column, rc, processed, mapping);
-                     }
-              } else {
-                     log.debug("Scanning " + identifier + " for <version>/<timestamp> columns.");
-                     Iterator columnIterator = table.getColumnIterator();
-                     while(columnIterator.hasNext()) {
-                            Column column = (Column) columnIterator.next();
-                            boolean useIt = revengStrategy.useColumnForOptimisticLock(identifier, column.getName());
-                            if(useIt && !processed.contains(column)) {
-                                   bindVersionProperty( table, identifier, column, rc, processed, mapping );
-                                   return; 
-                            }
-                     }
-                     log.debug("No columns reported while scanning for <version>/<timestamp> columns in " + identifier);
-              }
-       }
-
-       private void bindVersionProperty(Table table, TableIdentifier identifier, Column column, RootClass rc, Set processed, Mapping mapping) {
-              
-              processed.add(column);
-              String propertyName = revengStrategy.columnToPropertyName( identifier, column.getName() );
-              Property property = bindBasicProperty(makeUnique(rc, propertyName), table, column, processed, mapping);
-              rc.addProperty(property);
-              rc.setVersion(property);
-              rc.setOptimisticLockMode(Versioning.OPTIMISTIC_LOCK_VERSION);
-              log.debug("Column " + column.getName() + " will be used for <version>/<timestamp> columns in " + identifier);
-              
-       }
-
-       private Property bindBasicProperty(String propertyName, Table table, Column column, Set processedColumns, Mapping mapping) {
-
-              SimpleValue value = bindColumnToSimpleValue( table, column, mapping, false );
-              
-              return makeProperty(TableIdentifier.create( table ), propertyName, value, true, true, false, null, null);
-       }
-
-       private SimpleValue bindColumnToSimpleValue(Table table, Column column, Mapping mapping, boolean generatedIdentifier) {
-              SimpleValue value = new SimpleValue(table);                
-              value.addColumn(column);
-              value.setTypeName(guessAndAlignType(table, column, mapping, generatedIdentifier));
-              return value;
-       }
-
-    /**
-     * @param columnIterator
-     * @param processedColumns
-     * @return
-     */
-    private boolean contains(Iterator columnIterator, Set processedColumns) {
-        while (columnIterator.hasNext() ) {
-            Column element = (Column) columnIterator.next();
-            if(processedColumns.contains(element) ) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-       private void checkColumn(Column column) {
-              if(column.getValue()!=null) {
-                     //throw new JDBCBinderException("Binding column twice should not happen. " + column);
-              }
-       }
-
-       /**
-        * @param column
-        * @param generatedIdentifier 
-        * @return
-        */
-       private String guessAndAlignType(Table table, Column column, Mapping mapping, boolean generatedIdentifier) {
-              // TODO: this method mutates the column if the types does not match...not good. 
-              // maybe we should copy the column instead before calling this method.
-              Integer sqlTypeCode = column.getSqlTypeCode();
-              String location = "Table: " + Table.qualify(table.getCatalog(), table.getSchema(), table.getQuotedName() ) + " column: " + column.getQuotedName();
-              if(sqlTypeCode==null) {
-                     throw new JDBCBinderException("sqltype is null for " + location);
-              }
-              
-              String preferredHibernateType = revengStrategy.columnToHibernateTypeName(
-                            TableIdentifier.create(table), 
-                            column.getName(), 
-                            sqlTypeCode.intValue(),
-                            column.getLength(), column.getPrecision(), column.getScale(), column.isNullable(), generatedIdentifier
-              );
-              
-              Type wantedType = TypeFactory.heuristicType(preferredHibernateType);
-              
-              if(wantedType!=null) {
-                     int[] wantedSqlTypes = wantedType.sqlTypes(mapping);
-                     
-                     if(wantedSqlTypes.length>1) {
-                            throw new JDBCBinderException("The type " + preferredHibernateType + " found on " + location + " spans multiple columns. Only single column types allowed."); 
-                     }
-                     
-                     int wantedSqlType = wantedSqlTypes[0];
-                     if(wantedSqlType!=sqlTypeCode.intValue() ) {                 
-                            log.debug("Sql type mismatch for " + location + " between DB and wanted hibernate type. Sql type set to " + typeCodeName( sqlTypeCode.intValue() ) + " instead of " + typeCodeName(wantedSqlType) );
-                            column.setSqlTypeCode(new Integer(wantedSqlType));
-                     }
-              } 
-              else {
-                     log.debug("No Hibernate type found for " + preferredHibernateType + ". Most likely cause is a missing UserType class.");
-              }
-              
-              
-              
-              if(preferredHibernateType==null) {
-                     throw new JDBCBinderException("Could not find javatype for " + typeCodeName(sqlTypeCode.intValue()));
-              }
-        
-              return preferredHibernateType;
-       }
-
-       private String typeCodeName(int sqlTypeCode) {
-              return sqlTypeCode + "(" + JDBCToHibernateTypeHelper.getJDBCTypeName(sqlTypeCode) + ")";
-       }
-
-       /**
-     * Basically create an [classname]Id.class and add  properties for it.
-        * @param rc
-        * @param compositeKeyColumns 
-        * @param processed
-        * @return
-        */
-       private SimpleValue handleCompositeKey(RootClass rc, Set processedColumns, List keyColumns, Mapping mapping) {
-              Component pkc = new Component(rc);
-        pkc.setMetaAttributes(Collections.EMPTY_MAP);
-        pkc.setEmbedded(false);        
-        
-        String compositeIdName = revengStrategy.tableToCompositeIdName(TableIdentifier.create(rc.getTable()));
-        if(compositeIdName==null) {
-               compositeIdName = revengStrategy.classNameToCompositeIdName(rc.getClassName());
-        }
-        pkc.setComponentClassName(compositeIdName);
-              Table table = rc.getTable();          
-        List list = null;        
-              if (cfg.preferBasicCompositeIds() ) {
-            list = new ArrayList(keyColumns);
-        } 
-              else {
-            list = findForeignKeys(table.getForeignKeyIterator(), keyColumns);
-        }
-        for (Iterator iter = list.iterator(); iter.hasNext();) {
-            Object element = iter.next();
-                     Property property;
-            if (element instanceof Column) {
-                Column column = (Column) element;
-                if ( processedColumns.contains(column) ) {
-                    throw new JDBCBinderException("Binding column twice for primary key should not happen: " + column); 
-                } 
-                            else {
-                    checkColumn(column);
-                    
-                    String propertyName = revengStrategy.columnToPropertyName( TableIdentifier.create(table), column.getName() );
-                                   property = bindBasicProperty( makeUnique(pkc, propertyName), table, column, processedColumns, mapping);
-                    
-                    processedColumns.add(column);
-                }
-            } 
-                     else if (element instanceof ForeignKeyForColumns) {
-                ForeignKeyForColumns fkfc = (ForeignKeyForColumns) element;
-                ForeignKey foreignKey = fkfc.key;
-                String propertyName = revengStrategy.foreignKeyToEntityName(
-                                          foreignKey.getName(), 
-                                          TableIdentifier.create(foreignKey.getTable() ),
-                                          foreignKey.getColumns(), TableIdentifier.create(foreignKey.getReferencedTable() ), foreignKey.getReferencedColumns(), true
-                                   );
-                property = bindManyToOne( makeUnique(pkc, propertyName), table, foreignKey, processedColumns);
-                processedColumns.addAll(fkfc.columns);
-            }
-                     else {
-                            throw new JDBCBinderException("unknown thing");
-                     }
-                     
-            markAsUseInEquals(property);
-            pkc.addProperty(property);
-                     
-              }
-
-              return pkc;
-       }
-
-    /**
-     * @param property
-     */
-    private void markAsUseInEquals(Property property) {
-        Map m = new HashMap();
-        MetaAttribute ma = new MetaAttribute("use-in-equals");
-        ma.addValue("true");
-        m.put(ma.getName(),ma);
-        property.setMetaAttributes(m);
-    }
-
-    /**
-     * @param foreignKeyIterator
-     * @param columns
-     * @return 
-     */
-    private List findForeignKeys(Iterator foreignKeyIterator, List pkColumns) {
-       
-       List tempList = new ArrayList();
-       while(foreignKeyIterator.hasNext()) {
-              tempList.add(foreignKeyIterator.next());
-       }
-       
-//     Collections.reverse(tempList); 
-       
-       List result = new ArrayList();
-       Column myPkColumns[] = (Column[]) pkColumns.toArray(new Column[pkColumns.size()]);
-       
-       for (int i = 0; i < myPkColumns.length; i++) {
-                     
-              boolean foundKey = false;
-              foreignKeyIterator = tempList.iterator();
-              while(foreignKeyIterator.hasNext()) {
-                     ForeignKey key = (ForeignKey) foreignKeyIterator.next();
-                     List matchingColumns = columnMatches(myPkColumns, i, key);
-                     if(matchingColumns!=null) {
-                            result.add(new ForeignKeyForColumns(key, matchingColumns));
-                            i+=matchingColumns.size()-1;
-                            foreignKeyIterator.remove();
-                            foundKey=true;
-                            break;
-                     } 
-              }
-              if(!foundKey) {
-                     result.add(myPkColumns[i]);                         
-              }
-              
-              }
-       
-       return result;
-    }
-
-    private List columnMatches(Column[] myPkColumns, int offset, ForeignKey key) {
-              
-       if(key.getColumnSpan()>(myPkColumns.length-offset)) {
-              return null; // not enough columns in the key
-       }
-       
-       List columns = new ArrayList();
-       for (int j = 0; j < key.getColumnSpan(); j++) {
-                     Column column = myPkColumns[j+offset];
-                     if(!column.equals(key.getColumn(j))) {
-                            return null;
-                     } else {
-                            columns.add(column);
-                     }
-              }
-              return columns.isEmpty()?null:columns;
-       }
-
-       static class ForeignKeyForColumns {
-        
-        protected final List columns;
-        protected final ForeignKey key;
-
-        public ForeignKeyForColumns(ForeignKey key, List columns) {
-            this.key = key;
-            this.columns = columns;
-        }
-    }
-
-    private Property makeProperty(TableIdentifier table, String propertyName, Value value, boolean insertable, boolean updatable, boolean lazy, String cascade, String propertyAccessorName) {
-       log.debug("Building property " + propertyName);
-        Property prop = new Property();
-              prop.setName(propertyName);
-              prop.setValue(value);
-              prop.setInsertable(insertable);
-              prop.setUpdateable(updatable);
-              prop.setLazy(lazy);           
-              prop.setCascade(cascade==null?"none":cascade);
-              prop.setPropertyAccessorName(propertyAccessorName==null?"property":propertyAccessorName);             
-              bindMeta(prop, table);
-              
-              return prop;
-       }
-    
-    private Property bindMeta(Property property, TableIdentifier identifier) {
-       Iterator columnIterator = property.getValue().getColumnIterator();
-              while(columnIterator.hasNext()) {
-                     Column col = (Column) columnIterator.next();
-                     
-                     Map map = revengStrategy.columnToMetaAttributes( identifier, col.getName() );
-                     if(map!=null) { // TODO: merge from each column ?
-                            property.setMetaAttributes( map );
-                     }
-              }
-              
-              return property;
-    }
-
-    /**
-     * @param pkc
-     * @param string
-     * @return
-     */
-    private String makeUnique(Component clazz, String propertyName) {
-        return makeUnique(clazz.getPropertyIterator(), propertyName);
-    }
-
-    private String makeUnique(PersistentClass clazz, String propertyName) {
-        List list = new ArrayList();
-                
-        if( clazz.hasIdentifierProperty() ) {
-            list.add( clazz.getIdentifierProperty() );
-        }
-        
-        if( clazz.isVersioned() ) {
-            list.add( clazz.getVersion() );
-        }
-        
-        JoinedIterator iterator = new JoinedIterator( list.iterator(),clazz.getPropertyClosureIterator() );
-        return makeUnique(iterator, propertyName);
-    }
-    /**
-     * @param clazz
-     * @param propertyName
-     * @return
-     */
-    private static String makeUnique(Iterator props, String originalPropertyName) {
-        int cnt = 0;
-        String propertyName = originalPropertyName;
-        Set uniqueNames = new HashSet();
-        
-        while ( props.hasNext() ) {
-            Property element = (Property) props.next();
-            uniqueNames.add( element.getName() );
-        }
-        
-        while( uniqueNames.contains(propertyName) ) { 
-            cnt++;
-            propertyName = originalPropertyName + "_" + cnt;
-        }
-        
-        return propertyName;                                
-    }
-
-    public static void bindCollectionSecondPass(
-            Collection collection,
-            java.util.Map persistentClasses,
-            Mappings mappings,
-            java.util.Map inheritedMetas) throws MappingException {
-
-        if(collection.isOneToMany() ) {
-            OneToMany oneToMany = (OneToMany) collection.getElement();
-            PersistentClass persistentClass = mappings.getClass(oneToMany.getReferencedEntityName() ); 
-            
-            if (persistentClass==null) throw new MappingException(
-                    "Association " + collection.getRole() + " references unmapped class: " + oneToMany.getReferencedEntityName()
-                );
-            
-            oneToMany.setAssociatedClass(persistentClass); // Child            
-        }
-        
-    }
-
-    static class JDBCCollectionSecondPass extends CollectionSecondPass {
-
-        /**
-         * @param mappings
-         * @param coll
-         */
-        JDBCCollectionSecondPass(Mappings mappings, Collection coll) {
-            super(mappings, coll);
-        }
-
-        /* (non-Javadoc)
-         * @see org.hibernate.cfg.HbmBinder.SecondPass#secondPass(java.util.Map, java.util.Map)
-         */
-        public void secondPass(Map persistentClasses, Map inheritedMetas) throws MappingException {
-            JDBCBinder.bindCollectionSecondPass(collection, persistentClasses, mappings, inheritedMetas);            
-        }        
-    }
-       
-}
+/* 
+ * Created on 2004-11-23 
+ * 
+ */ 
+package org.hibernate.cfg; 
+ 
+ 
+import org.apache.commons.logging.Log; 
+import org.apache.commons.logging.LogFactory; 
+import org.hibernate.DuplicateMappingException; 
+import org.hibernate.FetchMode; 
+import org.hibernate.MappingException; 
+import org.hibernate.cfg.reveng.*; 
+import org.hibernate.connection.ConnectionProvider; 
+import org.hibernate.engine.Mapping; 
+import org.hibernate.engine.Versioning; 
+import org.hibernate.mapping.Collection; 
+import org.hibernate.mapping.*; 
+import org.hibernate.tool.hbm2x.visitor.JavaTypeFromValueVisitor; 
+import org.hibernate.type.Type; 
+import org.hibernate.type.TypeFactory; 
+import org.hibernate.util.JoinedIterator; 
+import org.hibernate.util.StringHelper; 
+ 
+import java.sql.SQLException; 
+import java.util.*; 
+import java.util.List; 
+import java.util.Map; 
+import java.util.Set; 
+ 
+ 
+/** 
+ * @author max 
+ */ 
+public class JDBCBinder { 
+ 
+    private Settings settings; 
+    private ConnectionProvider connectionProvider; 
+    private static final Log log = LogFactory.getLog(JDBCBinder.class); 
+ 
+    private final Mappings mappings; 
+ 
+    private final JDBCMetaDataConfiguration cfg; 
+    private ReverseEngineeringStrategy revengStrategy; 
+ 
+    /** 
+     * @param mappings 
+     * @param configuration 
+     */ 
+    public JDBCBinder(JDBCMetaDataConfiguration cfg, Settings settings, Mappings mappings, ReverseEngineeringStrategy revengStrategy) { 
+        this.cfg = cfg; 
+        this.settings = settings; 
+        this.mappings = mappings; 
+        this.revengStrategy = revengStrategy; 
+    } 
+ 
+    /** 
+     * 
+     */ 
+    public void readFromDatabase(String catalog, String schema, Mapping mapping) { 
+ 
+        this.connectionProvider = settings.getConnectionProvider(); 
+ 
+        try { 
+ 
+            Map oneToManyCandidates = readDatabaseSchema(catalog, schema); 
+ 
+            createPersistentClasses(oneToManyCandidates, mapping); //move this to a different step! 
+        } 
+        catch (SQLException e) { 
+            throw settings.getSQLExceptionConverter().convert(e, "Reading from database", null); 
+        } 
+        finally { 
+            if (connectionProvider != null) connectionProvider.close(); 
+        } 
+ 
+    } 
+ 
+    /** 
+     * Read JDBC Metadata from the database. Does not create any classes or other ORM releated structures. 
+     * 
+     * @param catalog 
+     * @param schema 
+     * @return 
+     * @throws SQLException 
+     * @deprecated should use readDatabaseSchema(DatabaseCollector, catalog, schema) 
+     */ 
+    public Map readDatabaseSchema(String catalog, String schema) throws SQLException { 
+        // use default from settings if nothing else specified. 
+        catalog = catalog != null ? catalog : settings.getDefaultCatalogName(); 
+        schema = schema != null ? schema : settings.getDefaultSchemaName(); 
+ 
+        JDBCReader reader = JDBCReaderFactory.newJDBCReader(cfg.getProperties(), settings, revengStrategy); 
+        DatabaseCollector dbs = new MappingsDatabaseCollector(mappings); 
+        reader.readDatabaseSchema(dbs, catalog, schema); 
+        return dbs.getOneToManyCandidates(); 
+    } 
+ 
+ 
+    /** 
+     * @param manyToOneCandidates 
+     * @param mappings2 
+     */ 
+    private void createPersistentClasses(Map manyToOneCandidates, Mapping mapping) { 
+ 
+        for (Iterator iter = mappings.iterateTables(); iter.hasNext();) { 
+            Table table = (Table) iter.next(); 
+            if (table.getColumnSpan() == 0) { 
+                log.warn("Cannot create persistent class for " + table + " as no columns were found."); 
+                continue; 
+            } 
+            // TODO: this naively just create an entity per table 
+            // should have an opt-out option to mark some as helper tables, subclasses etc. 
+            /*if(table.getPrimaryKey()==null || table.getPrimaryKey().getColumnSpan()==0) { 
+                log.warn("Cannot create persistent class for " + table + " as no primary key was found."); 
+                continue; 
+                // TODO: just create one big embedded composite id instead. 
+            }*/ 
+ 
+            if (revengStrategy.isManyToManyTable(table)) { 
+                log.debug("Ignoring " + table + " as class since rev.eng. says it is a many-to-many"); 
+                continue; 
+            } 
+ 
+            RootClass rc = new RootClass(); 
+            TableIdentifier tableIdentifier = TableIdentifier.create(table); 
+            String className = revengStrategy.tableToClassName(tableIdentifier); 
+            rc.setEntityName(className); 
+            rc.setClassName(className); 
+            rc.setProxyInterfaceName(rc.getEntityName()); // TODO: configurable ? 
+            rc.setLazy(true); 
+ 
+            rc.setMetaAttributes(safeMeta(revengStrategy.tableToMetaAttributes(tableIdentifier))); 
+ 
+ 
+            rc.setDiscriminatorValue(rc.getEntityName()); 
+            rc.setTable(table); 
+            try { 
+                mappings.addClass(rc); 
+            } catch (DuplicateMappingException dme) { 
+                // TODO: detect this and generate a "permutation" of it ? 
+                PersistentClass class1 = mappings.getClass(dme.getName()); 
+                Table table2 = class1.getTable(); 
+                throw new JDBCBinderException("Duplicate class name '" + rc.getEntityName() + "' generated for '" + table + "'. Same name where generated for '" + table2 + "'"); 
+            } 
+            mappings.addImport(rc.getEntityName(), rc.getEntityName()); 
+ 
+            Set processed = new HashSet(); 
+ 
+            bindPrimaryKeyToProperties(table, rc, processed, mapping); 
+            bindColumnsToVersioning(table, rc, processed, mapping); 
+            bindOutgoingForeignKeys(table, rc, processed); 
+            bindColumnsToProperties(table, rc, processed, mapping); 
+            List incomingForeignKeys = (List) manyToOneCandidates.get(rc.getEntityName()); 
+            bindIncomingForeignKeys(rc, processed, incomingForeignKeys, mapping); 
+        } 
+ 
+    } 
+ 
+    private Map safeMeta(Map map) { 
+        if (map == null) { 
+            return new HashMap(); 
+        } else { 
+            return map; 
+        } 
+    } 
+ 
+    // bind collections. 
+    private void bindIncomingForeignKeys(PersistentClass rc, Set processed, List foreignKeys, Mapping mapping) { 
+        if (foreignKeys != null) { 
+            for (Iterator iter = foreignKeys.iterator(); iter.hasNext();) { 
+                ForeignKey foreignKey = (ForeignKey) iter.next(); 
+ 
+                if (revengStrategy.excludeForeignKeyAsCollection( 
+                        foreignKey.getName(), 
+                        TableIdentifier.create(foreignKey.getTable()), 
+                        foreignKey.getColumns(), 
+                        TableIdentifier.create(foreignKey.getReferencedTable()), 
+                        foreignKey.getReferencedColumns())) { 
+                    log.debug("Rev.eng excluded one-to-many for foreignkey " + foreignKey.getName()); 
+                } else { 
+ 
+                    Property property = bindOneToMany(rc, foreignKey, processed, mapping); 
+                    rc.addProperty(property); 
+                } 
+            } 
+        } 
+    } 
+ 
+    /** 
+     * @param table 
+     * @param fk 
+     * @param columnsToBind 
+     * @param processedColumns 
+     * @param rc 
+     * @param propName 
+     */ 
+    private Property bindManyToOne(String propertyName, Table table, ForeignKey fk, Set processedColumns) { 
+        ManyToOne value = new ManyToOne(table); 
+        value.setReferencedEntityName(fk.getReferencedEntityName()); 
+        Iterator columns = fk.getColumnIterator(); 
+        while (columns.hasNext()) { 
+            Column fkcolumn = (Column) columns.next(); 
+            checkColumn(fkcolumn); 
+            value.addColumn(fkcolumn); 
+            processedColumns.add(fkcolumn); 
+        } 
+        value.setFetchMode(FetchMode.SELECT); 
+        return makeProperty(TableIdentifier.create(table), propertyName, value, true, true, value.getFetchMode() != FetchMode.JOIN, null, null); 
+    } 
+ 
+    /** 
+     * @param rc 
+     * @param processed 
+     * @param table 
+     * @param object 
+     */ 
+    private Property bindOneToMany(PersistentClass rc, ForeignKey foreignKey, Set processed, Mapping mapping) { 
+ 
+        Table collectionTable = foreignKey.getTable(); 
+ 
+        Collection collection = new org.hibernate.mapping.Set(rc); // MASTER TODO: allow overriding collection type 
+ 
+        collection.setCollectionTable(collectionTable); // CHILD+ 
+ 
+ 
+        boolean manyToMany = revengStrategy.isManyToManyTable(collectionTable); 
+        if (manyToMany) { 
+            log.debug("Rev.eng said here is a many-to-many"); 
+            // TODO: handle "the other side should influence the name" 
+        } 
+ 
+ 
+        if (manyToMany) { 
+ 
+            ManyToOne element = new ManyToOne(collection.getCollectionTable()); 
+            //TODO: find the other foreignkey and choose the other side. 
+            Iterator foreignKeyIterator = foreignKey.getTable().getForeignKeyIterator(); 
+            List keys = new ArrayList(); 
+            while (foreignKeyIterator.hasNext()) { 
+                Object next = foreignKeyIterator.next(); 
+                if (next != foreignKey) { 
+                    keys.add(next); 
+                } 
+            } 
+ 
+            if (keys.size() > 1) { 
+                throw new JDBCBinderException("more than one other foreign key to choose from!"); // todo: handle better ? 
+            } 
+ 
+            ForeignKey fk = (ForeignKey) keys.get(0); 
+ 
+            String tableToClassName = bindCollection(rc, foreignKey, fk, collection); 
+ 
+            element.setReferencedEntityName(tableToClassName); 
+            element.addColumn(fk.getColumn(0)); 
+            collection.setElement(element); 
+ 
+        } else { 
+            String tableToClassName = bindCollection(rc, foreignKey, null, collection); 
+ 
+            OneToMany oneToMany = new OneToMany(collection.getOwner()); 
+ 
+            oneToMany.setReferencedEntityName(tableToClassName); // Child 
+            mappings.addSecondPass(new JDBCCollectionSecondPass(mappings, collection)); 
+ 
+            collection.setElement(oneToMany); 
+        } 
+        // bind keyvalue 
+        KeyValue referencedKeyValue; 
+        String propRef = collection.getReferencedPropertyName(); 
+        if (propRef == null) { 
+            referencedKeyValue = collection.getOwner().getIdentifier(); 
+        } else { 
+            referencedKeyValue = (KeyValue) collection.getOwner() 
+                    .getProperty(propRef) 
+                    .getValue(); 
+        } 
+ 
+        SimpleValue keyValue = new DependantValue(collectionTable, referencedKeyValue); 
+        //key.setCascadeDeleteEnabled( "cascade".equals( subnode.attributeValue("on-delete") ) ); 
+        Iterator columnIterator = foreignKey.getColumnIterator(); 
+        while (columnIterator.hasNext()) { 
+            Column fkcolumn = (Column) columnIterator.next(); 
+            if (fkcolumn.getSqlTypeCode() != null) { // TODO: user defined foreign ref columns does not have a type set. 
+                guessAndAlignType(collectionTable, fkcolumn, mapping, false); // needed to ensure foreign key columns has same type as the "property" column. 
+            } 
+            keyValue.addColumn(fkcolumn); 
+        } 
+ 
+        collection.setKey(keyValue); 
+ 
+        mappings.addCollection(collection); 
+ 
+        return makeProperty(TableIdentifier.create(rc.getTable()), StringHelper.unqualify(collection.getRole()), collection, true, true, true, "all", null); // TODO: cascade isn't all by default 
+ 
+    } 
+ 
+    private String bindCollection(PersistentClass rc, ForeignKey fromForeignKey, ForeignKey toForeignKey, Collection collection) { 
+        ForeignKey targetKey = fromForeignKey; 
+        String collectionRole = null; 
+        boolean collectionLazy = false; 
+        boolean collectionInverse = false; 
+        TableIdentifier foreignKeyTable = null; 
+        String tableToClassName; 
+ 
+        if (toForeignKey != null) { 
+            targetKey = toForeignKey; 
+        } 
+ 
+        boolean uniqueReference = isUniqueReference(targetKey); // TODO: need to look one step further for many-to-many! 
+        foreignKeyTable = TableIdentifier.create(targetKey.getTable()); 
+        TableIdentifier foreignKeyReferencedTable = TableIdentifier.create(targetKey.getReferencedTable()); 
+ 
+        if (toForeignKey == null) { 
+ 
+            collectionRole = revengStrategy.foreignKeyToCollectionName( 
+                    fromForeignKey.getName(), 
+                    foreignKeyTable, 
+                    fromForeignKey.getColumns(), 
+                    foreignKeyReferencedTable, 
+                    fromForeignKey.getReferencedColumns(), 
+                    uniqueReference 
+            ); 
+ 
+            tableToClassName = revengStrategy.tableToClassName(foreignKeyTable); 
+        } else { 
+ 
+            collectionRole = revengStrategy.foreignKeyToManyToManyName( 
+                    fromForeignKey, TableIdentifier.create(fromForeignKey.getTable()), toForeignKey, uniqueReference); 
+ 
+            tableToClassName = revengStrategy.tableToClassName(foreignKeyReferencedTable); 
+        } 
+ 
+        collectionInverse = revengStrategy.isForeignKeyCollectionInverse(targetKey.getName(), 
+                foreignKeyTable, 
+                targetKey.getColumns(), 
+                foreignKeyReferencedTable, 
+                targetKey.getReferencedColumns()); 
+ 
+        collectionLazy = revengStrategy.isForeignKeyCollectionLazy(targetKey.getName(), 
+                foreignKeyTable, 
+                targetKey.getColumns(), 
+                foreignKeyReferencedTable, 
+                targetKey.getReferencedColumns()); 
+ 
+        collectionRole = makeUnique(rc, collectionRole); 
+ 
+        String fullRolePath = StringHelper.qualify(rc.getEntityName(), collectionRole); 
+        if (mappings.getCollection(fullRolePath) != null) { 
+            log.debug(fullRolePath + " found twice!"); 
+        } 
+ 
+        collection.setRole(fullRolePath);  // Master.setOfChildren+ 
+        collection.setInverse(collectionInverse); // TODO: allow overriding this 
+        collection.setLazy(collectionLazy); 
+        collection.setFetchMode(FetchMode.SELECT); 
+ 
+ 
+        return tableToClassName; 
+    } 
+ 
+    /** 
+     * return true if this foreignkey is the only reference from this table to the same foreign table 
+     */ 
+    private boolean isUniqueReference(ForeignKey foreignKey) { 
+ 
+        Iterator foreignKeyIterator = foreignKey.getTable().getForeignKeyIterator(); 
+        while (foreignKeyIterator.hasNext()) { 
+            ForeignKey element = (ForeignKey) foreignKeyIterator.next(); 
+            if (element != foreignKey && element.getReferencedTable().equals(foreignKey.getReferencedTable())) { 
+                return false; 
+            } 
+        } 
+        return true; 
+    } 
+ 
+    private void bindPrimaryKeyToProperties(Table table, RootClass rc, Set processed, Mapping mapping) { 
+        SimpleValue id = null; 
+        String idPropertyname = null; 
+ 
+        List keyColumns = null; 
+        if (table.getPrimaryKey() != null) { 
+            keyColumns = table.getPrimaryKey().getColumns(); 
+        } else { 
+            log.debug("No primary key found for " + table + ", using all properties as the identifier."); 
+            keyColumns = new ArrayList(); 
+            Iterator iter = table.getColumnIterator(); 
+            while (iter.hasNext()) { 
+                Column col = (Column) iter.next(); 
+                keyColumns.add(col); 
+            } 
+        } 
+ 
+        final TableIdentifier tableIdentifier = TableIdentifier.create(table); 
+ 
+        String tableIdentifierStrategyName = null; 
+ 
+        boolean naturalId; 
+ 
+        if (keyColumns.size() > 1) { 
+            tableIdentifierStrategyName = "assigned"; 
+            naturalId = true; 
+ 
+            id = handleCompositeKey(rc, processed, keyColumns, mapping); 
+            idPropertyname = revengStrategy.tableToIdentifierPropertyName(tableIdentifier); 
+            if (idPropertyname == null) { 
+                idPropertyname = "id"; 
+            } 
+        } else { 
+            tableIdentifierStrategyName = revengStrategy.getTableIdentifierStrategyName(tableIdentifier); 
+            naturalId = "assigned".equals(tableIdentifierStrategyName); 
+            Column pkc = (Column) keyColumns.get(0); 
+            checkColumn(pkc); 
+ 
+            id = bindColumnToSimpleValue(table, pkc, mapping, !naturalId); 
+ 
+            idPropertyname = revengStrategy.tableToIdentifierPropertyName(tableIdentifier); 
+            if (idPropertyname == null) { 
+                idPropertyname = revengStrategy.columnToPropertyName(tableIdentifier, pkc.getName()); 
+            } 
+ 
+            processed.add(pkc); 
+        } 
+        id.setIdentifierGeneratorStrategy(tableIdentifierStrategyName); 
+        id.setIdentifierGeneratorProperties(revengStrategy.getTableIdentifierProperties(tableIdentifier)); 
+        if (naturalId) { 
+            id.setNullValue("undefined"); 
+        } 
+ 
+ 
+        Property property = makeProperty(tableIdentifier, makeUnique(rc, idPropertyname), id, true, true, false, null, null); 
+        rc.setIdentifierProperty(property); 
+        rc.setIdentifier(id); 
+ 
+    } 
+ 
+    /** 
+     * bind many-to-ones 
+     * 
+     * @param table 
+     * @param rc 
+     * @param primaryKey 
+     */ 
+    private void bindOutgoingForeignKeys(Table table, RootClass rc, Set processedColumns) { 
+ 
+        // Iterate the outgoing foreign keys and create many-to-one's 
+        for (Iterator iterator = table.getForeignKeyIterator(); iterator.hasNext();) { 
+            ForeignKey foreignKey = (ForeignKey) iterator.next(); 
+ 
+            boolean mutable = true; 
+            if (contains(foreignKey.getColumnIterator(), processedColumns)) { 
+                if (!cfg.preferBasicCompositeIds()) continue; //it's in the pk, so skip this one 
+                mutable = false; 
+            } 
+ 
+            if (revengStrategy.excludeForeignKeyAsManytoOne(foreignKey.getName(), 
+                    TableIdentifier.create(foreignKey.getTable()), 
+                    foreignKey.getColumns(), 
+                    TableIdentifier.create(foreignKey.getReferencedTable()), 
+                    foreignKey.getReferencedColumns())) { 
+                // TODO: if many-to-one is excluded should the column be marked as processed so it won't show up at all ? 
+                log.debug("Rev.eng excluded many-to-one for foreignkey " + foreignKey.getName()); 
+            } else { 
+                boolean isUnique = isUniqueReference(foreignKey); 
+                String propertyName = revengStrategy.foreignKeyToEntityName( 
+                        foreignKey.getName(), 
+                        TableIdentifier.create(foreignKey.getTable()), 
+                        foreignKey.getColumns(), 
+                        TableIdentifier.create(foreignKey.getReferencedTable()), 
+                        foreignKey.getReferencedColumns(), 
+                        isUnique 
+                ); 
+ 
+                Property property = bindManyToOne( 
+                        makeUnique(rc, propertyName), 
+                        table, 
+                        foreignKey, 
+                        processedColumns 
+                ); 
+                property.setUpdateable(mutable); 
+                property.setInsertable(mutable); 
+ 
+                rc.addProperty(property); 
+            } 
+        } 
+    } 
+ 
+    /** 
+     * @param table 
+     * @param rc 
+     * @param primaryKey 
+     */ 
+    private void bindColumnsToProperties(Table table, RootClass rc, Set processedColumns, Mapping mapping) { 
+ 
+        for (Iterator iterator = table.getColumnIterator(); iterator.hasNext();) { 
+            Column column = (Column) iterator.next(); 
+            if (!processedColumns.contains(column)) { 
+                checkColumn(column); 
+ 
+                String propertyName = revengStrategy.columnToPropertyName(TableIdentifier.create(table), column.getName()); 
+ 
+                Property property = bindBasicProperty( 
+                        makeUnique(rc, propertyName), 
+                        table, 
+                        column, 
+                        processedColumns, 
+                        mapping 
+                ); 
+ 
+                rc.addProperty(property); 
+            } 
+        } 
+    } 
+ 
+    private void bindColumnsToVersioning(Table table, RootClass rc, Set processed, Mapping mapping) { 
+        TableIdentifier identifier = TableIdentifier.create(table); 
+ 
+        String optimisticLockColumnName = revengStrategy.getOptimisticLockColumnName(identifier); 
+ 
+        if (optimisticLockColumnName != null) { 
+            Column column = table.getColumn(new Column(optimisticLockColumnName)); 
+            if (column == null) { 
+                log.warn("Column " + column + " wanted for <version>/<timestamp> not found in " + identifier); 
+            } else { 
+                bindVersionProperty(table, identifier, column, rc, processed, mapping); 
+            } 
+        } else { 
+            log.debug("Scanning " + identifier + " for <version>/<timestamp> columns."); 
+            Iterator columnIterator = table.getColumnIterator(); 
+            while (columnIterator.hasNext()) { 
+                Column column = (Column) columnIterator.next(); 
+                boolean useIt = revengStrategy.useColumnForOptimisticLock(identifier, column.getName()); 
+                if (useIt && !processed.contains(column)) { 
+                    bindVersionProperty(table, identifier, column, rc, processed, mapping); 
+                    return; 
+                } 
+            } 
+            log.debug("No columns reported while scanning for <version>/<timestamp> columns in " + identifier); 
+        } 
+    } 
+ 
+    private void bindVersionProperty(Table table, TableIdentifier identifier, Column column, RootClass rc, Set processed, Mapping mapping) { 
+ 
+        processed.add(column); 
+        String propertyName = revengStrategy.columnToPropertyName(identifier, column.getName()); 
+        Property property = bindBasicProperty(makeUnique(rc, propertyName), table, column, processed, mapping); 
+        rc.addProperty(property); 
+        rc.setVersion(property); 
+        rc.setOptimisticLockMode(Versioning.OPTIMISTIC_LOCK_VERSION); 
+        log.debug("Column " + column.getName() + " will be used for <version>/<timestamp> columns in " + identifier); 
+ 
+    } 
+ 
+    private Property bindBasicProperty(String propertyName, Table table, Column column, Set processedColumns, Mapping mapping) { 
+ 
+        SimpleValue value = bindColumnToSimpleValue(table, column, mapping, false); 
+ 
+        return makeProperty(TableIdentifier.create(table), propertyName, value, true, true, false, null, null); 
+    } 
+ 
+    private SimpleValue bindColumnToSimpleValue(Table table, Column column, Mapping mapping, boolean generatedIdentifier) { 
+        SimpleValue value = new SimpleValue(table); 
+        value.addColumn(column); 
+        value.setTypeName(guessAndAlignType(table, column, mapping, generatedIdentifier)); 
+        return value; 
+    } 
+ 
+    /** 
+     * @param columnIterator 
+     * @param processedColumns 
+     * @return 
+     */ 
+    private boolean contains(Iterator columnIterator, Set processedColumns) { 
+        while (columnIterator.hasNext()) { 
+            Column element = (Column) columnIterator.next(); 
+            if (processedColumns.contains(element)) { 
+                return true; 
+            } 
+        } 
+        return false; 
+    } 
+ 
+    private void checkColumn(Column column) { 
+        if (column.getValue() != null) { 
+            //throw new JDBCBinderException("Binding column twice should not happen. " + column); 
+        } 
+    } 
+ 
+    /** 
+     * @param column 
+     * @param generatedIdentifier 
+     * @return 
+     */ 
+    private String guessAndAlignType(Table table, Column column, Mapping mapping, boolean generatedIdentifier) { 
+        // TODO: this method mutates the column if the types does not match...not good. 
+        // maybe we should copy the column instead before calling this method. 
+        Integer sqlTypeCode = column.getSqlTypeCode(); 
+        String location = "Table: " + Table.qualify(table.getCatalog(), table.getSchema(), table.getQuotedName()) + " column: " + column.getQuotedName(); 
+        if (sqlTypeCode == null) { 
+            throw new JDBCBinderException("sqltype is null for " + location); 
+        } 
+ 
+        String preferredHibernateType = revengStrategy.columnToHibernateTypeName( 
+                TableIdentifier.create(table), 
+                column.getName(), 
+                sqlTypeCode.intValue(), 
+                column.getLength(), column.getPrecision(), column.getScale(), column.isNullable(), generatedIdentifier 
+        ); 
+ 
+        Type wantedType = TypeFactory.heuristicType(preferredHibernateType); 
+ 
+        if (wantedType != null) { 
+            int[] wantedSqlTypes = wantedType.sqlTypes(mapping); 
+ 
+            if (wantedSqlTypes.length > 1) { 
+                throw new JDBCBinderException("The type " + preferredHibernateType + " found on " + location + " spans multiple columns. Only single column types allowed."); 
+            } 
+ 
+            int wantedSqlType = wantedSqlTypes[0]; 
+            if (wantedSqlType != sqlTypeCode.intValue()) { 
+                log.debug("Sql type mismatch for " + location + " between DB and wanted hibernate type. Sql type set to " + typeCodeName(sqlTypeCode.intValue()) + " instead of " + typeCodeName(wantedSqlType)); 
+                column.setSqlTypeCode(new Integer(wantedSqlType)); 
+            } 
+        } else { 
+            log.debug("No Hibernate type found for " + preferredHibernateType + ". Most likely cause is a missing UserType class."); 
+        } 
+ 
+ 
+        if (preferredHibernateType == null) { 
+            throw new JDBCBinderException("Could not find javatype for " + typeCodeName(sqlTypeCode.intValue())); 
+        } 
+ 
+        return preferredHibernateType; 
+    } 
+ 
+    private String typeCodeName(int sqlTypeCode) { 
+        return sqlTypeCode + "(" + JDBCToHibernateTypeHelper.getJDBCTypeName(sqlTypeCode) + ")"; 
+    } 
+ 
+    /** 
+     * Basically create an [classname]Id.class and add  properties for it. 
+     * 
+     * @param rc 
+     * @param compositeKeyColumns 
+     * @param processed 
+     * @return 
+     */ 
+    private SimpleValue handleCompositeKey(RootClass rc, Set processedColumns, List keyColumns, Mapping mapping) { 
+        Component pkc = new Component(rc); 
+        pkc.setMetaAttributes(Collections.EMPTY_MAP); 
+        pkc.setEmbedded(false); 
+ 
+        String compositeIdName = revengStrategy.tableToCompositeIdName(TableIdentifier.create(rc.getTable())); 
+        if (compositeIdName == null) { 
+            compositeIdName = revengStrategy.classNameToCompositeIdName(rc.getClassName()); 
+        } 
+        pkc.setComponentClassName(compositeIdName); 
+        Table table = rc.getTable(); 
+        List list = null; 
+        if (cfg.preferBasicCompositeIds()) { 
+            list = new ArrayList(keyColumns); 
+        } else { 
+            list = findForeignKeys(table.getForeignKeyIterator(), keyColumns); 
+        } 
+        for (Iterator iter = list.iterator(); iter.hasNext();) { 
+            Object element = iter.next(); 
+            Property property; 
+            if (element instanceof Column) { 
+                Column column = (Column) element; 
+                if (processedColumns.contains(column)) { 
+                    throw new JDBCBinderException("Binding column twice for primary key should not happen: " + column); 
+                } else { 
+                    checkColumn(column); 
+ 
+                    String propertyName = revengStrategy.columnToPropertyName(TableIdentifier.create(table), column.getName()); 
+                    property = bindBasicProperty(makeUnique(pkc, propertyName), table, column, processedColumns, mapping); 
+ 
+                    processedColumns.add(column); 
+                } 
+            } else if (element instanceof ForeignKeyForColumns) { 
+                ForeignKeyForColumns fkfc = (ForeignKeyForColumns) element; 
+                ForeignKey foreignKey = fkfc.key; 
+                String propertyName = revengStrategy.foreignKeyToEntityName( 
+                        foreignKey.getName(), 
+                        TableIdentifier.create(foreignKey.getTable()), 
+                        foreignKey.getColumns(), TableIdentifier.create(foreignKey.getReferencedTable()), foreignKey.getReferencedColumns(), true 
+                ); 
+                property = bindManyToOne(makeUnique(pkc, propertyName), table, foreignKey, processedColumns); 
+                processedColumns.addAll(fkfc.columns); 
+            } else { 
+                throw new JDBCBinderException("unknown thing"); 
+            } 
+ 
+            markAsUseInEquals(property); 
+            pkc.addProperty(property); 
+ 
+        } 
+ 
+        return pkc; 
+    } 
+ 
+    /** 
+     * @param property 
+     */ 
+    private void markAsUseInEquals(Property property) { 
+        Map m = new HashMap(); 
+        MetaAttribute ma = new MetaAttribute("use-in-equals"); 
+        ma.addValue("true"); 
+        m.put(ma.getName(), ma); 
+        property.setMetaAttributes(m); 
+    } 
+ 
+    /** 
+     * @param foreignKeyIterator 
+     * @param columns 
+     * @return 
+     */ 
+    private List findForeignKeys(Iterator foreignKeyIterator, List pkColumns) { 
+ 
+        List tempList = new ArrayList(); 
+        while (foreignKeyIterator.hasNext()) { 
+            tempList.add(foreignKeyIterator.next()); 
+        } 
+ 
+//     Collections.reverse(tempList); 
+ 
+        List result = new ArrayList(); 
+        Column myPkColumns[] = (Column[]) pkColumns.toArray(new Column[pkColumns.size()]); 
+ 
+        for (int i = 0; i < myPkColumns.length; i++) { 
+ 
+            boolean foundKey = false; 
+            foreignKeyIterator = tempList.iterator(); 
+            while (foreignKeyIterator.hasNext()) { 
+                ForeignKey key = (ForeignKey) foreignKeyIterator.next(); 
+                List matchingColumns = columnMatches(myPkColumns, i, key); 
+                if (matchingColumns != null) { 
+                    result.add(new ForeignKeyForColumns(key, matchingColumns)); 
+                    i += matchingColumns.size() - 1; 
+                    foreignKeyIterator.remove(); 
+                    foundKey = true; 
+                    break; 
+                } 
+            } 
+            if (!foundKey) { 
+                result.add(myPkColumns[i]); 
+            } 
+ 
+        } 
+ 
+        return result; 
+    } 
+ 
+    private List columnMatches(Column[] myPkColumns, int offset, ForeignKey key) { 
+ 
+        if (key.getColumnSpan() > (myPkColumns.length - offset)) { 
+            return null; // not enough columns in the key 
+        } 
+ 
+        List columns = new ArrayList(); 
+        for (int j = 0; j < key.getColumnSpan(); j++) { 
+            Column column = myPkColumns[j + offset]; 
+            if (!column.equals(key.getColumn(j))) { 
+                return null; 
+            } else { 
+                columns.add(column); 
+            } 
+        } 
+        return columns.isEmpty() ? null : columns; 
+    } 
+ 
+    static class ForeignKeyForColumns { 
+ 
+        protected final List columns; 
+        protected final ForeignKey key; 
+ 
+        public ForeignKeyForColumns(ForeignKey key, List columns) { 
+            this.key = key; 
+            this.columns = columns; 
+        } 
+    } 
+ 
+    private Property makeProperty(TableIdentifier table, String propertyName, Value value, boolean insertable, boolean updatable, boolean lazy, String cascade, String propertyAccessorName) { 
+        log.debug("Building property " + propertyName); 
+        Property prop = new Property(); 
+        prop.setName(propertyName); 
+        prop.setValue(value); 
+        prop.setInsertable(insertable); 
+        prop.setUpdateable(updatable); 
+        prop.setLazy(lazy); 
+        prop.setCascade(cascade == null ? "none" : cascade); 
+        prop.setPropertyAccessorName(propertyAccessorName == null ? "property" : propertyAccessorName); 
+        bindMeta(prop, table); 
+ 
+        return prop; 
+    } 
+ 
+    private boolean isForeignKey(Column col) { 
+        Table table = col.getValue().getTable(); 
+        Iterator fkIt = table.getForeignKeyIterator(); 
+        while (fkIt.hasNext()) { 
+            ForeignKey fk = (ForeignKey) fkIt.next(); 
+            if (fk.getColumns().indexOf(col) >= 0) { 
+                log.debug("found column " + col.getName() + " as FK"); 
+                return true; 
+            } 
+        } 
+        return false; 
+    } 
+ 
+    private Property bindMeta(Property property, TableIdentifier identifier) { 
+        Iterator columnIterator = property.getValue().getColumnIterator(); 
+        while (columnIterator.hasNext()) { 
+            Column col = (Column) columnIterator.next(); 
+ 
+            Map map = safeMeta(revengStrategy.columnToMetaAttributes(identifier, col.getName())); 
+            String preferredHibernateType = (String) col.getValue().accept(new JavaTypeFromValueVisitor()); 
+            if (preferredHibernateType == null) { 
+                preferredHibernateType = "Object"; 
+            } 
+            if (revengStrategy.useDefaultValueOnHibernateType(preferredHibernateType)) { 
+                if ((!map.containsKey("default-value")) 
+                        && (col.getDefaultValue() != null) 
+                        && (!"".equals(col.getDefaultValue()))) { 
+                    String defaultValue = revengStrategy.convertDefaultValueForColumn( 
+                            identifier, col.getName(), col.getSqlType(), 
+                            preferredHibernateType, isForeignKey(col), col.getDefaultValue()); 
+                    if (defaultValue != null) { 
+                        MetaAttribute ma = new MetaAttribute("default-value"); 
+                        ma.addValue(defaultValue); 
+                        map.put(ma.getName(), ma); 
+                    } 
+                } 
+            } 
+            if (!map.isEmpty()) { // TODO: merge from each column ? 
+                property.setMetaAttributes(map); 
+            } 
+        } 
+ 
+        return property; 
+    } 
+ 
+    /** 
+     * @param pkc 
+     * @param string 
+     * @return 
+     */ 
+    private String makeUnique(Component clazz, String propertyName) { 
+        return makeUnique(clazz.getPropertyIterator(), propertyName); 
+    } 
+ 
+    private String makeUnique(PersistentClass clazz, String propertyName) { 
+        List list = new ArrayList(); 
+ 
+        if (clazz.hasIdentifierProperty()) { 
+            list.add(clazz.getIdentifierProperty()); 
+        } 
+ 
+        if (clazz.isVersioned()) { 
+            list.add(clazz.getVersion()); 
+        } 
+ 
+        JoinedIterator iterator = new JoinedIterator(list.iterator(), clazz.getPropertyClosureIterator()); 
+        return makeUnique(iterator, propertyName); 
+    } 
+ 
+    /** 
+     * @param clazz 
+     * @param propertyName 
+     * @return 
+     */ 
+    private static String makeUnique(Iterator props, String originalPropertyName) { 
+        int cnt = 0; 
+        String propertyName = originalPropertyName; 
+        Set uniqueNames = new HashSet(); 
+ 
+        while (props.hasNext()) { 
+            Property element = (Property) props.next(); 
+            uniqueNames.add(element.getName()); 
+        } 
+ 
+        while (uniqueNames.contains(propertyName)) { 
+            cnt++; 
+            propertyName = originalPropertyName + "_" + cnt; 
+        } 
+ 
+        return propertyName; 
+    } 
+ 
+    public static void bindCollectionSecondPass( 
+            Collection collection, 
+            java.util.Map persistentClasses, 
+            Mappings mappings, 
+            java.util.Map inheritedMetas) throws MappingException { 
+ 
+        if (collection.isOneToMany()) { 
+            OneToMany oneToMany = (OneToMany) collection.getElement(); 
+            PersistentClass persistentClass = mappings.getClass(oneToMany.getReferencedEntityName()); 
+ 
+            if (persistentClass == null) throw new MappingException( 
+                    "Association " + collection.getRole() + " references unmapped class: " + oneToMany.getReferencedEntityName() 
+            ); 
+ 
+            oneToMany.setAssociatedClass(persistentClass); // Child 
+        } 
+ 
+    } 
+ 
+    static class JDBCCollectionSecondPass extends CollectionSecondPass { 
+ 
+        /** 
+         * @param mappings 
+         * @param coll 
+         */ 
+        JDBCCollectionSecondPass(Mappings mappings, Collection coll) { 
+            super(mappings, coll); 
+        } 
+ 
+        /* (non-Javadoc) 
+         * @see org.hibernate.cfg.HbmBinder.SecondPass#secondPass(java.util.Map, java.util.Map) 
+         */ 
+        public void secondPass(Map persistentClasses, Map inheritedMetas) throws MappingException { 
+            JDBCBinder.bindCollectionSecondPass(collection, persistentClasses, mappings, inheritedMetas); 
+        } 
+    } 
+ 
+} 
Index: /media/hdb5/home/sorin/Projects/hibernate-tools/trunk/src/main/java/org/hibernate/cfg/reveng/JDBCReader.java
===================================================================
--- /media/hdb5/home/sorin/Projects/hibernate-tools/trunk/src/main/java/org/hibernate/cfg/reveng/JDBCReader.java        (revision 341)
+++ /media/hdb5/home/sorin/Projects/hibernate-tools/trunk/src/main/java/org/hibernate/cfg/reveng/JDBCReader.java        (revision 328)
@@ -1,891 +1,876 @@
-package org.hibernate.cfg.reveng;
-
-import java.sql.Connection;
-import java.sql.DatabaseMetaData;
-import java.sql.ResultSet;
-import java.sql.SQLException;
-import java.sql.Statement;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.hibernate.JDBCException;
-import org.hibernate.MappingException;
-import org.hibernate.cfg.JDBCBinderException;
-import org.hibernate.cfg.reveng.dialect.MetaDataDialect;
-import org.hibernate.connection.ConnectionProvider;
-import org.hibernate.dialect.Dialect;
-import org.hibernate.exception.SQLExceptionConverter;
-import org.hibernate.mapping.Column;
-import org.hibernate.mapping.ForeignKey;
-import org.hibernate.mapping.Index;
-import org.hibernate.mapping.PrimaryKey;
-import org.hibernate.mapping.Table;
-import org.hibernate.mapping.UniqueKey;
-import org.hibernate.sql.Alias;
-
-public class JDBCReader {
-
-       private static final Log log = LogFactory.getLog(JDBCReader.class);
-       
-       private final ReverseEngineeringStrategy revengStrategy;
-       
-       private MetaDataDialect metadataDialect;
-
-       private final ConnectionProvider provider;
-
-       private final SQLExceptionConverter sec;
-
-       private final String defaultSchema;
-       private final String defaultCatalog;
-       
-       public JDBCReader(MetaDataDialect dialect, ConnectionProvider provider, SQLExceptionConverter sec, String defaultCatalog, String defaultSchema, ReverseEngineeringStrategy reveng) {
-              this.metadataDialect = dialect;
-              this.provider = provider;
-              this.sec = sec;
-              this.revengStrategy = reveng;
-              this.defaultCatalog = defaultCatalog;
-              this.defaultSchema = defaultSchema;
-              if(revengStrategy==null) {
-                     throw new IllegalStateException("Strategy cannot be null");
-              }
-       }
-              
-       public List readDatabaseSchema(DatabaseCollector dbs, String catalog, String schema, ProgressListener progress) {
-              try {
-                     getMetaDataDialect().configure(provider, sec);
-                     revengStrategy.configure(provider, sec);
-                     
-                     Set hasIndices = new HashSet();
-                     
-                     List schemaSelectors = revengStrategy.getSchemaSelections();
-                     List foundTables = new ArrayList();
-                     if(schemaSelectors==null) {
-                            foundTables.addAll( processTables(dbs, new SchemaSelection(catalog, schema), hasIndices, progress) );
-                     } else {
-                            for (Iterator iter = schemaSelectors.iterator(); iter.hasNext();) {
-                                   SchemaSelection selection = (SchemaSelection) iter.next();
-                                   foundTables.addAll( processTables(dbs, selection, hasIndices, progress) );
-                            }
-                     }
-                     
-                     Iterator tables = foundTables.iterator(); // not dbs.iterateTables() to avoid "double-read" of columns etc.
-                     while ( tables.hasNext() ) {
-                            Table table = (Table) tables.next();
-                            processBasicColumns(table, progress);
-                            processPrimaryKey(table);
-                            if(hasIndices.contains(table)) {
-                                   processIndices(table);
-                            }
-                     }
-                     
-                     tables = foundTables.iterator(); //dbs.iterateTables();
-                     Map oneToManyCandidates = resolveForeignKeys( dbs, tables, progress );
-                     
-                     dbs.setOneToManyCandidates(oneToManyCandidates);
-                     
-                     return foundTables;
-              } finally {
-                     getMetaDataDialect().close();
-                     revengStrategy.close();
-              }
-       }
-
-       /**
-        * Iterates the tables and find all the foreignkeys that refers to something that is available inside the DatabaseCollector.
-        * @param dbs
-        * @param progress
-        * @param tables
-        * @return
-        */
-       private Map resolveForeignKeys(DatabaseCollector dbs, Iterator tables, ProgressListener progress) {
-              List fks = new ArrayList();
-              while ( tables.hasNext() ) {
-                     Table table = (Table) tables.next();
-                     // Done here after the basic process of collections as we might not have touched 
-                     // all referenced tables (this ensure the columns are the same instances througout the basic JDBC derived model.
-                     // after this stage it should be "ok" to divert from keeping columns in sync as it can be required if the same 
-                     //column is used with different aliases in the ORM mapping.
-                     ForeignKeysInfo foreignKeys = processForeignKeys(dbs, table, progress);
-                     fks.add( foreignKeys );                                       
-              }
-              
-              Map oneToManyCandidates = new HashMap();                     
-              for (Iterator iter = fks.iterator(); iter.hasNext();) {
-                     ForeignKeysInfo element = (ForeignKeysInfo) iter.next();
-                     Map map = element.process( revengStrategy ); // the actual foreignkey is created here.
-                     mergeMultiMap( oneToManyCandidates, map );
-              }
-              return oneToManyCandidates;
-       }
-       
-       static class ForeignKeysInfo {
-              
-              final Map dependentTables;
-              final Map dependentColumns;
-              final Map referencedColumns;
-              private final Table referencedTable;
-              
-              public ForeignKeysInfo(Table referencedTable, Map tables, Map columns, Map refColumns) {
-                     this.referencedTable = referencedTable;
-                     this.dependentTables = tables;
-                     this.dependentColumns = columns;
-                     this.referencedColumns = refColumns;
-              }
-              
-              Map process(ReverseEngineeringStrategy revengStrategy) {
-                     Map oneToManyCandidates = new HashMap();
-               Iterator iterator = dependentTables.entrySet().iterator();
-                     while (iterator.hasNext() ) {
-                            Map.Entry entry = (Map.Entry) iterator.next();
-                            String fkName = (String) entry.getKey();
-                            Table fkTable = (Table) entry.getValue();                    
-                            List columns = (List) dependentColumns.get(fkName);
-                            List refColumns = (List) referencedColumns.get(fkName);
-                            
-                            String className = revengStrategy.tableToClassName(TableIdentifier.create(referencedTable) );
-
-                            ForeignKey key = fkTable.createForeignKey(fkName, columns, className, refColumns);                   
-                            key.setReferencedTable(referencedTable);
-
-                            addToMultiMap(oneToManyCandidates, className, key);                         
-                     }
-                     // map<className, foreignkey>
-                     return oneToManyCandidates;
-              }
-       }
-       
-       protected ForeignKeysInfo processForeignKeys(DatabaseCollector dbs, Table referencedTable, ProgressListener progress) throws JDBCBinderException {
-              // foreign key name to list of columns
-              Map dependentColumns = new HashMap();
-              // foreign key name to Table
-              Map dependentTables = new HashMap();
-              Map referencedColumns = new HashMap();
-              
-              short bogusFkName = 0;
-              
-              // first get all the relationships dictated by the database schema
-              
-              Iterator exportedKeyIterator = null;
-              
-        log.debug("Calling getExportedKeys on " + referencedTable);
-        progress.startSubTask("Finding exported foreignkeys on " + referencedTable.getName());
-        try {
-               Map exportedKeyRs = null;
-               exportedKeyIterator = getMetaDataDialect().getExportedKeys(getCatalogForDBLookup(referencedTable.getCatalog()), getSchemaForDBLookup(referencedTable.getSchema()), referencedTable.getName() );
-        try {
-                     while (exportedKeyIterator.hasNext() ) {
-                            exportedKeyRs = (Map) exportedKeyIterator.next();
-                            String fkCatalog = getCatalogForModel((String) exportedKeyRs.get("FKTABLE_CAT"));
-                            String fkSchema = getSchemaForModel((String) exportedKeyRs.get("FKTABLE_SCHEM"));
-                            String fkTableName = (String) exportedKeyRs.get("FKTABLE_NAME");
-                            String fkColumnName = (String) exportedKeyRs.get("FKCOLUMN_NAME");
-                            String pkColumnName = (String) exportedKeyRs.get("PKCOLUMN_NAME");
-                            String fkName = (String) exportedKeyRs.get("FK_NAME");
-                            short keySeq = ((Short)exportedKeyRs.get("KEY_SEQ")).shortValue();
-                                                        
-                            Table fkTable = dbs.getTable(fkSchema, fkCatalog, fkTableName);
-                            if(fkTable==null) {
-                                   //     filter out stuff we don't have tables for!
-                                   log.debug("Foreign key " + fkName + " references unknown or filtered table " + Table.qualify(fkCatalog, fkSchema, fkTableName) );
-                                   continue;
-                            } else {
-                                   log.debug("Foreign key " + fkName);
-                            }
-                            
-                            // TODO: if there is a relation to a column which is not a pk
-                            //       then handle it as a property-ref
-                            
-                            if (keySeq == 0) {
-                                   bogusFkName++;
-                            }
-                            
-                            if (fkName == null) {
-                                   // somehow reuse hibernates name generator ?
-                                   fkName = Short.toString(bogusFkName);
-                            }
-                            //Table fkTable = mappings.addTable(fkSchema, fkCatalog, fkTableName, null, false);
-                            
-                            
-                            List depColumns =  (List) dependentColumns.get(fkName);
-                            if (depColumns == null) {
-                                   depColumns = new ArrayList();
-                                   dependentColumns.put(fkName,depColumns);
-                                   dependentTables.put(fkName, fkTable);
-                            } 
-                            else {
-                                   Object previousTable = dependentTables.get(fkName);
-                                   if(fkTable != previousTable) {
-                                          throw new JDBCBinderException("Foreign key name (" + fkName + ") mapped to different tables! previous: " + previousTable + " current:" + fkTable);
-                                   }
-                            }
-                            
-                            Column column = new Column(fkColumnName);
-                            Column existingColumn = fkTable.getColumn(column);
-                            column = existingColumn==null ? column : existingColumn;
-                            
-                            depColumns.add(column);
-                     }
-              } 
-        finally {
-               try {
-                      if(exportedKeyIterator!=null) {
-                             getMetaDataDialect().close(exportedKeyIterator);
-                      }
-               } catch(JDBCException se) {
-                      log.warn("Exception while closing result set for foreign key meta data",se);
-               }
-        }
-        } catch(JDBCException se) {
-               //throw sec.convert(se, "Exception while reading foreign keys for " + referencedTable, null);
-               log.warn("Exception while reading foreign keys for " + referencedTable + " [" + se.toString() + "]", se);
-               // sybase (and possibly others has issues with exportedkeys) see HBX-411
-               // we continue after this to allow user provided keys to be added.
-        }
-        
-        List userForeignKeys = revengStrategy.getForeignKeys(TableIdentifier.create(referencedTable));
-        if(userForeignKeys!=null) {
-               Iterator iterator = userForeignKeys.iterator();
-               while ( iterator.hasNext() ) {
-                      ForeignKey element = (ForeignKey) iterator.next();
-                      
-                      if(!equalTable(referencedTable, element.getReferencedTable() ) ) {
-                             log.debug("Referenced table " + element.getReferencedTable().getName() + " is not " +  referencedTable + ". Ignoring userdefined foreign key " + element );
-                             continue; // skip non related foreign keys
-                      }
-                      
-                      String userfkName = element.getName();                
-                      Table userfkTable = element.getTable();
-                      
-                      List userColumns = element.getColumns();
-                      List userrefColumns = element.getReferencedColumns();
-                      
-                      Table deptable = (Table) dependentTables.get(userfkName);
-                      if(deptable!=null) { // foreign key already defined!?
-                             throw new MappingException("Foreign key " + userfkName + " already defined in the database!");
-                      }
-                      
-                      deptable = dbs.getTable(userfkTable.getSchema(), userfkTable.getCatalog(), userfkTable.getName() );
-                      if(deptable==null) {
-                                   //     filter out stuff we don't have tables for!
-                                   log.debug("User defined foreign key " + userfkName + " references unknown or filtered table " + TableIdentifier.create(userfkTable) );
-                                   continue;                            
-                      }
-                      
-                      dependentTables.put(userfkName, deptable);
-                      
-                      List depColumns = new ArrayList(userColumns.size() );
-                      Iterator colIterator = userColumns.iterator();
-                      while(colIterator.hasNext() ) {
-                             Column jdbcColumn = (Column) colIterator.next();
-                             Column column = new Column(jdbcColumn.getName() );
-                            Column existingColumn = deptable.getColumn(column);
-                            column = existingColumn==null ? column : existingColumn;
-                            depColumns.add(column);
-                      }
-                      
-                      List refColumns = new ArrayList(userrefColumns.size() );
-                      colIterator = userrefColumns.iterator();
-                      while(colIterator.hasNext() ) {
-                             Column jdbcColumn = (Column) colIterator.next();
-                             Column column = new Column(jdbcColumn.getName() );
-                            Column existingColumn = referencedTable.getColumn(column);
-                            column = existingColumn==null ? column : existingColumn;
-                            refColumns.add(column);
-                      }
-                      
-                      referencedColumns.put(userfkName, refColumns );
-                      dependentColumns.put(userfkName, depColumns );
-               }
-        }
-        
-        
-        return new ForeignKeysInfo(referencedTable, dependentTables, dependentColumns, referencedColumns);
-        
-       }
-
-       
-       /**
-        * @param catalog
-        * @param schema
-        * @param table
-        * @param primaryKeys
-        * @return
-        * @throws SQLException
-        */
-       private void processPrimaryKey(Table table) {
-              
-              List columns = new ArrayList();
-              PrimaryKey key = null;
-              Iterator primaryKeyIterator = null;
-              try {
-                     Map primaryKeyRs = null;       
-                     primaryKeyIterator = getMetaDataDialect().getPrimaryKeys(getCatalogForDBLookup(table.getCatalog()), getSchemaForDBLookup(table.getSchema()), table.getName() );               
-              
-                     while (primaryKeyIterator.hasNext() ) {
-                            primaryKeyRs = (Map) primaryKeyIterator.next();
-                            
-                            /*String ownCatalog = primaryKeyRs.getString("TABLE_CAT");
-                             String ownSchema = primaryKeyRs.getString("TABLE_SCHEM");
-                             String ownTable = primaryKeyRs.getString("TABLE_NAME");*/
-                            
-                            String columnName = (String) primaryKeyRs.get("COLUMN_NAME");
-                            short seq = ((Short)primaryKeyRs.get("KEY_SEQ")).shortValue();
-                            String name = (String) primaryKeyRs.get("PK_NAME");
-                            
-                            if(key==null) {
-                                   key = new PrimaryKey();
-                                   key.setName(name);
-                                   key.setTable(table);
-                                   if(table.getPrimaryKey()!=null) {
-                                          throw new JDBCBinderException(table + " already has a primary key!"); //TODO: ignore ?
-                                   }
-                                   table.setPrimaryKey(key);
-                            } 
-                            else {
-                                   if(!(name==key.getName() ) && name!=null && !name.equals(key.getName() ) ) {
-                                          throw new JDBCBinderException("Duplicate names found for primarykey. Existing name: " + key.getName() + " JDBC name: " + name + " on table " + table);
-                                   }                    
-                            }
-                            
-                            columns.add(new Object[] { new Short(seq), columnName});
-                     }
-              } finally {
-                     if (primaryKeyIterator!=null) {
-                            try {
-                                   getMetaDataDialect().close(primaryKeyIterator);
-                            } catch(JDBCException se) {
-                                   log.warn("Exception when closing resultset for reading primary key information",se);
-                            }
-                     }
-              }
-             
-             // sort the columns accoring to the key_seq.
-             Collections.sort(columns,new Comparator() {
-                     public boolean equals(Object obj) {
-                            return super.equals(obj);
-                     }
-
-                     public int compare(Object o1, Object o2) {
-                            Short left = (Short) ( (Object[]) o1)[0];
-                            Short right = (Short) ( (Object[]) o2)[0];
-                            return left.compareTo(right);
-                     }
-                     
-                     public int hashCode() {
-                            return super.hashCode();
-                     }
-             });
-             
-             List t = new ArrayList(columns.size());
-             Iterator cols = columns.iterator();
-             while (cols.hasNext() ) {
-                     Object[] element = (Object[]) cols.next();
-                     t.add(element[1]);
-             }
-             columns = t;
-                           
-             if(key==null) {
-              log.warn("The JDBC driver didn't report any primary key columns in " + table.getName() + ". Asking rev.eng. strategy" );
-              List userPrimaryKey = revengStrategy.getPrimaryKeyColumnNames(TableIdentifier.create(table));
-              if(userPrimaryKey!=null && !userPrimaryKey.isEmpty()) {
-                     key = new PrimaryKey();
-                     key.setName(new Alias(15, "PK").toAliasString( table.getName()));
-                     key.setTable(table);
-                     if(table.getPrimaryKey()!=null) {
-                            throw new JDBCBinderException(table + " already has a primary key!"); //TODO: ignore ?
-                     }
-                     table.setPrimaryKey(key);
-                     columns = new ArrayList(userPrimaryKey);
-              } else {
-                     log.warn("Rev.eng. strategy did not report any primary key columns for " + table.getName());
-              }             
-             }
-             
-             if(key!=null) {
-                cols = columns.iterator();
-                while (cols.hasNext() ) {
-                       String name = (String) cols.next();
-                       // should get column from table if it already exists!
-                       Column col = getColumn(table, name);
-                       key.addColumn(col);
-                }
-                log.debug("primary key for " + table + " -> "  + key);
-             } 
-            
-                   
-              
-             
-              
-       }
-
-       private boolean safeEquals(Object value, Object tf) {
-              if(value==tf) return true;
-              if(value==null) return false;
-              return value.equals(tf);
-       }
-
-       private Collection processTables(DatabaseCollector dbs, SchemaSelection schemaSelection, Set hasIndices, ProgressListener progress) {
-              Map tableRs = null;
-              Iterator tableIterator = null;
-              List tables = new ArrayList();
-              boolean multiSchema = false; // TODO: the code below detects if the reveng is multischema'ed, but not used for anything yet. should be used to remove schema/catalog info from output if only one schema/catalog used.
-              
-                try {                        
-                   progress.startSubTask("Finding tables in " + schemaSelection);
-                   
-                   tableIterator = getMetaDataDialect().getTables(schemaSelection.getMatchCatalog(), schemaSelection.getMatchSchema(), schemaSelection.getMatchTable());
-                   String[] lastQualifier = null;
-                   String[] foundQualifier = new String[2];
-                   
-                   while (tableIterator.hasNext() ) {
-                      tableRs = (Map) tableIterator.next();
-                      String tableName = (String) tableRs.get("TABLE_NAME");
-                            String schemaName = (String) tableRs.get("TABLE_SCHEM");
-                      String catalogName = (String) tableRs.get("TABLE_CAT");
-                      
-                      TableIdentifier ti = new TableIdentifier(catalogName, schemaName, tableName);                 
-                            if(revengStrategy.excludeTable(ti) ) {
-                                   log.debug("Table " + ti + " excluded by strategy");
-                             continue;
-                      }
-                            
-                            if(!multiSchema) {
-                                   foundQualifier[0] = catalogName;
-                                   foundQualifier[1] = schemaName;
-                                   if(lastQualifier==null) {
-                                          lastQualifier=new String[2];
-                                          lastQualifier[0] = foundQualifier[0];
-                                          lastQualifier[1] = foundQualifier[1];                              
-                                   }
-                                   if((!safeEquals(lastQualifier[0],foundQualifier[0])) || (!safeEquals(lastQualifier[1],foundQualifier[1]))) {
-                                          multiSchema = true;
-                                   }
-                            }
-                            
-                            tables.add(new HashMap(tableRs));
-                   }
-                } 
-                finally {
-                       try {
-                              if (tableIterator!=null) getMetaDataDialect().close(tableIterator);
-                       } 
-                       catch (Exception ignore) {
-                       }
-                }
-                
-                List processedTables = new ArrayList();
-                tableIterator = tables.iterator();
-                while (tableIterator.hasNext() ) {
-                       tableRs = (Map) tableIterator.next();
-                       String tableName = (String) tableRs.get("TABLE_NAME");
-                       String schemaName = (String) tableRs.get("TABLE_SCHEM");
-                       String catalogName = (String) tableRs.get("TABLE_CAT");
-                       
-                       /*TableIdentifier ti = new TableIdentifier(catalogName, schemaName, tableName);
-                        if(revengStrategy.excludeTable(ti) ) {
-                        log.debug("Table " + ti + " excluded by strategy");
-                        continue;
-                        }*/
-                       
-                       String comment = (String) tableRs.get("REMARKS");
-                       String tableType = (String) tableRs.get("TABLE_TYPE");
-                       
-                       if(dbs.getTable(schemaName, catalogName, tableName)!=null) {
-                              log.debug("Ignoring " + tableName + " since it has already been processed");
-                              continue;
-                       } else {
-                              if ( ("TABLE".equals(tableType) || "VIEW".equals(tableType) /*|| "SYNONYM".equals(tableType) */) ) { //||
-                                     // ("SYNONYM".equals(tableType) && isOracle() ) ) { // only on oracle ? TODO: HBX-218
-                                     // it's a regular table or a synonym
-                                     
-                                     // ensure schema and catalogname is truly empty (especially mysql returns null schema, "" catalog)
-                                     if(schemaName!=null && schemaName.trim().length()==0) {
-                                            schemaName = null;
-                                     }                     
-                                     if(catalogName!=null && catalogName.trim().length()==0) {
-                                            catalogName=null;
-                                     }
-                                     log.debug("Adding table " + tableName + " of type " + tableType);
-                                     progress.startSubTask("Found " + tableName);
-                                     Table table = dbs.addTable(quote(getSchemaForModel(schemaName)), getCatalogForModel(catalogName), quote(tableName));
-                                     table.setComment(comment);
-                                     if(tableType.equals("TABLE")) {
-                                            hasIndices.add(table);
-                                     }
-                                     processedTables.add( table );
-                              }
-                              else {
-                                     log.debug("Ignoring table " + tableName + " of type " + tableType);
-                              }
-                       }
-                }
-                
-                return processedTables;
-       }
-
-       private void processBasicColumns(Table table, ProgressListener progress) {
-              // get the columns
-              
-              String qualify = Table.qualify(table.getCatalog(), table.getSchema(), table.getName() );
-              Iterator columnIterator = null;
-              
-              try {
-                     Map columnRs = null;
-                     log.debug("Finding columns for " + qualify );
-                     progress.startSubTask("Finding columns for " + qualify);
-                     columnIterator = getMetaDataDialect().getColumns(getCatalogForDBLookup(table.getCatalog()), getSchemaForDBLookup(table.getSchema()), table.getName(), null);
-                     //dumpHeader(columnRs);
-                     while (columnIterator.hasNext() ) {
-                            //dumpRow(columnRs);
-                            columnRs = (Map) columnIterator.next();
-                            String tableName = (String) columnRs.get("TABLE_NAME");
-                            int sqlType = ((Integer)columnRs.get("DATA_TYPE")).intValue();
-                            String sqlTypeName = (String) columnRs.get("TYPE_NAME");
-                            String columnName = (String) columnRs.get("COLUMN_NAME");
-                            
-                     
-                            
-                            
-                            String comment = (String) columnRs.get("REMARKS");
-                            
-                            TableIdentifier ti = TableIdentifier.create(table);
-                            if(revengStrategy.excludeColumn(ti, columnName)) {
-                                   log.debug("Column " + ti + "." + columnName + " excluded by strategy");
-                                   continue;
-                            }
-                            if(!tableName.equals(table.getName())) {
-                                   log.debug("Table name " + tableName + " does not match requested " + table.getName() + ". Ignoring column " + columnName + " since it either is invalid or a duplicate" );
-                                   continue;
-                            }
-                            
-                            //String columnDefaultValue = columnRs.getString("COLUMN_DEF"); TODO: only read if have a way to avoid issues with clobs/lobs and similar
-                            int dbNullability = ((Integer)columnRs.get("NULLABLE")).intValue();
-                            boolean isNullable = true;
-                            switch (dbNullability) {
-                            case DatabaseMetaData.columnNullable:
-                            case DatabaseMetaData.columnNullableUnknown:
-                                   isNullable = true;
-                                   break;
-                            case DatabaseMetaData.columnNoNulls:
-                                   isNullable = false;
-                                   break;
-                            default:
-                                   isNullable = true;
-                            }
-                            
-                            int size = ((Integer)columnRs.get("COLUMN_SIZE")).intValue();
-                            int decimalDigits = ((Integer)columnRs.get("DECIMAL_DIGITS")).intValue();
-                            
-                            Column column = new Column();
-                            column.setName(quote(columnName));
-                            Column existing = table.getColumn(column);
-                            if(existing!=null) {
-                                   // TODO: should we just pick it up and fill it up with whatever we get from the db instead ?
-                                   throw new JDBCBinderException(column + " already exists in " + qualify);
-                            }
-                                                        
-                            //TODO: column.setSqlType(sqlTypeName); //this does not work 'cos the precision/scale/length are not retured in TYPE_NAME
-                            //column.setSqlType(sqlTypeName);
-                            column.setComment(comment);
-                            column.setSqlTypeCode(new Integer(sqlType) );
-                if(intBounds(size) ) {
-                       if(JDBCToHibernateTypeHelper.typeHasLength(sqlType) ) {
-                              column.setLength(size);
-                       } 
-                       if(JDBCToHibernateTypeHelper.typeHasScaleAndPrecision(sqlType) ) {
-                              column.setPrecision(size); 
-                       }
-                            } 
-                if(intBounds(decimalDigits) ) {
-                       if(JDBCToHibernateTypeHelper.typeHasScaleAndPrecision(sqlType) ) {
-                              column.setScale(decimalDigits);
-                       }
-                            }
-                            
-                            column.setNullable(isNullable);
-
-                            // columnDefaultValue is useless for Hibernate
-                            // isIndexed  (available via Indexes)
-                            // unique - detected when getting indexes
-                            // isPk - detected when finding primary keys                        
-                            
-                            table.addColumn(column);
-                     }
-              }
-              finally {
-                     
-                     if(columnIterator!=null) {
-                            try {
-                                   getMetaDataDialect().close(columnIterator);
-                            } catch(JDBCException se) {
-                                   log.warn("Exception while closing iterator for column meta data",se);
-                            }
-                     }
-              }
-                            
-       }
-
-
-          private String quote(String columnName) {
-                 if(columnName==null) return columnName;
-                 if(getMetaDataDialect().needQuote(columnName)) {
-                        if(columnName.length()>1 && columnName.charAt(0)=='`' && columnName.charAt(columnName.length()-1)=='`') {
-                               return columnName; // avoid double quoting
-                        }
-                        return "`" + columnName + "`";
-                 } else {
-                        return columnName;
-                 }          
-       }
-
-       private MetaDataDialect getMetaDataDialect() {
-              return metadataDialect;
-       }
-       
-         
-              /**
-            * @param size
-            * @return
-            */
-           private boolean intBounds(int size) {
-               return size>=0 && size!=Integer.MAX_VALUE;
-           }
-
-       
-           private void processIndices(Table table) {
-                     
-                     Map indexes = new HashMap(); // indexname (String) -> Index
-                     Map uniquekeys = new HashMap(); // name (String) -> UniqueKey
-                     Map uniqueColumns = new HashMap(); // Column -> List<Index>
-                     
-                     Iterator indexIterator = null;
-                     try {
-                            Map indexRs = null;    
-                            indexIterator = getMetaDataDialect().getIndexInfo(getCatalogForDBLookup(table.getCatalog()), getSchemaForDBLookup(table.getSchema()), table.getName());
-                            
-                            while (indexIterator.hasNext() ) {
-                                   indexRs = (Map) indexIterator.next();
-                                   String indexName = (String) indexRs.get("INDEX_NAME");
-                                   String columnName = (String) indexRs.get("COLUMN_NAME");
-                                   boolean unique = !((Boolean)indexRs.get("NON_UNIQUE")).booleanValue();
-                                   
-                                   if (columnName != null || indexName != null) { // both can be non-null with statistical indexs which we don't have any use for.
-                                          
-                                          if(unique) {
-                                                 UniqueKey key = (UniqueKey) uniquekeys.get(indexName);
-                                                 if (key==null) {
-                                                        key = new UniqueKey();
-                                                        key.setName(indexName);
-                                                        key.setTable(table);
-                                                        table.addUniqueKey(key);                                                 
-                                                        uniquekeys.put(indexName, key);
-                                                 }
-                                   
-                                                 if(indexes.containsKey(indexName) ) {
-                                                        throw new JDBCBinderException("UniqueKey exists also as Index! ");
-                                                 }
-                                                 Column column = getColumn(table, columnName);
-                                                 key.addColumn(column);
-                                                 
-                                                 if (unique && key.getColumnSpan()==1) {
-                                                        // make list of columns that has the chance of being unique
-                                                        List l = (List) uniqueColumns.get(column);
-                                                        if (l == null) {
-                                                               l = new ArrayList();
-                                                               uniqueColumns.put(column, l);
-                                                        }
-                                                        l.add(key);
-                                                 }
-                                          } 
-                                          else {
-                                                 Index index = (Index) indexes.get(indexName);
-                                                 if(index==null) {
-                                                        index = new Index();
-                                                        index.setName(indexName);
-                                                        index.setTable(table);
-                                                        table.addIndex(index);
-                                                        indexes.put(indexName, index);                             
-                                                 }
-                                                 
-                                                 if(uniquekeys.containsKey(indexName) ) {
-                                                        throw new JDBCBinderException("Index exists also as Unique! ");
-                                                 }
-                                                 Column column = getColumn(table, columnName);
-                                                 index.addColumn(column);
-                                          }
-                                          
-                                   } 
-                                   else {
-                                          if(DatabaseMetaData.tableIndexStatistic != ((Short)indexRs.get("TYPE")).shortValue() ) {
-                                                 log.warn("Index was not statistical, but no column name was found in " + indexName);
-                                          }
-                                                 
-                                   }                                                       
-                            }
-                     } 
-                     catch (JDBCException t) {
-                            log.warn("Exception while trying to get indexinfo on " + Table.qualify(table.getCatalog(), table.getSchema(), table.getName() ) +  "=" + t.getMessage() );
-                            // Bug #604761 Oracle getIndexInfo() needs major grants And other dbs sucks too ;)
-                            // http://sourceforge.net/tracker/index.php?func=detail&aid=604761&group_id=36044&atid=415990                       
-                     } 
-                     finally {
-                            if (indexIterator != null) {
-                                   try {
-                                          getMetaDataDialect().close(indexIterator);
-                                   } catch(JDBCException se) {
-                                          log.warn("Exception while trying to close resultset for index meta data",se);
-                                   }
-                            }
-                     }
-                     
-                     // mark columns that are unique TODO: multiple columns are not unique on their own.
-                     Iterator iterator = uniqueColumns.entrySet().iterator();
-                     while (iterator.hasNext() ) {
-                            Map.Entry entry = (Map.Entry) iterator.next();
-                            Column col = (Column) entry.getKey();
-                            Iterator keys = ( (List)entry.getValue() ).iterator();
-                             while (keys.hasNext() ) {
-                                   UniqueKey key = (UniqueKey) keys.next();
-                            
-                                   if(key.getColumnSpan()==1) {
-                                          col.setUnique(true);
-                                   }
-                            }
-                     }
-                     
-                     iterator = uniquekeys.entrySet().iterator();
-                     while(iterator.hasNext()) {
-                            // if keyset has no overlaps with primary key (table.getPrimaryKey())
-                            // if only key matches then mark as setNaturalId(true);
-                            iterator.next();
-                     }
-              }
-
-           private void mergeMultiMap(Map dest, Map src) {
-              Iterator items = src.entrySet().iterator();
-              
-              while ( items.hasNext() ) {
-                     Map.Entry element = (Map.Entry) items.next();
-                     
-                     List existing = (List) dest.get( element.getKey() );
-                     if(existing == null) {
-                            dest.put( element.getKey(), element.getValue() );
-                     } 
-                     else {
-                            existing.addAll( (List)element.getValue() );
-                     }                    
-              }
-              
-           }
-
-           private boolean equalTable(Table table1, Table table2) {
-                     return  table1.getName().equals(table2.getName()) 
-                                   && ( equal(table1.getSchema(), table2.getSchema() )
-                                   && ( equal(table1.getCatalog(), table2.getCatalog() ) ) );
-              }
-
-              private boolean equal(String str, String str2) {
-                     if(str==str2) return true;
-                     if(str!=null && str.equals(str2) ) return true;
-                     return false;
-              }
-
-              static private void addToMultiMap(Map multimap, String key, Object item) {
-                     List existing = (List) multimap.get(key);
-                     if(existing == null) {
-                            existing = new ArrayList();
-                            multimap.put(key, existing);
-                     }
-                     existing.add(item);
-              }
-
-              private Column getColumn(Table table, String columnName) {
-                     Column column = new Column();
-                     column.setName(quote(columnName));
-                     Column existing = table.getColumn(column);
-                     if(existing!=null) {
-                            column = existing;
-                     }
-                     return column;
-              }
-
-              static class NoopProgressListener implements ProgressListener {
-                     public void startSubTask(String name) {        // noop };
-                     }
-              }
-              
-              public List readDatabaseSchema(DatabaseCollector dbs, String catalog, String schema) {
-                     return readDatabaseSchema(dbs, catalog, schema, new NoopProgressListener());
-              }
-              
-              /** If catalog is equal to defaultCatalog then we return null so it will be null in the generated code. */
-              protected String getCatalogForModel(String catalog) {
-                     if(catalog==null) return null;
-                     if(catalog.equals(defaultCatalog)) return null;
-                     return catalog;
-              }
-
-              /** If catalog is equal to defaultSchema then we return null so it will be null in the generated code. */
-              protected String getSchemaForModel(String schema) {
-                     if(schema==null) return null;
-                     if(schema.equals(defaultSchema)) return null;
-                     return schema;
-              }
-              
-              protected String getCatalogForDBLookup(String catalog) {
-                     return catalog==null?defaultCatalog:catalog;                 
-              }
-
-              protected String getSchemaForDBLookup(String schema) {
-                     return schema==null?defaultSchema:schema;
-              }
-
-              public Set readSequences(String sql) {
-                     Set sequences = new HashSet();
-                     if (sql!=null) {
-                            Connection connection = null;
-                            try {
-                            
-                                   connection = provider.getConnection();
-                                   Statement statement = null;
-                                   ResultSet rs = null;
-                                   try {
-                                          statement = connection.createStatement();
-                                          rs = statement.executeQuery(sql);
-
-                                          while ( rs.next() ) {
-                                                 sequences.add( rs.getString(1).toLowerCase().trim() );
-                                          }
-                                   }
-                                   finally {
-                                          if (rs!=null) rs.close();
-                                          if (statement!=null) statement.close();
-                                   }
-
-                            } catch (SQLException e) {
-                                   sec.convert(e, "Problem while closing connection", null);
-                            }
-                            finally {
-                                   if(connection!=null)
-                                          try {
-                                                 provider.closeConnection( connection );
-                                          }
-                                          catch (SQLException e) {
-                                                 sec.convert(e, "Problem while closing connection", null);
-                                          }
-                            } 
-                     }
-                     return sequences;
-              }
-}             
-
+package org.hibernate.cfg.reveng; 
+ 
+import org.apache.commons.logging.Log; 
+import org.apache.commons.logging.LogFactory; 
+import org.hibernate.JDBCException; 
+import org.hibernate.MappingException; 
+import org.hibernate.cfg.JDBCBinderException; 
+import org.hibernate.cfg.reveng.dialect.MetaDataDialect; 
+import org.hibernate.connection.ConnectionProvider; 
+import org.hibernate.exception.SQLExceptionConverter; 
+import org.hibernate.mapping.*; 
+import org.hibernate.sql.Alias; 
+ 
+import java.sql.*; 
+import java.util.*; 
+import java.util.Collection; 
+import java.util.List; 
+import java.util.Map; 
+import java.util.Set; 
+ 
+public class JDBCReader { 
+ 
+    private static final Log log = LogFactory.getLog(JDBCReader.class); 
+ 
+    private final ReverseEngineeringStrategy revengStrategy; 
+ 
+    private MetaDataDialect metadataDialect; 
+ 
+    private final ConnectionProvider provider; 
+ 
+    private final SQLExceptionConverter sec; 
+ 
+    private final String defaultSchema; 
+    private final String defaultCatalog; 
+ 
+    public JDBCReader(MetaDataDialect dialect, ConnectionProvider provider, SQLExceptionConverter sec, String defaultCatalog, String defaultSchema, ReverseEngineeringStrategy reveng) { 
+        this.metadataDialect = dialect; 
+        this.provider = provider; 
+        this.sec = sec; 
+        this.revengStrategy = reveng; 
+        this.defaultCatalog = defaultCatalog; 
+        this.defaultSchema = defaultSchema; 
+        if (revengStrategy == null) { 
+            throw new IllegalStateException("Strategy cannot be null"); 
+        } 
+    } 
+ 
+    public List readDatabaseSchema(DatabaseCollector dbs, String catalog, String schema, ProgressListener progress) { 
+        try { 
+            getMetaDataDialect().configure(provider, sec); 
+            revengStrategy.configure(provider, sec); 
+ 
+            Set hasIndices = new HashSet(); 
+ 
+            List schemaSelectors = revengStrategy.getSchemaSelections(); 
+            List foundTables = new ArrayList(); 
+            if (schemaSelectors == null) { 
+                foundTables.addAll(processTables(dbs, new SchemaSelection(catalog, schema), hasIndices, progress)); 
+            } else { 
+                for (Iterator iter = schemaSelectors.iterator(); iter.hasNext();) { 
+                    SchemaSelection selection = (SchemaSelection) iter.next(); 
+                    foundTables.addAll(processTables(dbs, selection, hasIndices, progress)); 
+                } 
+            } 
+ 
+            Iterator tables = foundTables.iterator(); // not dbs.iterateTables() to avoid "double-read" of columns etc. 
+            while (tables.hasNext()) { 
+                Table table = (Table) tables.next(); 
+                processBasicColumns(table, progress); 
+                processPrimaryKey(table); 
+                if (hasIndices.contains(table)) { 
+                    processIndices(table); 
+                } 
+            } 
+ 
+            tables = foundTables.iterator(); //dbs.iterateTables(); 
+            Map oneToManyCandidates = resolveForeignKeys(dbs, tables, progress); 
+ 
+            dbs.setOneToManyCandidates(oneToManyCandidates); 
+ 
+            return foundTables; 
+        } finally { 
+            getMetaDataDialect().close(); 
+            revengStrategy.close(); 
+        } 
+    } 
+ 
+    /** 
+     * Iterates the tables and find all the foreignkeys that refers to something that is available inside the DatabaseCollector. 
+     * 
+     * @param dbs 
+     * @param progress 
+     * @param tables 
+     * @return 
+     */ 
+    private Map resolveForeignKeys(DatabaseCollector dbs, Iterator tables, ProgressListener progress) { 
+        List fks = new ArrayList(); 
+        while (tables.hasNext()) { 
+            Table table = (Table) tables.next(); 
+            // Done here after the basic process of collections as we might not have touched 
+            // all referenced tables (this ensure the columns are the same instances througout the basic JDBC derived model. 
+            // after this stage it should be "ok" to divert from keeping columns in sync as it can be required if the same 
+            //column is used with different aliases in the ORM mapping. 
+            ForeignKeysInfo foreignKeys = processForeignKeys(dbs, table, progress); 
+            fks.add(foreignKeys); 
+        } 
+ 
+        Map oneToManyCandidates = new HashMap(); 
+        for (Iterator iter = fks.iterator(); iter.hasNext();) { 
+            ForeignKeysInfo element = (ForeignKeysInfo) iter.next(); 
+            Map map = element.process(revengStrategy); // the actual foreignkey is created here. 
+            mergeMultiMap(oneToManyCandidates, map); 
+        } 
+        return oneToManyCandidates; 
+    } 
+ 
+    static class ForeignKeysInfo { 
+ 
+        final Map dependentTables; 
+        final Map dependentColumns; 
+        final Map referencedColumns; 
+        private final Table referencedTable; 
+ 
+        public ForeignKeysInfo(Table referencedTable, Map tables, Map columns, Map refColumns) { 
+            this.referencedTable = referencedTable; 
+            this.dependentTables = tables; 
+            this.dependentColumns = columns; 
+            this.referencedColumns = refColumns; 
+        } 
+ 
+        Map process(ReverseEngineeringStrategy revengStrategy) { 
+            Map oneToManyCandidates = new HashMap(); 
+            Iterator iterator = dependentTables.entrySet().iterator(); 
+            while (iterator.hasNext()) { 
+                Map.Entry entry = (Map.Entry) iterator.next(); 
+                String fkName = (String) entry.getKey(); 
+                Table fkTable = (Table) entry.getValue(); 
+                List columns = (List) dependentColumns.get(fkName); 
+                List refColumns = (List) referencedColumns.get(fkName); 
+ 
+                String className = revengStrategy.tableToClassName(TableIdentifier.create(referencedTable)); 
+ 
+                ForeignKey key = fkTable.createForeignKey(fkName, columns, className, refColumns); 
+                key.setReferencedTable(referencedTable); 
+ 
+                addToMultiMap(oneToManyCandidates, className, key); 
+            } 
+            // map<className, foreignkey> 
+            return oneToManyCandidates; 
+        } 
+    } 
+ 
+    protected ForeignKeysInfo processForeignKeys(DatabaseCollector dbs, Table referencedTable, ProgressListener progress) throws JDBCBinderException { 
+        // foreign key name to list of columns 
+        Map dependentColumns = new HashMap(); 
+        // foreign key name to Table 
+        Map dependentTables = new HashMap(); 
+        Map referencedColumns = new HashMap(); 
+ 
+        short bogusFkName = 0; 
+ 
+        // first get all the relationships dictated by the database schema 
+ 
+        Iterator exportedKeyIterator = null; 
+ 
+        log.debug("Calling getExportedKeys on " + referencedTable); 
+        progress.startSubTask("Finding exported foreignkeys on " + referencedTable.getName()); 
+        try { 
+            Map exportedKeyRs = null; 
+            exportedKeyIterator = getMetaDataDialect().getExportedKeys(getCatalogForDBLookup(referencedTable.getCatalog()), getSchemaForDBLookup(referencedTable.getSchema()), referencedTable.getName()); 
+            try { 
+                while (exportedKeyIterator.hasNext()) { 
+                    exportedKeyRs = (Map) exportedKeyIterator.next(); 
+                    String fkCatalog = getCatalogForModel((String) exportedKeyRs.get("FKTABLE_CAT")); 
+                    String fkSchema = getSchemaForModel((String) exportedKeyRs.get("FKTABLE_SCHEM")); 
+                    String fkTableName = (String) exportedKeyRs.get("FKTABLE_NAME"); 
+                    String fkColumnName = (String) exportedKeyRs.get("FKCOLUMN_NAME"); 
+                    String pkColumnName = (String) exportedKeyRs.get("PKCOLUMN_NAME"); 
+                    String fkName = (String) exportedKeyRs.get("FK_NAME"); 
+                    short keySeq = ((Short) exportedKeyRs.get("KEY_SEQ")).shortValue(); 
+ 
+                    Table fkTable = dbs.getTable(fkSchema, fkCatalog, fkTableName); 
+                    if (fkTable == null) { 
+                        //     filter out stuff we don't have tables for! 
+                        log.debug("Foreign key " + fkName + " references unknown or filtered table " + Table.qualify(fkCatalog, fkSchema, fkTableName)); 
+                        continue; 
+                    } else { 
+                        log.debug("Foreign key " + fkName); 
+                    } 
+ 
+                    // TODO: if there is a relation to a column which is not a pk 
+                    //       then handle it as a property-ref 
+ 
+                    if (keySeq == 0) { 
+                        bogusFkName++; 
+                    } 
+ 
+                    if (fkName == null) { 
+                        // somehow reuse hibernates name generator ? 
+                        fkName = Short.toString(bogusFkName); 
+                    } 
+                    //Table fkTable = mappings.addTable(fkSchema, fkCatalog, fkTableName, null, false); 
+ 
+ 
+                    List depColumns = (List) dependentColumns.get(fkName); 
+                    if (depColumns == null) { 
+                        depColumns = new ArrayList(); 
+                        dependentColumns.put(fkName, depColumns); 
+                        dependentTables.put(fkName, fkTable); 
+                    } else { 
+                        Object previousTable = dependentTables.get(fkName); 
+                        if (fkTable != previousTable) { 
+                            throw new JDBCBinderException("Foreign key name (" + fkName + ") mapped to different tables! previous: " + previousTable + " current:" + fkTable); 
+                        } 
+                    } 
+ 
+                    Column column = new Column(fkColumnName); 
+                    Column existingColumn = fkTable.getColumn(column); 
+                    column = existingColumn == null ? column : existingColumn; 
+ 
+                    depColumns.add(column); 
+                } 
+            } 
+            finally { 
+                try { 
+                    if (exportedKeyIterator != null) { 
+                        getMetaDataDialect().close(exportedKeyIterator); 
+                    } 
+                } catch (JDBCException se) { 
+                    log.warn("Exception while closing result set for foreign key meta data", se); 
+                } 
+            } 
+        } catch (JDBCException se) { 
+            //throw sec.convert(se, "Exception while reading foreign keys for " + referencedTable, null); 
+            log.warn("Exception while reading foreign keys for " + referencedTable + " [" + se.toString() + "]", se); 
+            // sybase (and possibly others has issues with exportedkeys) see HBX-411 
+            // we continue after this to allow user provided keys to be added. 
+        } 
+ 
+        List userForeignKeys = revengStrategy.getForeignKeys(TableIdentifier.create(referencedTable)); 
+        if (userForeignKeys != null) { 
+            Iterator iterator = userForeignKeys.iterator(); 
+            while (iterator.hasNext()) { 
+                ForeignKey element = (ForeignKey) iterator.next(); 
+ 
+                if (!equalTable(referencedTable, element.getReferencedTable())) { 
+                    log.debug("Referenced table " + element.getReferencedTable().getName() + " is not " + referencedTable + ". Ignoring userdefined foreign key " + element); 
+                    continue; // skip non related foreign keys 
+                } 
+ 
+                String userfkName = element.getName(); 
+                Table userfkTable = element.getTable(); 
+ 
+                List userColumns = element.getColumns(); 
+                List userrefColumns = element.getReferencedColumns(); 
+ 
+                Table deptable = (Table) dependentTables.get(userfkName); 
+                if (deptable != null) { // foreign key already defined!? 
+                    throw new MappingException("Foreign key " + userfkName + " already defined in the database!"); 
+                } 
+ 
+                deptable = dbs.getTable(userfkTable.getSchema(), userfkTable.getCatalog(), userfkTable.getName()); 
+                if (deptable == null) { 
+                    // filter out stuff we don't have tables for! 
+                    log.debug("User defined foreign key " + userfkName + " references unknown or filtered table " + TableIdentifier.create(userfkTable)); 
+                    continue; 
+                } 
+ 
+                dependentTables.put(userfkName, deptable); 
+ 
+                List depColumns = new ArrayList(userColumns.size()); 
+                Iterator colIterator = userColumns.iterator(); 
+                while (colIterator.hasNext()) { 
+                    Column jdbcColumn = (Column) colIterator.next(); 
+                    Column column = new Column(jdbcColumn.getName()); 
+                    Column existingColumn = deptable.getColumn(column); 
+                    column = existingColumn == null ? column : existingColumn; 
+                    depColumns.add(column); 
+                } 
+ 
+                List refColumns = new ArrayList(userrefColumns.size()); 
+                colIterator = userrefColumns.iterator(); 
+                while (colIterator.hasNext()) { 
+                    Column jdbcColumn = (Column) colIterator.next(); 
+                    Column column = new Column(jdbcColumn.getName()); 
+                    Column existingColumn = referencedTable.getColumn(column); 
+                    column = existingColumn == null ? column : existingColumn; 
+                    refColumns.add(column); 
+                } 
+ 
+                referencedColumns.put(userfkName, refColumns); 
+                dependentColumns.put(userfkName, depColumns); 
+            } 
+        } 
+ 
+ 
+        return new ForeignKeysInfo(referencedTable, dependentTables, dependentColumns, referencedColumns); 
+ 
+    } 
+ 
+ 
+    /** 
+     * @param catalog 
+     * @param schema 
+     * @param table 
+     * @param primaryKeys 
+     * @return 
+     * @throws SQLException 
+     */ 
+    private void processPrimaryKey(Table table) { 
+ 
+        List columns = new ArrayList(); 
+        PrimaryKey key = null; 
+        Iterator primaryKeyIterator = null; 
+        try { 
+            Map primaryKeyRs = null; 
+            primaryKeyIterator = getMetaDataDialect().getPrimaryKeys(getCatalogForDBLookup(table.getCatalog()), getSchemaForDBLookup(table.getSchema()), table.getName()); 
+ 
+            while (primaryKeyIterator.hasNext()) { 
+                primaryKeyRs = (Map) primaryKeyIterator.next(); 
+ 
+                /*String ownCatalog = primaryKeyRs.getString("TABLE_CAT"); 
+                     String ownSchema = primaryKeyRs.getString("TABLE_SCHEM"); 
+                     String ownTable = primaryKeyRs.getString("TABLE_NAME");*/ 
+ 
+                String columnName = (String) primaryKeyRs.get("COLUMN_NAME"); 
+                short seq = ((Short) primaryKeyRs.get("KEY_SEQ")).shortValue(); 
+                String name = (String) primaryKeyRs.get("PK_NAME"); 
+ 
+                if (key == null) { 
+                    key = new PrimaryKey(); 
+                    key.setName(name); 
+                    key.setTable(table); 
+                    if (table.getPrimaryKey() != null) { 
+                        throw new JDBCBinderException(table + " already has a primary key!"); //TODO: ignore ? 
+                    } 
+                    table.setPrimaryKey(key); 
+                } else { 
+                    if (!(name == key.getName()) && name != null && !name.equals(key.getName())) { 
+                        throw new JDBCBinderException("Duplicate names found for primarykey. Existing name: " + key.getName() + " JDBC name: " + name + " on table " + table); 
+                    } 
+                } 
+ 
+                columns.add(new Object[]{new Short(seq), columnName}); 
+            } 
+        } finally { 
+            if (primaryKeyIterator != null) { 
+                try { 
+                    getMetaDataDialect().close(primaryKeyIterator); 
+                } catch (JDBCException se) { 
+                    log.warn("Exception when closing resultset for reading primary key information", se); 
+                } 
+            } 
+        } 
+ 
+        // sort the columns accoring to the key_seq. 
+        Collections.sort(columns, new Comparator() { 
+            public boolean equals(Object obj) { 
+                return super.equals(obj); 
+            } 
+ 
+            public int compare(Object o1, Object o2) { 
+                Short left = (Short) ((Object[]) o1)[0]; 
+                Short right = (Short) ((Object[]) o2)[0]; 
+                return left.compareTo(right); 
+            } 
+ 
+            public int hashCode() { 
+                return super.hashCode(); 
+            } 
+        }); 
+ 
+        List t = new ArrayList(columns.size()); 
+        Iterator cols = columns.iterator(); 
+        while (cols.hasNext()) { 
+            Object[] element = (Object[]) cols.next(); 
+            t.add(element[1]); 
+        } 
+        columns = t; 
+ 
+        if (key == null) { 
+            log.warn("The JDBC driver didn't report any primary key columns in " + table.getName() + ". Asking rev.eng. strategy"); 
+            List userPrimaryKey = revengStrategy.getPrimaryKeyColumnNames(TableIdentifier.create(table)); 
+            if (userPrimaryKey != null && !userPrimaryKey.isEmpty()) { 
+                key = new PrimaryKey(); 
+                key.setName(new Alias(15, "PK").toAliasString(table.getName())); 
+                key.setTable(table); 
+                if (table.getPrimaryKey() != null) { 
+                    throw new JDBCBinderException(table + " already has a primary key!"); //TODO: ignore ? 
+                } 
+                table.setPrimaryKey(key); 
+                columns = new ArrayList(userPrimaryKey); 
+            } else { 
+                log.warn("Rev.eng. strategy did not report any primary key columns for " + table.getName()); 
+            } 
+        } 
+ 
+        if (key != null) { 
+            cols = columns.iterator(); 
+            while (cols.hasNext()) { 
+                String name = (String) cols.next(); 
+                // should get column from table if it already exists! 
+                Column col = getColumn(table, name); 
+                key.addColumn(col); 
+            } 
+            log.debug("primary key for " + table + " -> " + key); 
+        } 
+ 
+ 
+    } 
+ 
+    private boolean safeEquals(Object value, Object tf) { 
+        if (value == tf) return true; 
+        if (value == null) return false; 
+        return value.equals(tf); 
+    } 
+ 
+    private Collection processTables(DatabaseCollector dbs, SchemaSelection schemaSelection, Set hasIndices, ProgressListener progress) { 
+        Map tableRs = null; 
+        Iterator tableIterator = null; 
+        List tables = new ArrayList(); 
+        boolean multiSchema = false; // TODO: the code below detects if the reveng is multischema'ed, but not used for anything yet. should be used to remove schema/catalog info from output if only one schema/catalog used. 
+ 
+        try { 
+            progress.startSubTask("Finding tables in " + schemaSelection); 
+ 
+            tableIterator = getMetaDataDialect().getTables(schemaSelection.getMatchCatalog(), schemaSelection.getMatchSchema(), schemaSelection.getMatchTable()); 
+            String[] lastQualifier = null; 
+            String[] foundQualifier = new String[2]; 
+ 
+            while (tableIterator.hasNext()) { 
+                tableRs = (Map) tableIterator.next(); 
+                String tableName = (String) tableRs.get("TABLE_NAME"); 
+                String schemaName = (String) tableRs.get("TABLE_SCHEM"); 
+                String catalogName = (String) tableRs.get("TABLE_CAT"); 
+ 
+                TableIdentifier ti = new TableIdentifier(catalogName, schemaName, tableName); 
+                if (revengStrategy.excludeTable(ti)) { 
+                    log.debug("Table " + ti + " excluded by strategy"); 
+                    continue; 
+                } 
+ 
+                if (!multiSchema) { 
+                    foundQualifier[0] = catalogName; 
+                    foundQualifier[1] = schemaName; 
+                    if (lastQualifier == null) { 
+                        lastQualifier = new String[2]; 
+                        lastQualifier[0] = foundQualifier[0]; 
+                        lastQualifier[1] = foundQualifier[1]; 
+                    } 
+                    if ((!safeEquals(lastQualifier[0], foundQualifier[0])) || (!safeEquals(lastQualifier[1], foundQualifier[1]))) { 
+                        multiSchema = true; 
+                    } 
+                } 
+ 
+                tables.add(new HashMap(tableRs)); 
+            } 
+        } 
+        finally { 
+            try { 
+                if (tableIterator != null) getMetaDataDialect().close(tableIterator); 
+            } 
+            catch (Exception ignore) { 
+            } 
+        } 
+ 
+        List processedTables = new ArrayList(); 
+        tableIterator = tables.iterator(); 
+        while (tableIterator.hasNext()) { 
+            tableRs = (Map) tableIterator.next(); 
+            String tableName = (String) tableRs.get("TABLE_NAME"); 
+            String schemaName = (String) tableRs.get("TABLE_SCHEM"); 
+            String catalogName = (String) tableRs.get("TABLE_CAT"); 
+ 
+            /*TableIdentifier ti = new TableIdentifier(catalogName, schemaName, tableName); 
+                  if(revengStrategy.excludeTable(ti) ) { 
+                  log.debug("Table " + ti + " excluded by strategy"); 
+                  continue; 
+                  }*/ 
+ 
+            String comment = (String) tableRs.get("REMARKS"); 
+            String tableType = (String) tableRs.get("TABLE_TYPE"); 
+ 
+            if (dbs.getTable(schemaName, catalogName, tableName) != null) { 
+                log.debug("Ignoring " + tableName + " since it has already been processed"); 
+                continue; 
+            } else { 
+                if (("TABLE".equals(tableType) || "VIEW".equals(tableType) /*|| "SYNONYM".equals(tableType) */)) { //|| 
+                    // ("SYNONYM".equals(tableType) && isOracle() ) ) { // only on oracle ? TODO: HBX-218 
+                    // it's a regular table or a synonym 
+ 
+                    // ensure schema and catalogname is truly empty (especially mysql returns null schema, "" catalog) 
+                    if (schemaName != null && schemaName.trim().length() == 0) { 
+                        schemaName = null; 
+                    } 
+                    if (catalogName != null && catalogName.trim().length() == 0) { 
+                        catalogName = null; 
+                    } 
+                    log.debug("Adding table " + tableName + " of type " + tableType); 
+                    progress.startSubTask("Found " + tableName); 
+                    Table table = dbs.addTable(quote(getSchemaForModel(schemaName)), getCatalogForModel(catalogName), quote(tableName)); 
+                    table.setComment(comment); 
+                    if (tableType.equals("TABLE")) { 
+                        hasIndices.add(table); 
+                    } 
+                    processedTables.add(table); 
+                } else { 
+                    log.debug("Ignoring table " + tableName + " of type " + tableType); 
+                } 
+            } 
+        } 
+ 
+        return processedTables; 
+    } 
+ 
+    private void processBasicColumns(Table table, ProgressListener progress) { 
+        // get the columns 
+ 
+        String qualify = Table.qualify(table.getCatalog(), table.getSchema(), table.getName()); 
+        Iterator columnIterator = null; 
+ 
+        try { 
+            Map columnRs = null; 
+            log.debug("Finding columns for " + qualify); 
+            progress.startSubTask("Finding columns for " + qualify); 
+            columnIterator = getMetaDataDialect().getColumns(getCatalogForDBLookup(table.getCatalog()), getSchemaForDBLookup(table.getSchema()), table.getName(), null); 
+            //dumpHeader(columnRs); 
+            while (columnIterator.hasNext()) { 
+                //dumpRow(columnRs); 
+                columnRs = (Map) columnIterator.next(); 
+                String tableName = (String) columnRs.get("TABLE_NAME"); 
+                int sqlType = ((Integer) columnRs.get("DATA_TYPE")).intValue(); 
+                String sqlTypeName = (String) columnRs.get("TYPE_NAME"); 
+                String columnName = (String) columnRs.get("COLUMN_NAME"); 
+ 
+ 
+                String comment = (String) columnRs.get("REMARKS"); 
+ 
+                TableIdentifier ti = TableIdentifier.create(table); 
+                if (revengStrategy.excludeColumn(ti, columnName)) { 
+                    log.debug("Column " + ti + "." + columnName + " excluded by strategy"); 
+                    continue; 
+                } 
+                if (!tableName.equals(table.getName())) { 
+                    log.debug("Table name " + tableName + " does not match requested " + table.getName() + ". Ignoring column " + columnName + " since it either is invalid or a duplicate"); 
+                    continue; 
+                } 
+ 
+                Object columnDefaultValue = columnRs.get("COLUMN_DEF"); //TODO: only read if have a way to avoid issues with clobs/lobs and similar 
+                int dbNullability = ((Integer) columnRs.get("NULLABLE")).intValue(); 
+                boolean isNullable = true; 
+                switch (dbNullability) { 
+                    case DatabaseMetaData.columnNullable: 
+                    case DatabaseMetaData.columnNullableUnknown: 
+                        isNullable = true; 
+                        break; 
+                    case DatabaseMetaData.columnNoNulls: 
+                        isNullable = false; 
+                        break; 
+                    default: 
+                        isNullable = true; 
+                } 
+ 
+                int size = ((Integer) columnRs.get("COLUMN_SIZE")).intValue(); 
+                int decimalDigits = ((Integer) columnRs.get("DECIMAL_DIGITS")).intValue(); 
+ 
+                Column column = new Column(); 
+ 
+                if (columnDefaultValue != null) { 
+                    log.debug("Default value found for column " + columnName + " :" + columnDefaultValue.toString()); 
+                    column.setDefaultValue(columnDefaultValue.toString()); 
+                } 
+ 
+                column.setName(quote(columnName)); 
+                Column existing = table.getColumn(column); 
+                if (existing != null) { 
+                    // TODO: should we just pick it up and fill it up with whatever we get from the db instead ? 
+                    throw new JDBCBinderException(column + " already exists in " + qualify); 
+                } 
+ 
+                //TODO: column.setSqlType(sqlTypeName); //this does not work 'cos the precision/scale/length are not retured in TYPE_NAME 
+                //column.setSqlType(sqlTypeName); 
+                column.setComment(comment); 
+                column.setSqlTypeCode(new Integer(sqlType)); 
+                if (intBounds(size)) { 
+                    if (JDBCToHibernateTypeHelper.typeHasLength(sqlType)) { 
+                        column.setLength(size); 
+                    } 
+                    if (JDBCToHibernateTypeHelper.typeHasScaleAndPrecision(sqlType)) { 
+                        column.setPrecision(size); 
+                    } 
+                } 
+                if (intBounds(decimalDigits)) { 
+                    if (JDBCToHibernateTypeHelper.typeHasScaleAndPrecision(sqlType)) { 
+                        column.setScale(decimalDigits); 
+                    } 
+                } 
+ 
+                column.setNullable(isNullable); 
+ 
+                // columnDefaultValue is useless for Hibernate 
+                // isIndexed  (available via Indexes) 
+                // unique - detected when getting indexes 
+                // isPk - detected when finding primary keys 
+ 
+                table.addColumn(column); 
+            } 
+        } 
+        finally { 
+ 
+            if (columnIterator != null) { 
+                try { 
+                    getMetaDataDialect().close(columnIterator); 
+                } catch (JDBCException se) { 
+                    log.warn("Exception while closing iterator for column meta data", se); 
+                } 
+            } 
+        } 
+ 
+    } 
+ 
+ 
+    private String quote(String columnName) { 
+        if (columnName == null) return columnName; 
+        if (getMetaDataDialect().needQuote(columnName)) { 
+            if (columnName.length() > 1 && columnName.charAt(0) == '`' && columnName.charAt(columnName.length() - 1) == '`') { 
+                return columnName; // avoid double quoting 
+            } 
+            return "`" + columnName + "`"; 
+        } else { 
+            return columnName; 
+        } 
+    } 
+ 
+    private MetaDataDialect getMetaDataDialect() { 
+        return metadataDialect; 
+    } 
+ 
+ 
+    /** 
+     * @param size 
+     * @return 
+     */ 
+    private boolean intBounds(int size) { 
+        return size >= 0 && size != Integer.MAX_VALUE; 
+    } 
+ 
+ 
+    private void processIndices(Table table) { 
+ 
+        Map indexes = new HashMap(); // indexname (String) -> Index 
+        Map uniquekeys = new HashMap(); // name (String) -> UniqueKey 
+        Map uniqueColumns = new HashMap(); // Column -> List<Index> 
+ 
+        Iterator indexIterator = null; 
+        try { 
+            Map indexRs = null; 
+            indexIterator = getMetaDataDialect().getIndexInfo(getCatalogForDBLookup(table.getCatalog()), getSchemaForDBLookup(table.getSchema()), table.getName()); 
+ 
+            while (indexIterator.hasNext()) { 
+                indexRs = (Map) indexIterator.next(); 
+                String indexName = (String) indexRs.get("INDEX_NAME"); 
+                String columnName = (String) indexRs.get("COLUMN_NAME"); 
+                boolean unique = !((Boolean) indexRs.get("NON_UNIQUE")).booleanValue(); 
+ 
+                if (columnName != null || indexName != null) { // both can be non-null with statistical indexs which we don't have any use for. 
+ 
+                    if (unique) { 
+                        UniqueKey key = (UniqueKey) uniquekeys.get(indexName); 
+                        if (key == null) { 
+                            key = new UniqueKey(); 
+                            key.setName(indexName); 
+                            key.setTable(table); 
+                            table.addUniqueKey(key); 
+                            uniquekeys.put(indexName, key); 
+                        } 
+ 
+                        if (indexes.containsKey(indexName)) { 
+                            throw new JDBCBinderException("UniqueKey exists also as Index! "); 
+                        } 
+                        Column column = getColumn(table, columnName); 
+                        key.addColumn(column); 
+ 
+                        if (unique && key.getColumnSpan() == 1) { 
+                            // make list of columns that has the chance of being unique 
+                            List l = (List) uniqueColumns.get(column); 
+                            if (l == null) { 
+                                l = new ArrayList(); 
+                                uniqueColumns.put(column, l); 
+                            } 
+                            l.add(key); 
+                        } 
+                    } else { 
+                        Index index = (Index) indexes.get(indexName); 
+                        if (index == null) { 
+                            index = new Index(); 
+                            index.setName(indexName); 
+                            index.setTable(table); 
+                            table.addIndex(index); 
+                            indexes.put(indexName, index); 
+                        } 
+ 
+                        if (uniquekeys.containsKey(indexName)) { 
+                            throw new JDBCBinderException("Index exists also as Unique! "); 
+                        } 
+                        Column column = getColumn(table, columnName); 
+                        index.addColumn(column); 
+                    } 
+ 
+                } else { 
+                    if (DatabaseMetaData.tableIndexStatistic != ((Short) indexRs.get("TYPE")).shortValue()) { 
+                        log.warn("Index was not statistical, but no column name was found in " + indexName); 
+                    } 
+ 
+                } 
+            } 
+        } 
+        catch (JDBCException t) { 
+            log.warn("Exception while trying to get indexinfo on " + Table.qualify(table.getCatalog(), table.getSchema(), table.getName()) + "=" + t.getMessage()); 
+            // Bug #604761 Oracle getIndexInfo() needs major grants And other dbs sucks too ;) 
+            // http://sourceforge.net/tracker/index.php?func=detail&aid=604761&group_id=36044&atid=415990 
+        } 
+        finally { 
+            if (indexIterator != null) { 
+                try { 
+                    getMetaDataDialect().close(indexIterator); 
+                } catch (JDBCException se) { 
+                    log.warn("Exception while trying to close resultset for index meta data", se); 
+                } 
+            } 
+        } 
+ 
+        // mark columns that are unique TODO: multiple columns are not unique on their own. 
+        Iterator iterator = uniqueColumns.entrySet().iterator(); 
+        while (iterator.hasNext()) { 
+            Map.Entry entry = (Map.Entry) iterator.next(); 
+            Column col = (Column) entry.getKey(); 
+            Iterator keys = ((List) entry.getValue()).iterator(); 
+            while (keys.hasNext()) { 
+                UniqueKey key = (UniqueKey) keys.next(); 
+ 
+                if (key.getColumnSpan() == 1) { 
+                    col.setUnique(true); 
+                } 
+            } 
+        } 
+ 
+        iterator = uniquekeys.entrySet().iterator(); 
+        while (iterator.hasNext()) { 
+            // if keyset has no overlaps with primary key (table.getPrimaryKey()) 
+            // if only key matches then mark as setNaturalId(true); 
+            iterator.next(); 
+        } 
+    } 
+ 
+    private void mergeMultiMap(Map dest, Map src) { 
+        Iterator items = src.entrySet().iterator(); 
+ 
+        while (items.hasNext()) { 
+            Map.Entry element = (Map.Entry) items.next(); 
+ 
+            List existing = (List) dest.get(element.getKey()); 
+            if (existing == null) { 
+                dest.put(element.getKey(), element.getValue()); 
+            } else { 
+                existing.addAll((List) element.getValue()); 
+            } 
+        } 
+ 
+    } 
+ 
+    private boolean equalTable(Table table1, Table table2) { 
+        return table1.getName().equals(table2.getName()) 
+                && (equal(table1.getSchema(), table2.getSchema()) 
+                && (equal(table1.getCatalog(), table2.getCatalog()))); 
+    } 
+ 
+    private boolean equal(String str, String str2) { 
+        if (str == str2) return true; 
+        if (str != null && str.equals(str2)) return true; 
+        return false; 
+    } 
+ 
+    static private void addToMultiMap(Map multimap, String key, Object item) { 
+        List existing = (List) multimap.get(key); 
+        if (existing == null) { 
+            existing = new ArrayList(); 
+            multimap.put(key, existing); 
+        } 
+        existing.add(item); 
+    } 
+ 
+    private Column getColumn(Table table, String columnName) { 
+        Column column = new Column(); 
+        column.setName(quote(columnName)); 
+        Column existing = table.getColumn(column); 
+        if (existing != null) { 
+            column = existing; 
+        } 
+        return column; 
+    } 
+ 
+    static class NoopProgressListener implements ProgressListener { 
+        public void startSubTask(String name) {    // noop }; 
+        } 
+    } 
+ 
+    public List readDatabaseSchema(DatabaseCollector dbs, String catalog, String schema) { 
+        return readDatabaseSchema(dbs, catalog, schema, new NoopProgressListener()); 
+    } 
+ 
+    /** 
+     * If catalog is equal to defaultCatalog then we return null so it will be null in the generated code. 
+     */ 
+    protected String getCatalogForModel(String catalog) { 
+        if (catalog == null) return null; 
+        if (catalog.equals(defaultCatalog)) return null; 
+        return catalog; 
+    } 
+ 
+    /** 
+     * If catalog is equal to defaultSchema then we return null so it will be null in the generated code. 
+     */ 
+    protected String getSchemaForModel(String schema) { 
+        if (schema == null) return null; 
+        if (schema.equals(defaultSchema)) return null; 
+        return schema; 
+    } 
+ 
+    protected String getCatalogForDBLookup(String catalog) { 
+        return catalog == null ? defaultCatalog : catalog; 
+    } 
+ 
+    protected String getSchemaForDBLookup(String schema) { 
+        return schema == null ? defaultSchema : schema; 
+    } 
+ 
+    public Set readSequences(String sql) { 
+        Set sequences = new HashSet(); 
+        if (sql != null) { 
+            Connection connection = null; 
+            try { 
+ 
+                connection = provider.getConnection(); 
+                Statement statement = null; 
+                ResultSet rs = null; 
+                try { 
+                    statement = connection.createStatement(); 
+                    rs = statement.executeQuery(sql); 
+ 
+                    while (rs.next()) { 
+                        sequences.add(rs.getString(1).toLowerCase().trim()); 
+                    } 
+                } 
+                finally { 
+                    if (rs != null) rs.close(); 
+                    if (statement != null) statement.close(); 
+                } 
+ 
+            } catch (SQLException e) { 
+                sec.convert(e, "Problem while closing connection", null); 
+            } 
+            finally { 
+                if (connection != null) 
+                    try { 
+                        provider.closeConnection(connection); 
+                    } 
+                    catch (SQLException e) { 
+                        sec.convert(e, "Problem while closing connection", null); 
+                    } 
+            } 
+        } 
+        return sequences; 
+    } 
+} 
+ 
Index: /media/hdb5/home/sorin/Projects/hibernate-tools/trunk/src/main/java/org/hibernate/cfg/reveng/dialect/JDBCMetaDataDialect.java
===================================================================
--- /media/hdb5/home/sorin/Projects/hibernate-tools/trunk/src/main/java/org/hibernate/cfg/reveng/dialect/JDBCMetaDataDialect.java       (revision 341)
+++ /media/hdb5/home/sorin/Projects/hibernate-tools/trunk/src/main/java/org/hibernate/cfg/reveng/dialect/JDBCMetaDataDialect.java       (revision 328)
@@ -1,219 +1,227 @@
-package org.hibernate.cfg.reveng.dialect;
-
-import java.sql.ResultSet;
-import java.sql.ResultSetMetaData;
-import java.sql.SQLException;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Map;
-
-import org.hibernate.mapping.Table;
-
-/**
- * MetaData dialect that uses standard JDBC for reading metadata.
- * 
- * @author Max Rydahl Andersen
- *
- */
-public class JDBCMetaDataDialect extends AbstractMetaDataDialect {
-       
-       public Iterator getTables(String xcatalog, String xschema, String xtable) {
-              try {                
-                     final String catalog = caseForSearch( xcatalog );
-                     final String schema = caseForSearch( xschema );
-                     final String table = caseForSearch( xtable );
-                     
-                     log.debug("getTables(" + catalog + "." + schema + "." + table + ")");
-                     
-                     ResultSet tableRs = getMetaData().getTables(catalog , schema , table, new String[] { "TABLE", "VIEW" });
-                     
-                     return new ResultSetIterator(tableRs, getSQLExceptionConverter()) {
-                            
-                            Map element = new HashMap();
-                            protected Object convertRow(ResultSet tableRs) throws SQLException {
-                                   element.clear();
-                                   putTablePart( element, tableRs );
-                                   element.put("TABLE_TYPE", tableRs.getString("TABLE_TYPE"));
-                                   element.put("REMARKS", tableRs.getString("REMARKS"));
-                                   return element;                                    
-                            }
-                            protected Throwable handleSQLException(SQLException e) {
-                                   // schemaRs and catalogRs are only used for error reporting if
-                                   // we get an exception
-                                   String databaseStructure = getDatabaseStructure( catalog, schema );
-                                   throw getSQLExceptionConverter().convert( e,
-                                                 "Could not get list of tables from database. Probably a JDBC driver problem. "
-                                                               + databaseStructure, null );                               
-                            }
-                     };
-              } catch (SQLException e) {
-                     // schemaRs and catalogRs are only used for error reporting if we get an exception
-                     String databaseStructure = getDatabaseStructure(xcatalog,xschema);
-                     throw getSQLExceptionConverter().convert(e, "Could not get list of tables from database. Probably a JDBC driver problem. " + databaseStructure, null);                 
-              }             
-       }
-       
-
-       private void dumpHeader(ResultSet columnRs) throws SQLException {
-                 ResultSetMetaData md2 = columnRs.getMetaData();
-                 
-                 int columnCount = md2.getColumnCount();
-                 for (int i = 1; i <= columnCount; i++) {
-                        System.out.print(md2.getColumnName(i) + "|");
-                 }          
-                 System.out.println();
-       }
-
-       private void dumpRow(ResultSet columnRs) throws SQLException {
-                 ResultSetMetaData md2 = columnRs.getMetaData();
-                 
-                 int columnCount = md2.getColumnCount();
-                 for (int i = 1; i <= columnCount; i++) {
-                        System.out.print(columnRs.getObject(i) + "|");
-                 }          
-                 System.out.println();
-       }
-
-    
-       
-
-       public Iterator getIndexInfo(final String xcatalog, final String xschema, final String xtable) {
-              try {
-                     final String catalog = caseForSearch( xcatalog );
-                     final String schema = caseForSearch( xschema );
-                     final String table = caseForSearch( xtable );
-                     
-                     log.debug("getIndexInfo(" + catalog + "." + schema + "." + table + ")");
-                     ResultSet tableRs = getMetaData().getIndexInfo(catalog , schema , table, false, true);
-                     
-                     return new ResultSetIterator(tableRs, getSQLExceptionConverter()) {
-                            
-                            Map element = new HashMap();
-                            protected Object convertRow(ResultSet rs) throws SQLException {
-                                   element.clear();
-                                   putTablePart(element, rs);
-                                   element.put("INDEX_NAME", rs.getString("INDEX_NAME"));
-                                   element.put("COLUMN_NAME", rs.getString("COLUMN_NAME"));
-                                   element.put("NON_UNIQUE", Boolean.valueOf(rs.getBoolean("NON_UNIQUE")));
-                                   element.put("TYPE", new Short(rs.getShort("TYPE")));                                
-                                   return element;                                    
-                            }
-                            protected Throwable handleSQLException(SQLException e) {
-                                   throw getSQLExceptionConverter().convert(e, "Exception while getting index info for " + Table.qualify(catalog, schema, table), null);
-                            }
-                     };
-              } catch (SQLException e) {
-                     throw getSQLExceptionConverter().convert(e, "Exception while getting index info for " + Table.qualify(xcatalog, xschema, xtable), null);
-              }             
-       }
-
-       protected void putTablePart(Map element, ResultSet tableRs) throws SQLException {
-              element.put("TABLE_NAME", tableRs.getString("TABLE_NAME"));
-              element.put("TABLE_SCHEM", tableRs.getString("TABLE_SCHEM"));
-              element.put("TABLE_CAT", tableRs.getString("TABLE_CAT"));
-       }
-
-       public Iterator getColumns(final String xcatalog, final String xschema, final String xtable, String xcolumn) {
-              try {                  
-                     final String catalog = caseForSearch( xcatalog );
-                     final String schema = caseForSearch( xschema );
-                     final String table = caseForSearch( xtable );
-                     final String column = caseForSearch( xcolumn );
-                     
-                     log.debug("getColumns(" + catalog + "." + schema + "." + table + "." + column + ")");
-                     ResultSet tableRs = getMetaData().getColumns(catalog, schema, table, column);
-                     
-                     return new ResultSetIterator(tableRs, getSQLExceptionConverter()) {
-                            
-                            Map element = new HashMap();
-                            protected Object convertRow(ResultSet rs) throws SQLException {
-                                   element.clear();
-                                   putTablePart(element, rs);
-                                   element.put("DATA_TYPE", new Integer(rs.getInt("DATA_TYPE")));
-                                   element.put("TYPE_NAME", rs.getString("TYPE_NAME"));
-                                   element.put("COLUMN_NAME", rs.getString("COLUMN_NAME"));
-                                   element.put("NULLABLE", new Integer(rs.getInt("NULLABLE")));
-                                   element.put("COLUMN_SIZE", new Integer(rs.getInt("COLUMN_SIZE")));
-                                   element.put("DECIMAL_DIGITS", new Integer(rs.getInt("DECIMAL_DIGITS")));
-                                   element.put("REMARKS", rs.getString("REMARKS"));
-                                   return element;                                    
-                            }
-                            protected Throwable handleSQLException(SQLException e) {
-                                   throw getSQLExceptionConverter().convert(e, "Error while reading column meta data for " + Table.qualify(catalog, schema, table), null);
-                            }
-                     };
-              } catch (SQLException e) {
-                     throw getSQLExceptionConverter().convert(e, "Error while reading column meta data for " + Table.qualify(xcatalog, xschema, xtable), null);
-              }      
-       }
-
-       public Iterator getPrimaryKeys(final String xcatalog, final String xschema, final String xtable) {
-              try {
-                     final String catalog = caseForSearch( xcatalog );
-                     final String schema = caseForSearch( xschema );
-                     final String table = caseForSearch( xtable );
-                     
-                     log.debug("getPrimaryKeys(" + catalog + "." + schema + "." + table + ")");
-                     ResultSet tableRs = getMetaData().getPrimaryKeys(catalog, schema, table);
-                     
-                     return new ResultSetIterator(tableRs, getSQLExceptionConverter()) {
-                            
-                            Map element = new HashMap();
-                            protected Object convertRow(ResultSet rs) throws SQLException {
-                                   element.clear();
-                                   putTablePart(element, rs);
-                                   element.put("COLUMN_NAME", rs.getString("COLUMN_NAME"));
-                                   element.put("KEY_SEQ", new Short(rs.getShort("KEY_SEQ")));
-                                   element.put("PK_NAME", rs.getString("PK_NAME"));
-                                   return element;                                    
-                            }
-                            protected Throwable handleSQLException(SQLException e) {
-                                   throw getSQLExceptionConverter().convert(e, "Error while reading primary key meta data for " + Table.qualify(catalog, schema, table), null);
-                            }
-                     };
-              } catch (SQLException e) {
-                     throw getSQLExceptionConverter().convert(e, "Error while reading primary key meta data for " + Table.qualify(xcatalog, xschema, xtable), null);
-              }      
-       }
-
-       public Iterator getExportedKeys(final String xcatalog, final String xschema, final String xtable) {
-              try {
-                     final String catalog = caseForSearch( xcatalog );
-                     final String schema = caseForSearch( xschema );
-                     final String table = caseForSearch( xtable );
-                     
-                     log.debug("getExportedKeys(" + catalog + "." + schema + "." + table + ")");
-                     ResultSet tableRs = getMetaData().getExportedKeys(catalog, schema, table);
-                     
-                     return new ResultSetIterator(tableRs, getSQLExceptionConverter()) {
-                            
-                            Map element = new HashMap();
-                            protected Object convertRow(ResultSet rs) throws SQLException {
-                                   element.clear();
-                                   putExportedKeysPart( element, rs );                                
-                                   return element;                                    
-                            }
-                            protected Throwable handleSQLException(SQLException e) {
-                                   throw getSQLExceptionConverter().convert(e, "Error while reading exported keys meta data for " + Table.qualify(catalog, schema, table), null);
-                            }
-                     };
-              } catch (SQLException e) {
-                     throw getSQLExceptionConverter().convert(e, "Error while reading exported keys meta data for " + Table.qualify(xcatalog, xschema, xtable), null);
-              }      
-       }
-       
-       protected void putExportedKeysPart(Map element, ResultSet rs) throws SQLException {
-              element.put( "PKTABLE_NAME", rs.getString("PKTABLE_NAME"));
-              element.put( "PKTABLE_SCHEM", rs.getString("PKTABLE_SCHEM"));
-              element.put( "PKTABLE_CAT", rs.getString("PKTABLE_CAT"));
-              element.put( "FKTABLE_CAT", rs.getString("FKTABLE_CAT"));
-              element.put( "FKTABLE_SCHEM",rs.getString("FKTABLE_SCHEM"));
-              element.put( "FKTABLE_NAME", rs.getString("FKTABLE_NAME"));
-              element.put( "FKCOLUMN_NAME", rs.getString("FKCOLUMN_NAME"));
-              element.put( "PKCOLUMN_NAME", rs.getString("PKCOLUMN_NAME"));
-              element.put( "FK_NAME", rs.getString("FK_NAME"));
-              element.put( "KEY_SEQ", new Short(rs.getShort("KEY_SEQ")));
-       }
-       
-       
-}
+package org.hibernate.cfg.reveng.dialect; 
+ 
+import org.hibernate.mapping.Table; 
+ 
+import java.sql.ResultSet; 
+import java.sql.ResultSetMetaData; 
+import java.sql.SQLException; 
+import java.util.HashMap; 
+import java.util.Iterator; 
+import java.util.Map; 
+ 
+/** 
+ * MetaData dialect that uses standard JDBC for reading metadata. 
+ * 
+ * @author Max Rydahl Andersen 
+ */ 
+public class JDBCMetaDataDialect extends AbstractMetaDataDialect { 
+ 
+    public Iterator getTables(String xcatalog, String xschema, String xtable) { 
+        try { 
+            final String catalog = caseForSearch(xcatalog); 
+            final String schema = caseForSearch(xschema); 
+            final String table = caseForSearch(xtable); 
+ 
+            log.debug("getTables(" + catalog + "." + schema + "." + table + ")"); 
+ 
+            ResultSet tableRs = getMetaData().getTables(catalog, schema, table, new String[]{"TABLE", "VIEW"}); 
+ 
+            return new ResultSetIterator(tableRs, getSQLExceptionConverter()) { 
+ 
+                Map element = new HashMap(); 
+ 
+                protected Object convertRow(ResultSet tableRs) throws SQLException { 
+                    element.clear(); 
+                    putTablePart(element, tableRs); 
+                    element.put("TABLE_TYPE", tableRs.getString("TABLE_TYPE")); 
+                    element.put("REMARKS", tableRs.getString("REMARKS")); 
+                    return element; 
+                } 
+ 
+                protected Throwable handleSQLException(SQLException e) { 
+                    // schemaRs and catalogRs are only used for error reporting if 
+                    // we get an exception 
+                    String databaseStructure = getDatabaseStructure(catalog, schema); 
+                    throw getSQLExceptionConverter().convert(e, 
+                            "Could not get list of tables from database. Probably a JDBC driver problem. " 
+                                    + databaseStructure, null); 
+                } 
+            }; 
+        } catch (SQLException e) { 
+            // schemaRs and catalogRs are only used for error reporting if we get an exception 
+            String databaseStructure = getDatabaseStructure(xcatalog, xschema); 
+            throw getSQLExceptionConverter().convert(e, "Could not get list of tables from database. Probably a JDBC driver problem. " + databaseStructure, null); 
+        } 
+    } 
+ 
+ 
+    private void dumpHeader(ResultSet columnRs) throws SQLException { 
+        ResultSetMetaData md2 = columnRs.getMetaData(); 
+ 
+        int columnCount = md2.getColumnCount(); 
+        for (int i = 1; i <= columnCount; i++) { 
+            System.out.print(md2.getColumnName(i) + "|"); 
+        } 
+        System.out.println(); 
+    } 
+ 
+    private void dumpRow(ResultSet columnRs) throws SQLException { 
+        ResultSetMetaData md2 = columnRs.getMetaData(); 
+ 
+        int columnCount = md2.getColumnCount(); 
+        for (int i = 1; i <= columnCount; i++) { 
+            System.out.print(columnRs.getObject(i) + "|"); 
+        } 
+        System.out.println(); 
+    } 
+ 
+ 
+    public Iterator getIndexInfo(final String xcatalog, final String xschema, final String xtable) { 
+        try { 
+            final String catalog = caseForSearch(xcatalog); 
+            final String schema = caseForSearch(xschema); 
+            final String table = caseForSearch(xtable); 
+ 
+            log.debug("getIndexInfo(" + catalog + "." + schema + "." + table + ")"); 
+            ResultSet tableRs = getMetaData().getIndexInfo(catalog, schema, table, false, true); 
+ 
+            return new ResultSetIterator(tableRs, getSQLExceptionConverter()) { 
+ 
+                Map element = new HashMap(); 
+ 
+                protected Object convertRow(ResultSet rs) throws SQLException { 
+                    element.clear(); 
+                    putTablePart(element, rs); 
+                    element.put("INDEX_NAME", rs.getString("INDEX_NAME")); 
+                    element.put("COLUMN_NAME", rs.getString("COLUMN_NAME")); 
+                    element.put("NON_UNIQUE", Boolean.valueOf(rs.getBoolean("NON_UNIQUE"))); 
+                    element.put("TYPE", new Short(rs.getShort("TYPE"))); 
+                    return element; 
+                } 
+ 
+                protected Throwable handleSQLException(SQLException e) { 
+                    throw getSQLExceptionConverter().convert(e, "Exception while getting index info for " + Table.qualify(catalog, schema, table), null); 
+                } 
+            }; 
+        } catch (SQLException e) { 
+            throw getSQLExceptionConverter().convert(e, "Exception while getting index info for " + Table.qualify(xcatalog, xschema, xtable), null); 
+        } 
+    } 
+ 
+    protected void putTablePart(Map element, ResultSet tableRs) throws SQLException { 
+        element.put("TABLE_NAME", tableRs.getString("TABLE_NAME")); 
+        element.put("TABLE_SCHEM", tableRs.getString("TABLE_SCHEM")); 
+        element.put("TABLE_CAT", tableRs.getString("TABLE_CAT")); 
+    } 
+ 
+    public Iterator getColumns(final String xcatalog, final String xschema, final String xtable, String xcolumn) { 
+        try { 
+            final String catalog = caseForSearch(xcatalog); 
+            final String schema = caseForSearch(xschema); 
+            final String table = caseForSearch(xtable); 
+            final String column = caseForSearch(xcolumn); 
+ 
+            log.debug("getColumns(" + catalog + "." + schema + "." + table + "." + column + ")"); 
+            ResultSet tableRs = getMetaData().getColumns(catalog, schema, table, column); 
+ 
+            return new ResultSetIterator(tableRs, getSQLExceptionConverter()) { 
+ 
+                Map element = new HashMap(); 
+ 
+                protected Object convertRow(ResultSet rs) throws SQLException { 
+                    element.clear(); 
+                    putTablePart(element, rs); 
+                    element.put("DATA_TYPE", new Integer(rs.getInt("DATA_TYPE"))); 
+                    element.put("TYPE_NAME", rs.getString("TYPE_NAME")); 
+                    element.put("COLUMN_NAME", rs.getString("COLUMN_NAME")); 
+                    element.put("NULLABLE", new Integer(rs.getInt("NULLABLE"))); 
+                    element.put("COLUMN_SIZE", new Integer(rs.getInt("COLUMN_SIZE"))); 
+                    element.put("DECIMAL_DIGITS", new Integer(rs.getInt("DECIMAL_DIGITS"))); 
+                    element.put("REMARKS", rs.getString("REMARKS")); 
+                    element.put("COLUMN_DEF", rs.getString("COLUMN_DEF")); 
+                    return element; 
+                } 
+ 
+                protected Throwable handleSQLException(SQLException e) { 
+                    throw getSQLExceptionConverter().convert(e, "Error while reading column meta data for " + Table.qualify(catalog, schema, table), null); 
+                } 
+            }; 
+        } catch (SQLException e) { 
+            throw getSQLExceptionConverter().convert(e, "Error while reading column meta data for " + Table.qualify(xcatalog, xschema, xtable), null); 
+        } 
+    } 
+ 
+    public Iterator getPrimaryKeys(final String xcatalog, final String xschema, final String xtable) { 
+        try { 
+            final String catalog = caseForSearch(xcatalog); 
+            final String schema = caseForSearch(xschema); 
+            final String table = caseForSearch(xtable); 
+ 
+            log.debug("getPrimaryKeys(" + catalog + "." + schema + "." + table + ")"); 
+            ResultSet tableRs = getMetaData().getPrimaryKeys(catalog, schema, table); 
+ 
+            return new ResultSetIterator(tableRs, getSQLExceptionConverter()) { 
+ 
+                Map element = new HashMap(); 
+ 
+                protected Object convertRow(ResultSet rs) throws SQLException { 
+                    element.clear(); 
+                    putTablePart(element, rs); 
+                    element.put("COLUMN_NAME", rs.getString("COLUMN_NAME")); 
+                    element.put("KEY_SEQ", new Short(rs.getShort("KEY_SEQ"))); 
+                    element.put("PK_NAME", rs.getString("PK_NAME")); 
+                    return element; 
+                } 
+ 
+                protected Throwable handleSQLException(SQLException e) { 
+                    throw getSQLExceptionConverter().convert(e, "Error while reading primary key meta data for " + Table.qualify(catalog, schema, table), null); 
+                } 
+            }; 
+        } catch (SQLException e) { 
+            throw getSQLExceptionConverter().convert(e, "Error while reading primary key meta data for " + Table.qualify(xcatalog, xschema, xtable), null); 
+        } 
+    } 
+ 
+    public Iterator getExportedKeys(final String xcatalog, final String xschema, final String xtable) { 
+        try { 
+            final String catalog = caseForSearch(xcatalog); 
+            final String schema = caseForSearch(xschema); 
+            final String table = caseForSearch(xtable); 
+ 
+            log.debug("getExportedKeys(" + catalog + "." + schema + "." + table + ")"); 
+            ResultSet tableRs = getMetaData().getExportedKeys(catalog, schema, table); 
+ 
+            return new ResultSetIterator(tableRs, getSQLExceptionConverter()) { 
+ 
+                Map element = new HashMap(); 
+ 
+                protected Object convertRow(ResultSet rs) throws SQLException { 
+                    element.clear(); 
+                    putExportedKeysPart(element, rs); 
+                    return element; 
+                } 
+ 
+                protected Throwable handleSQLException(SQLException e) { 
+                    throw getSQLExceptionConverter().convert(e, "Error while reading exported keys meta data for " + Table.qualify(catalog, schema, table), null); 
+                } 
+            }; 
+        } catch (SQLException e) { 
+            throw getSQLExceptionConverter().convert(e, "Error while reading exported keys meta data for " + Table.qualify(xcatalog, xschema, xtable), null); 
+        } 
+    } 
+ 
+    protected void putExportedKeysPart(Map element, ResultSet rs) throws SQLException { 
+        element.put("PKTABLE_NAME", rs.getString("PKTABLE_NAME")); 
+        element.put("PKTABLE_SCHEM", rs.getString("PKTABLE_SCHEM")); 
+        element.put("PKTABLE_CAT", rs.getString("PKTABLE_CAT")); 
+        element.put("FKTABLE_CAT", rs.getString("FKTABLE_CAT")); 
+        element.put("FKTABLE_SCHEM", rs.getString("FKTABLE_SCHEM")); 
+        element.put("FKTABLE_NAME", rs.getString("FKTABLE_NAME")); 
+        element.put("FKCOLUMN_NAME", rs.getString("FKCOLUMN_NAME")); 
+        element.put("PKCOLUMN_NAME", rs.getString("PKCOLUMN_NAME")); 
+        element.put("FK_NAME", rs.getString("FK_NAME")); 
+        element.put("KEY_SEQ", new Short(rs.getShort("KEY_SEQ"))); 
+    } 
+ 
+ 
+} 
Index: /media/hdb5/home/sorin/Projects/hibernate-tools/trunk/src/main/java/org/hibernate/cfg/reveng/ReverseEngineeringStrategy.java
===================================================================
--- /media/hdb5/home/sorin/Projects/hibernate-tools/trunk/src/main/java/org/hibernate/cfg/reveng/ReverseEngineeringStrategy.java        (revision 341)
+++ /media/hdb5/home/sorin/Projects/hibernate-tools/trunk/src/main/java/org/hibernate/cfg/reveng/ReverseEngineeringStrategy.java        (revision 328)
@@ -1,186 +1,216 @@
-package org.hibernate.cfg.reveng;
-
-import java.util.List;
-import java.util.Map;
-import java.util.Properties;
-
-import org.hibernate.connection.ConnectionProvider;
-import org.hibernate.exception.SQLExceptionConverter;
-import org.hibernate.mapping.ForeignKey;
-import org.hibernate.mapping.MetaAttribute;
-import org.hibernate.mapping.Table;
-
-public interface ReverseEngineeringStrategy {
-
-       /**
-        * Generic method used to initialize the reverse engineering strategy.
-        * 
-        * @param settings used for this
-        */
-       public void  setSettings(ReverseEngineeringSettings settings);
-       
-       /**
-        * Configure the reverse engineering strategy. Called before reverse engineering commences.
-        * 
-        * This is mainly for exotic strategies to get access to a connection. 
-        *  
-        * @param provider a connectionprovider. It is the responsibility of the metadatadialect to open/close any used connections via this provider.
-        * @param sec sqlexceptionConverter, use to convert any possible SQLExceptions.
-        */
-       public void configure(ConnectionProvider provider, SQLExceptionConverter sec);
-
-
-       /**
-        * Close any resources this strategy might have used. Called after reverse engineering has been completed.
-        */
-       public void close();
-
-       /**
-        * 
-        * @return a fully-qualified class name  
-        */
-       public String tableToClassName(TableIdentifier tableIdentifier);
-
-       /**
-        * Return a property name for a Column.
-        * @param column a columnname
-        * @return a property name
-        */
-       public String columnToPropertyName(TableIdentifier table, String column);
-          
-       public boolean excludeTable(TableIdentifier ti);
-       
-       public boolean excludeColumn(TableIdentifier identifier, String columnName);
-       
-       /**
-        * Gets the preferred Hibernate type for an SQL type.
-        * @param table name of the table, can be null
-        * @param columnName name of the column, can be null
-        * @param sqlType The sql type.
-        * @param length The length of the column.
-        * @param precision The number of decimal digits, if applicable.
-        * @param scale The scale, if applicable.
-        * @param nullable The nullability of the column
-        * @param generatedIdentifier true if for a column used in an identifier that is not "assigned", false otherwise.
-        * @return The Preferred hibernate type name.
-        */
-       public String columnToHibernateTypeName(TableIdentifier table, String columnName, int sqlType, int length, int precision, int scale, boolean nullable, boolean generatedIdentifier);
-
-       /**
-        * Gets the user defined foreign keys.
-        * @param referencedTable TODO
-        * @param identifier 
-        * @return a list of ForeignKey's
-        */
-       public List getForeignKeys(TableIdentifier referencedTable);
-
-       public String getTableIdentifierStrategyName(TableIdentifier identifier);
-
-       public Properties getTableIdentifierProperties(TableIdentifier identifier);
-
-       /** 
-        * If a table does not have any primarykey columns reported, this method is called. 
-        * @return list of strings for each column name that is part of the primary key 
-        **/
-       public List getPrimaryKeyColumnNames(TableIdentifier identifier);
-
-       /**
-        * Given a class name return the name for its composite id if it will have one.
-        * 
-        * @param className
-        * @return
-        */
-       public String classNameToCompositeIdName(String className);
-
-       
-       /** Return explicit which column name should be used for optimistic lock */
-       public String getOptimisticLockColumnName(TableIdentifier identifier);
-
-       public boolean useColumnForOptimisticLock(TableIdentifier identifier, String column);
-
-       /** 
-        * Return list of SchemaSelctors to be used when asking {@link MetaDataDialect} for metadata. 
-        * 
-        * @return list of {@link SchemaSelection} instances 
-        */
-       public List getSchemaSelections();
-
-       /**
-        * Given a table name, return the wanted name for the identifier. 
-        * @param tableIdentifier
-        * @return name to be used for identification
-        */
-       public String tableToIdentifierPropertyName(TableIdentifier tableIdentifier);
-
-       /**
-        * Given a table name, return the wanted name for a composite identifier.
-        * @param identifier
-        * @return
-        */
-       public String tableToCompositeIdName(TableIdentifier identifier);
-
-       /**
-        * Return the list of metaattributes to assign to classes created based on the given table 
-        * @param tableIdentifier
-        * @return a Map from String to {@link MetaAttribute}
-        */
-       public Map tableToMetaAttributes(TableIdentifier tableIdentifier);
-       
-       /**
-        * Return the list of metaattributes to assign to properties created based on the given column 
-        * @param tableIdentifier
-        * @param column
-        * @return a Map from String to {@link MetaAttribute}
-        */
-       public Map columnToMetaAttributes(TableIdentifier identifier, String column);
-       
-       /** Should this foreignkey be excluded as a oneToMany */
-       public boolean excludeForeignKeyAsCollection(String keyname, TableIdentifier fromTable, List fromColumns, TableIdentifier referencedTable, List referencedColumns);
-
-       /** Should this foreignkey be excluded as a many-to-one */
-       public boolean excludeForeignKeyAsManytoOne(String keyname, TableIdentifier fromTable, List fromColumns, TableIdentifier referencedTable, List referencedColumns);
-       
-       /** is the collection inverse or not ? */
-       public boolean isForeignKeyCollectionInverse(String name, TableIdentifier foreignKeyTable, List columns, TableIdentifier foreignKeyReferencedTable, List referencedColumns);
-       
-       /** is the collection lazy or not ? */
-       public boolean isForeignKeyCollectionLazy(String name, TableIdentifier foreignKeyTable, List columns, TableIdentifier foreignKeyReferencedTable, List referencedColumns);
-       
-    /**
-     * Return a collection role name for a Collection based on the foreignkey.
-     * @param fromColumns list of Column instances on the fromTable. Only col.getName() should be assumed to be correct 
-     * @param referencedColumns list of Column instances on the referenced Table. Only col.getName() should be assumed to be correct
-     * @param uniqueReference true if there is no other references to the same table
-     * @return
-     */
-    public String foreignKeyToCollectionName(String keyname, TableIdentifier fromTable, List fromColumns, TableIdentifier referencedTable, List referencedColumns, boolean uniqueReference);
-       
-    /**
-     * 
-     * @param fromColumns list of Column instances on the fromTable. Only col.getName() should be assumed to be correct 
-     * @param referencedColumns list of Column instances on the referenced Table. Only col.getName() should be assumed to be correct
-     * @param uniqueReference true if there is no other references to the same table
-     * @return
-     */
-    public String foreignKeyToEntityName(String keyname, TableIdentifier fromTable, List fromColumnNames, TableIdentifier referencedTable, List referencedColumnNames, boolean uniqueReference);
-
-       /**
-        * @param table
-        * @return true if this table is considered to be a many-to-many table.
-        */
-       public boolean isManyToManyTable(Table table);
-
-    /**
-     * 
-     * @param middleTable 
-     * @param uniqueReference true if there is no other references to the same table
-     * @param fromColumns list of Column instances on the fromTable. Only col.getName() should be assumed to be correct 
-     * @param referencedColumns list of Column instances on the referenced Table. Only col.getName() should be assumed to be correct
-     * @return
-     */
-    public String foreignKeyToManyToManyName(ForeignKey fromKey, TableIdentifier middleTable, ForeignKey toKey, boolean uniqueReference);
-
-       
-       
-       
-}
+package org.hibernate.cfg.reveng; 
+ 
+import org.hibernate.connection.ConnectionProvider; 
+import org.hibernate.exception.SQLExceptionConverter; 
+import org.hibernate.mapping.ForeignKey; 
+import org.hibernate.mapping.MetaAttribute; 
+import org.hibernate.mapping.Table; 
+ 
+import java.util.List; 
+import java.util.Map; 
+import java.util.Properties; 
+ 
+public interface ReverseEngineeringStrategy { 
+ 
+    /** 
+     * Generic method used to initialize the reverse engineering strategy. 
+     * 
+     * @param settings used for this 
+     */ 
+    public void setSettings(ReverseEngineeringSettings settings); 
+ 
+    /** 
+     * Configure the reverse engineering strategy. Called before reverse engineering commences. 
+     * <p/> 
+     * This is mainly for exotic strategies to get access to a connection. 
+     * 
+     * @param provider a connectionprovider. It is the responsibility of the metadatadialect to open/close any used connections via this provider. 
+     * @param sec      sqlexceptionConverter, use to convert any possible SQLExceptions. 
+     */ 
+    public void configure(ConnectionProvider provider, SQLExceptionConverter sec); 
+ 
+ 
+    /** 
+     * Close any resources this strategy might have used. Called after reverse engineering has been completed. 
+     */ 
+    public void close(); 
+ 
+    /** 
+     * @return a fully-qualified class name 
+     */ 
+    public String tableToClassName(TableIdentifier tableIdentifier); 
+ 
+    /** 
+     * Return a property name for a Column. 
+     * 
+     * @param column a columnname 
+     * @return a property name 
+     */ 
+    public String columnToPropertyName(TableIdentifier table, String column); 
+ 
+    public boolean excludeTable(TableIdentifier ti); 
+ 
+    public boolean excludeColumn(TableIdentifier identifier, String columnName); 
+ 
+    /** 
+     * Gets the preferred Hibernate type for an SQL type. 
+     * 
+     * @param table               name of the table, can be null 
+     * @param columnName          name of the column, can be null 
+     * @param sqlType             The sql type. 
+     * @param length              The length of the column. 
+     * @param precision           The number of decimal digits, if applicable. 
+     * @param scale               The scale, if applicable. 
+     * @param nullable            The nullability of the column 
+     * @param generatedIdentifier true if for a column used in an identifier that is not "assigned", false otherwise. 
+     * @return The Preferred hibernate type name. 
+     */ 
+    public String columnToHibernateTypeName(TableIdentifier table, String columnName, int sqlType, int length, int precision, int scale, boolean nullable, boolean generatedIdentifier); 
+ 
+    /** 
+     * Gets the user defined foreign keys. 
+     * 
+     * @param referencedTable TODO 
+     * @param identifier 
+     * @return a list of ForeignKey's 
+     */ 
+    public List getForeignKeys(TableIdentifier referencedTable); 
+ 
+    public String getTableIdentifierStrategyName(TableIdentifier identifier); 
+ 
+    public Properties getTableIdentifierProperties(TableIdentifier identifier); 
+ 
+    /** 
+     * If a table does not have any primarykey columns reported, this method is called. 
+     * 
+     * @return list of strings for each column name that is part of the primary key 
+     */ 
+    public List getPrimaryKeyColumnNames(TableIdentifier identifier); 
+ 
+    /** 
+     * Given a class name return the name for its composite id if it will have one. 
+     * 
+     * @param className 
+     * @return 
+     */ 
+    public String classNameToCompositeIdName(String className); 
+ 
+ 
+    /** 
+     * Return explicit which column name should be used for optimistic lock 
+     */ 
+    public String getOptimisticLockColumnName(TableIdentifier identifier); 
+ 
+    public boolean useColumnForOptimisticLock(TableIdentifier identifier, String column); 
+ 
+    /** 
+     * Return list of SchemaSelctors to be used when asking {@link MetaDataDialect} for metadata. 
+     * 
+     * @return list of {@link SchemaSelection} instances 
+     */ 
+    public List getSchemaSelections(); 
+ 
+    /** 
+     * Given a table name, return the wanted name for the identifier. 
+     * 
+     * @param tableIdentifier 
+     * @return name to be used for identification 
+     */ 
+    public String tableToIdentifierPropertyName(TableIdentifier tableIdentifier); 
+ 
+    /** 
+     * Given a table name, return the wanted name for a composite identifier. 
+     * 
+     * @param identifier 
+     * @return 
+     */ 
+    public String tableToCompositeIdName(TableIdentifier identifier); 
+ 
+    /** 
+     * Return the list of metaattributes to assign to classes created based on the given table 
+     * 
+     * @param tableIdentifier 
+     * @return a Map from String to {@link MetaAttribute} 
+     */ 
+    public Map tableToMetaAttributes(TableIdentifier tableIdentifier); 
+ 
+    /** 
+     * Return the list of metaattributes to assign to properties created based on the given column 
+     * 
+     * @param tableIdentifier 
+     * @param column 
+     * @return a Map from String to {@link MetaAttribute} 
+     */ 
+    public Map columnToMetaAttributes(TableIdentifier identifier, String column); 
+ 
+    /** 
+     * Should this foreignkey be excluded as a oneToMany 
+     */ 
+    public boolean excludeForeignKeyAsCollection(String keyname, TableIdentifier fromTable, List fromColumns, TableIdentifier referencedTable, List referencedColumns); 
+ 
+    /** 
+     * Should this foreignkey be excluded as a many-to-one 
+     */ 
+    public boolean excludeForeignKeyAsManytoOne(String keyname, TableIdentifier fromTable, List fromColumns, TableIdentifier referencedTable, List referencedColumns); 
+ 
+    /** 
+     * is the collection inverse or not ? 
+     */ 
+    public boolean isForeignKeyCollectionInverse(String name, TableIdentifier foreignKeyTable, List columns, TableIdentifier foreignKeyReferencedTable, List referencedColumns); 
+ 
+    /** 
+     * is the collection lazy or not ? 
+     */ 
+    public boolean isForeignKeyCollectionLazy(String name, TableIdentifier foreignKeyTable, List columns, TableIdentifier foreignKeyReferencedTable, List referencedColumns); 
+ 
+    /** 
+     * Return a collection role name for a Collection based on the foreignkey. 
+     * 
+     * @param fromColumns       list of Column instances on the fromTable. Only col.getName() should be assumed to be correct 
+     * @param referencedColumns list of Column instances on the referenced Table. Only col.getName() should be assumed to be correct 
+     * @param uniqueReference   true if there is no other references to the same table 
+     * @return 
+     */ 
+    public String foreignKeyToCollectionName(String keyname, TableIdentifier fromTable, List fromColumns, TableIdentifier referencedTable, List referencedColumns, boolean uniqueReference); 
+ 
+    /** 
+     * @param fromColumns       list of Column instances on the fromTable. Only col.getName() should be assumed to be correct 
+     * @param referencedColumns list of Column instances on the referenced Table. Only col.getName() should be assumed to be correct 
+     * @param uniqueReference   true if there is no other references to the same table 
+     * @return 
+     */ 
+    public String foreignKeyToEntityName(String keyname, TableIdentifier fromTable, List fromColumnNames, TableIdentifier referencedTable, List referencedColumnNames, boolean uniqueReference); 
+ 
+    /** 
+     * @param table 
+     * @return true if this table is considered to be a many-to-many table. 
+     */ 
+    public boolean isManyToManyTable(Table table); 
+ 
+    /** 
+     * @param middleTable 
+     * @param uniqueReference   true if there is no other references to the same table 
+     * @param fromColumns       list of Column instances on the fromTable. Only col.getName() should be assumed to be correct 
+     * @param referencedColumns list of Column instances on the referenced Table. Only col.getName() should be assumed to be correct 
+     * @return 
+     */ 
+    public String foreignKeyToManyToManyName(ForeignKey fromKey, TableIdentifier middleTable, ForeignKey toKey, boolean uniqueReference); 
+ 
+ 
+    /** 
+     * @param hibernateType The hibernate type that needs default values from DB if available 
+     * @return True or false depending on type. 
+     */ 
+    public boolean useDefaultValueOnHibernateType(String hibernateType); 
+ 
+    /** 
+     * @param table        Table identifier 
+     * @param columnName   Tne name of the column in the database 
+     * @param sqlType      The sql type of the column 
+     * @param isForeignKey True if the column is a FK 
+     * @param value        Value to be converted 
+     * @return A string containing the converted value. 
+     */ 
+    public String convertDefaultValueForColumn(TableIdentifier table, String columnName, String sqlTypeName, String hibernateTypeName, boolean isForeignKey, String value); 
+ 
+} 
Index: /media/hdb5/home/sorin/Projects/hibernate-tools/trunk/src/main/java/org/hibernate/cfg/reveng/DelegatingReverseEngineeringStrategy.java
===================================================================
--- /media/hdb5/home/sorin/Projects/hibernate-tools/trunk/src/main/java/org/hibernate/cfg/reveng/DelegatingReverseEngineeringStrategy.java      (revision 341)
+++ /media/hdb5/home/sorin/Projects/hibernate-tools/trunk/src/main/java/org/hibernate/cfg/reveng/DelegatingReverseEngineeringStrategy.java      (revision 328)
@@ -1,139 +1,147 @@
-package org.hibernate.cfg.reveng;
-
-import java.util.List;
-import java.util.Map;
-import java.util.Properties;
-
-import org.hibernate.connection.ConnectionProvider;
-import org.hibernate.exception.SQLExceptionConverter;
-import org.hibernate.mapping.ForeignKey;
-import org.hibernate.mapping.Table;
-
-public class DelegatingReverseEngineeringStrategy implements ReverseEngineeringStrategy {
-
-       ReverseEngineeringStrategy delegate;
-
-       public List getForeignKeys(TableIdentifier referencedTable) {
-              return delegate==null?null:delegate.getForeignKeys(referencedTable);
-       }
-
-       public DelegatingReverseEngineeringStrategy(ReverseEngineeringStrategy delegate) {
-              this.delegate = delegate;
-       }
-
-       public String columnToPropertyName(TableIdentifier table, String column) {
-              return delegate==null?null:delegate.columnToPropertyName(table, column);
-       }
-
-       public boolean excludeTable(TableIdentifier ti) {
-              return delegate==null?false:delegate.excludeTable(ti);
-       }
-       
-       public boolean excludeColumn(TableIdentifier identifier, String columnName) {
-              return delegate==null?false:delegate.excludeColumn(identifier, columnName);
-       }
-
-       public String foreignKeyToCollectionName(String keyname, TableIdentifier fromTable, List fromColumns, TableIdentifier referencedTable, List referencedColumns, boolean uniqueReference) {
-              return delegate==null?null:delegate.foreignKeyToCollectionName(keyname, fromTable, fromColumns, referencedTable, referencedColumns, uniqueReference);
-       }
-
-       public String foreignKeyToEntityName(String keyname, TableIdentifier fromTable, List fromColumnNames, TableIdentifier referencedTable, List referencedColumnNames, boolean uniqueReference) {
-              return delegate==null?null:delegate.foreignKeyToEntityName(keyname, fromTable, fromColumnNames, referencedTable, referencedColumnNames, uniqueReference);
-       }
-
-       public String columnToHibernateTypeName(TableIdentifier table, String columnName, int sqlType, int length, int precision, int scale, boolean nullable, boolean generatedIdentifier) {
-              return delegate==null?null:delegate.columnToHibernateTypeName(table, columnName, sqlType, length, precision, scale, nullable, generatedIdentifier);
-       }
-
-       public String tableToClassName(TableIdentifier tableIdentifier) {
-              return delegate==null?null:delegate.tableToClassName(tableIdentifier);
-       }
-
-       public String getTableIdentifierStrategyName(TableIdentifier tableIdentifier) {
-              return delegate==null?null:delegate.getTableIdentifierStrategyName(tableIdentifier);
-       }
-
-       public Properties getTableIdentifierProperties(TableIdentifier identifier) {
-              return delegate==null?null:delegate.getTableIdentifierProperties(identifier);
-       }
-
-       public List getPrimaryKeyColumnNames(TableIdentifier identifier) {
-              return delegate==null?null:delegate.getPrimaryKeyColumnNames(identifier);
-       }
-
-       public String classNameToCompositeIdName(String className) {
-              return delegate==null?null:delegate.classNameToCompositeIdName(className);
-       }
-
-       public void configure(ConnectionProvider provider, SQLExceptionConverter sec) {
-              if(delegate!=null) delegate.configure(provider,sec);          
-       }
-
-       public void close() {
-              if(delegate!=null) delegate.close();
-       }
-
-       public String getOptimisticLockColumnName(TableIdentifier identifier) {
-              return delegate==null?null:delegate.getOptimisticLockColumnName(identifier);          
-       }
-
-       public boolean useColumnForOptimisticLock(TableIdentifier identifier, String column) {
-              return delegate==null?false:delegate.useColumnForOptimisticLock(identifier, column);
-       }
-
-       public List getSchemaSelections() {
-              return delegate==null?null:delegate.getSchemaSelections();
-       }
-
-       public String tableToIdentifierPropertyName(TableIdentifier tableIdentifier) {
-              return delegate==null?null:delegate.tableToIdentifierPropertyName(tableIdentifier);
-       }
-
-       public String tableToCompositeIdName(TableIdentifier identifier) {
-              return delegate==null?null:delegate.tableToCompositeIdName(identifier);
-       }
-
-       public boolean excludeForeignKeyAsCollection(String keyname, TableIdentifier fromTable, List fromColumns, TableIdentifier referencedTable, List referencedColumns) {
-              return delegate==null?false:delegate.excludeForeignKeyAsCollection(keyname, fromTable, fromColumns, referencedTable, referencedColumns);
-       }
-
-       public boolean excludeForeignKeyAsManytoOne(String keyname, TableIdentifier fromTable, List fromColumns, TableIdentifier referencedTable, List referencedColumns) {
-              return delegate==null?false:delegate.excludeForeignKeyAsManytoOne(keyname, fromTable, fromColumns, referencedTable, referencedColumns);
-       }
-
-       public boolean isForeignKeyCollectionInverse(String name, TableIdentifier foreignKeyTable, List columns, TableIdentifier foreignKeyReferencedTable, List referencedColumns) {
-              return delegate==null?true:delegate.isForeignKeyCollectionInverse(name, foreignKeyTable, columns, foreignKeyReferencedTable, referencedColumns);
-       }
-
-       public boolean isForeignKeyCollectionLazy(String name, TableIdentifier foreignKeyTable, List columns, TableIdentifier foreignKeyReferencedTable, List referencedColumns) {
-              return delegate==null?true:delegate.isForeignKeyCollectionLazy(name, foreignKeyTable, columns, foreignKeyReferencedTable, referencedColumns);
-       }
-
-       /**
-        * Initialize the settings. 
-        * 
-        * If subclasses need to use the Settings then it should keep its own reference, but still remember to initialize the delegates settings by calling super.setSettings(settings).
-        * 
-        * @see ReverseEngineeringStrategy.setSettings
-        */
-       public void setSettings(ReverseEngineeringSettings settings) {
-              if(delegate!=null) delegate.setSettings(settings);
-       }
-
-       public boolean isManyToManyTable(Table table) {
-              return delegate==null?true:delegate.isManyToManyTable( table );
-       }
-
-       public String foreignKeyToManyToManyName(ForeignKey fromKey, TableIdentifier middleTable, ForeignKey toKey, boolean uniqueReference) {
-              return delegate==null?null:delegate.foreignKeyToManyToManyName( fromKey, middleTable, toKey, uniqueReference );
-       }
-
-       public Map tableToMetaAttributes(TableIdentifier tableIdentifier) {
-              return delegate==null?null:delegate.tableToMetaAttributes( tableIdentifier );         
-       }
-
-       public Map columnToMetaAttributes(TableIdentifier identifier, String column) {
-              return delegate==null?null:delegate.columnToMetaAttributes( identifier, column );
-       }
-       
-}
+package org.hibernate.cfg.reveng; 
+ 
+import org.hibernate.connection.ConnectionProvider; 
+import org.hibernate.exception.SQLExceptionConverter; 
+import org.hibernate.mapping.ForeignKey; 
+import org.hibernate.mapping.Table; 
+ 
+import java.util.List; 
+import java.util.Map; 
+import java.util.Properties; 
+ 
+public class DelegatingReverseEngineeringStrategy implements ReverseEngineeringStrategy { 
+ 
+    ReverseEngineeringStrategy delegate; 
+ 
+    public List getForeignKeys(TableIdentifier referencedTable) { 
+        return delegate == null ? null : delegate.getForeignKeys(referencedTable); 
+    } 
+ 
+    public DelegatingReverseEngineeringStrategy(ReverseEngineeringStrategy delegate) { 
+        this.delegate = delegate; 
+    } 
+ 
+    public String columnToPropertyName(TableIdentifier table, String column) { 
+        return delegate == null ? null : delegate.columnToPropertyName(table, column); 
+    } 
+ 
+    public boolean excludeTable(TableIdentifier ti) { 
+        return delegate == null ? false : delegate.excludeTable(ti); 
+    } 
+ 
+    public boolean excludeColumn(TableIdentifier identifier, String columnName) { 
+        return delegate == null ? false : delegate.excludeColumn(identifier, columnName); 
+    } 
+ 
+    public String foreignKeyToCollectionName(String keyname, TableIdentifier fromTable, List fromColumns, TableIdentifier referencedTable, List referencedColumns, boolean uniqueReference) { 
+        return delegate == null ? null : delegate.foreignKeyToCollectionName(keyname, fromTable, fromColumns, referencedTable, referencedColumns, uniqueReference); 
+    } 
+ 
+    public String foreignKeyToEntityName(String keyname, TableIdentifier fromTable, List fromColumnNames, TableIdentifier referencedTable, List referencedColumnNames, boolean uniqueReference) { 
+        return delegate == null ? null : delegate.foreignKeyToEntityName(keyname, fromTable, fromColumnNames, referencedTable, referencedColumnNames, uniqueReference); 
+    } 
+ 
+    public String columnToHibernateTypeName(TableIdentifier table, String columnName, int sqlType, int length, int precision, int scale, boolean nullable, boolean generatedIdentifier) { 
+        return delegate == null ? null : delegate.columnToHibernateTypeName(table, columnName, sqlType, length, precision, scale, nullable, generatedIdentifier); 
+    } 
+ 
+    public String tableToClassName(TableIdentifier tableIdentifier) { 
+        return delegate == null ? null : delegate.tableToClassName(tableIdentifier); 
+    } 
+ 
+    public String getTableIdentifierStrategyName(TableIdentifier tableIdentifier) { 
+        return delegate == null ? null : delegate.getTableIdentifierStrategyName(tableIdentifier); 
+    } 
+ 
+    public Properties getTableIdentifierProperties(TableIdentifier identifier) { 
+        return delegate == null ? null : delegate.getTableIdentifierProperties(identifier); 
+    } 
+ 
+    public List getPrimaryKeyColumnNames(TableIdentifier identifier) { 
+        return delegate == null ? null : delegate.getPrimaryKeyColumnNames(identifier); 
+    } 
+ 
+    public String classNameToCompositeIdName(String className) { 
+        return delegate == null ? null : delegate.classNameToCompositeIdName(className); 
+    } 
+ 
+    public void configure(ConnectionProvider provider, SQLExceptionConverter sec) { 
+        if (delegate != null) delegate.configure(provider, sec); 
+    } 
+ 
+    public void close() { 
+        if (delegate != null) delegate.close(); 
+    } 
+ 
+    public String getOptimisticLockColumnName(TableIdentifier identifier) { 
+        return delegate == null ? null : delegate.getOptimisticLockColumnName(identifier); 
+    } 
+ 
+    public boolean useColumnForOptimisticLock(TableIdentifier identifier, String column) { 
+        return delegate == null ? false : delegate.useColumnForOptimisticLock(identifier, column); 
+    } 
+ 
+    public List getSchemaSelections() { 
+        return delegate == null ? null : delegate.getSchemaSelections(); 
+    } 
+ 
+    public String tableToIdentifierPropertyName(TableIdentifier tableIdentifier) { 
+        return delegate == null ? null : delegate.tableToIdentifierPropertyName(tableIdentifier); 
+    } 
+ 
+    public String tableToCompositeIdName(TableIdentifier identifier) { 
+        return delegate == null ? null : delegate.tableToCompositeIdName(identifier); 
+    } 
+ 
+    public boolean excludeForeignKeyAsCollection(String keyname, TableIdentifier fromTable, List fromColumns, TableIdentifier referencedTable, List referencedColumns) { 
+        return delegate == null ? false : delegate.excludeForeignKeyAsCollection(keyname, fromTable, fromColumns, referencedTable, referencedColumns); 
+    } 
+ 
+    public boolean excludeForeignKeyAsManytoOne(String keyname, TableIdentifier fromTable, List fromColumns, TableIdentifier referencedTable, List referencedColumns) { 
+        return delegate == null ? false : delegate.excludeForeignKeyAsManytoOne(keyname, fromTable, fromColumns, referencedTable, referencedColumns); 
+    } 
+ 
+    public boolean isForeignKeyCollectionInverse(String name, TableIdentifier foreignKeyTable, List columns, TableIdentifier foreignKeyReferencedTable, List referencedColumns) { 
+        return delegate == null ? true : delegate.isForeignKeyCollectionInverse(name, foreignKeyTable, columns, foreignKeyReferencedTable, referencedColumns); 
+    } 
+ 
+    public boolean isForeignKeyCollectionLazy(String name, TableIdentifier foreignKeyTable, List columns, TableIdentifier foreignKeyReferencedTable, List referencedColumns) { 
+        return delegate == null ? true : delegate.isForeignKeyCollectionLazy(name, foreignKeyTable, columns, foreignKeyReferencedTable, referencedColumns); 
+    } 
+ 
+    /** 
+     * Initialize the settings. 
+     * <p/> 
+     * If subclasses need to use the Settings then it should keep its own reference, but still remember to initialize the delegates settings by calling super.setSettings(settings). 
+     * 
+     * @see ReverseEngineeringStrategy.setSettings 
+     */ 
+    public void setSettings(ReverseEngineeringSettings settings) { 
+        if (delegate != null) delegate.setSettings(settings); 
+    } 
+ 
+    public boolean isManyToManyTable(Table table) { 
+        return delegate == null ? true : delegate.isManyToManyTable(table); 
+    } 
+ 
+    public String foreignKeyToManyToManyName(ForeignKey fromKey, TableIdentifier middleTable, ForeignKey toKey, boolean uniqueReference) { 
+        return delegate == null ? null : delegate.foreignKeyToManyToManyName(fromKey, middleTable, toKey, uniqueReference); 
+    } 
+ 
+    public boolean useDefaultValueOnHibernateType(String hibernateType) { 
+        return false; 
+    } 
+ 
+    public String convertDefaultValueForColumn(TableIdentifier table, String columnName, String sqlTypeName, String hibernateTypeName, boolean isForeignKey, String value) { 
+        return ""; 
+    } 
+ 
+    public Map tableToMetaAttributes(TableIdentifier tableIdentifier) { 
+        return delegate == null ? null : delegate.tableToMetaAttributes(tableIdentifier); 
+    } 
+ 
+    public Map columnToMetaAttributes(TableIdentifier identifier, String column) { 
+        return delegate == null ? null : delegate.columnToMetaAttributes(identifier, column); 
+    } 
+ 
+} 
Index: /media/hdb5/home/sorin/Projects/hibernate-tools/trunk/src/main/java/org/hibernate/cfg/reveng/DefaultReverseEngineeringStrategy.java
===================================================================
--- /media/hdb5/home/sorin/Projects/hibernate-tools/trunk/src/main/java/org/hibernate/cfg/reveng/DefaultReverseEngineeringStrategy.java (revision 341)
+++ /media/hdb5/home/sorin/Projects/hibernate-tools/trunk/src/main/java/org/hibernate/cfg/reveng/DefaultReverseEngineeringStrategy.java (revision 328)
@@ -1,278 +1,279 @@
-package org.hibernate.cfg.reveng;
-
-import java.beans.Introspector;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Properties;
-import java.util.Set;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.hibernate.connection.ConnectionProvider;
-import org.hibernate.exception.SQLExceptionConverter;
-import org.hibernate.mapping.Column;
-import org.hibernate.mapping.ForeignKey;
-import org.hibernate.mapping.Table;
-import org.hibernate.util.StringHelper;
-
-public class DefaultReverseEngineeringStrategy implements ReverseEngineeringStrategy {
-
-       static final private Log log = LogFactory.getLog(DefaultReverseEngineeringStrategy.class);
-       
-       private static Set AUTO_OPTIMISTICLOCK_COLUMNS;
-
-       private ReverseEngineeringSettings settings = new ReverseEngineeringSettings(this);
-       static {
-              AUTO_OPTIMISTICLOCK_COLUMNS = new HashSet();
-              AUTO_OPTIMISTICLOCK_COLUMNS.add("version");
-              AUTO_OPTIMISTICLOCK_COLUMNS.add("timestamp");
-       }
-       
-              
-       public DefaultReverseEngineeringStrategy() {
-              super();
-       }
-       
-       public String columnToPropertyName(TableIdentifier table, String columnName) {
-              String decapitalize = Introspector.decapitalize( toUpperCamelCase(columnName) );
-              
-              return keywordCheck( decapitalize );
-       }
-
-       private String keywordCheck(String possibleKeyword) {
-              if(ReverseEngineeringStrategyUtil.isReservedJavaKeyword(possibleKeyword)) {
-                     possibleKeyword = possibleKeyword + "_";
-              }
-              return possibleKeyword;
-       }
-       
-       protected String toUpperCamelCase(String s) {
-              return ReverseEngineeringStrategyUtil.toUpperCamelCase(s);
-       }
-       
-       /**
-        * Does some crude english pluralization
-        * TODO: are the from/to names correct ?
-        */
-    public String foreignKeyToCollectionName(String keyname, TableIdentifier fromTable, List fromColumns, TableIdentifier referencedTable, List referencedColumns, boolean uniqueReference) {
-              String propertyName = Introspector.decapitalize( StringHelper.unqualify( getRoot().tableToClassName(fromTable) ) );
-              propertyName = pluralize( propertyName );
-              
-              if(!uniqueReference) {
-               if(fromColumns!=null && fromColumns.size()==1) {
-                      String columnName = ( (Column) fromColumns.get(0) ).getName();
-                      propertyName = propertyName + "For" + toUpperCamelCase(columnName);
-               } 
-               else { // composite key or no columns at all safeguard
-                      propertyName = propertyName + "For" + toUpperCamelCase(keyname); 
-               }
-        }
-        return propertyName;
-    }
-
-       protected String pluralize(String singular) {
-              return ReverseEngineeringStrategyUtil.simplePluralize(singular);
-       }
-
-    public String foreignKeyToEntityName(String keyname, TableIdentifier fromTable, List fromColumnNames, TableIdentifier referencedTable, List referencedColumnNames, boolean uniqueReference) {
-        String propertyName = Introspector.decapitalize( StringHelper.unqualify( getRoot().tableToClassName(referencedTable) ) );
-        
-        if(!uniqueReference) {
-               if(fromColumnNames!=null && fromColumnNames.size()==1) {
-                      String columnName = ( (Column) fromColumnNames.get(0) ).getName();
-                      propertyName = propertyName + "By" + toUpperCamelCase(columnName);
-               } 
-               else { // composite key or no columns at all safeguard
-                      propertyName = propertyName + "By" + toUpperCamelCase(keyname); 
-               }
-        }
-        
-        return propertyName;
-    }
-       
-       public String columnToHibernateTypeName(TableIdentifier table, String columnName, int sqlType, int length, int precision, int scale, boolean nullable, boolean generatedIdentifier) {
-              String preferredHibernateType = JDBCToHibernateTypeHelper.getPreferredHibernateType(sqlType, length, precision, scale, nullable, generatedIdentifier);
-              
-              String location = "<no info>";
-              if(log.isDebugEnabled()) {
-                     String info = " t:" + JDBCToHibernateTypeHelper.getJDBCTypeName( sqlType ) + " l:" + length + " p:" + precision + " s:" + scale + " n:" + nullable + " id:" + generatedIdentifier;
-                     if(table!=null) {
-                            location = Table.qualify(table.getCatalog(), table.getSchema(), table.getName() ) + "." + columnName + info;
-                     } else {
-                            
-                            location += " Column: " + columnName + info;
-                     }                    
-              }
-              if(preferredHibernateType==null) {
-                     log.debug("No default type found for [" + location + "] falling back to [serializable]");
-                     return "serializable";
-              } else {
-                     log.debug("Default type found for [" + location + "] to [" + preferredHibernateType + "]");           
-                     return preferredHibernateType;
-              }             
-       }
-
-       public boolean excludeTable(TableIdentifier ti) {
-              if(ti.getName().startsWith("BIN$")) return true; // hard code oracle recycle bin names. Better than requiring users to do it manually. TODO: make it dependent on dialect.
-              return false;
-       }
-       
-       public boolean excludeColumn(TableIdentifier identifier, String columnName) {
-              return false;
-       }
-
-       public String tableToClassName(TableIdentifier tableIdentifier) {
-              
-              String pkgName = settings.getDefaultPackageName();
-              String className = toUpperCamelCase( tableIdentifier.getName() );
-              
-              if(pkgName.length()>0) {                     
-                     return StringHelper.qualify(pkgName, className);
-              }
-              else {
-                     return className;
-              }
-              
-       }
-
-       public List getForeignKeys(TableIdentifier referencedTable) {
-              return Collections.EMPTY_LIST;
-       }
-
-       public String getTableIdentifierStrategyName(TableIdentifier identifier) {
-              return "assigned";
-       }
-
-       public Properties getTableIdentifierProperties(TableIdentifier identifier) {
-              return null;
-       }
-
-       public List getPrimaryKeyColumnNames(TableIdentifier identifier) {
-              return null;
-       }
-
-       public String classNameToCompositeIdName(String className) {
-              return className + "Id"; 
-       }
-
-       public void configure(ConnectionProvider provider, SQLExceptionConverter sec) {
-              // noop               
-       }
-
-       public void close() {
-              // noop               
-       }
-
-       /** Return explicit which column name should be used for optimistic lock */
-       public String getOptimisticLockColumnName(TableIdentifier identifier) {
-              return null;
-       }
-
-       public boolean useColumnForOptimisticLock(TableIdentifier identifier, String column) {
-              if(settings.getDetectOptimsticLock()) {
-                     return AUTO_OPTIMISTICLOCK_COLUMNS.contains(column.toLowerCase())?true:false;
-              } else {
-                     return false;
-              }
-       }
-
-       public List getSchemaSelections() {
-              return null;
-       }
-
-       public String tableToIdentifierPropertyName(TableIdentifier tableIdentifier) {
-              return null;
-       }
-
-       public String tableToCompositeIdName(TableIdentifier identifier) {
-              return null;
-       }
-
-       public boolean excludeForeignKeyAsCollection(String keyname, TableIdentifier fromTable, List fromColumns, TableIdentifier referencedTable, List referencedColumns) {
-              return !settings.createCollectionForForeignKey();             
-       }
-
-       public boolean excludeForeignKeyAsManytoOne(String keyname, TableIdentifier fromTable, List fromColumns, TableIdentifier referencedTable, List referencedColumns) {
-              return !settings.createManyToOneForForeignKey();
-       }
-
-       public boolean isForeignKeyCollectionInverse(String name, TableIdentifier foreignKeyTable, List columns, TableIdentifier foreignKeyReferencedTable, List referencedColumns) {
-              return true;
-       }
-
-       public boolean isForeignKeyCollectionLazy(String name, TableIdentifier foreignKeyTable, List columns, TableIdentifier foreignKeyReferencedTable, List referencedColumns) {
-              return true;
-       }
-
-       public void setSettings(ReverseEngineeringSettings settings) {
-              this.settings = settings;             
-       }
-
-       public boolean isManyToManyTable(Table table) {
-              if(settings.getDetectManyToMany()) {
-                     Iterator foreignKeyIterator = table.getForeignKeyIterator();
-                     List foreignKeys = new ArrayList();
-                     while ( foreignKeyIterator.hasNext() ) {
-                            ForeignKey fkey = (ForeignKey) foreignKeyIterator.next();
-                            foreignKeys.add( fkey );
-                            if(foreignKeys.size()>2) {
-                                   return false; // early exit if we have more than two fk.
-                            }
-                     }
-                     if(foreignKeys.size()!=2) {
-                            return false;
-                     }
-                     
-                     Set columns = new HashSet();
-                     Iterator columnIterator = table.getColumnIterator();
-                     while ( columnIterator.hasNext() ) {
-                            Column column = (Column) columnIterator.next();
-                            columns.add(column);
-                     }
-              
-                     foreignKeyIterator = table.getForeignKeyIterator();
-                     while ( !columns.isEmpty() && foreignKeyIterator.hasNext() ) {
-                            ForeignKey element = (ForeignKey) foreignKeyIterator.next();                        
-                            columns.removeAll( element.getColumns() );                          
-                     }
-                     // what if one of the columns is not the primary key?
-                     return columns.isEmpty();
-              } else {
-                     return false;
-              }
-       }
-
-       protected ReverseEngineeringStrategy getRoot() {
-              return settings.getRootStrategy();
-       }
-       
-       public String foreignKeyToManyToManyName(ForeignKey fromKey, TableIdentifier middleTable, ForeignKey toKey, boolean uniqueReference) {
-              String propertyName = Introspector.decapitalize( StringHelper.unqualify( getRoot().tableToClassName(TableIdentifier.create( toKey.getReferencedTable()) )) );
-              propertyName = pluralize( propertyName );
-              
-              if(!uniqueReference) {
-                     //TODO: maybe use the middleTable name here ?
-               if(toKey.getColumns()!=null && toKey.getColumns().size()==1) {
-                      String columnName = ( (Column) toKey.getColumns().get(0) ).getName();
-                      propertyName = propertyName + "For" + toUpperCamelCase(columnName);
-               } 
-               else { // composite key or no columns at all safeguard
-                      propertyName = propertyName + "For" + toUpperCamelCase(toKey.getName()); 
-               }
-        }
-        return propertyName;      
-       }
-
-       public Map tableToMetaAttributes(TableIdentifier tableIdentifier) {
-              return null;
-       }
-
-       public Map columnToMetaAttributes(TableIdentifier identifier, String column) {
-              return null;
-       }
-       
-}
+package org.hibernate.cfg.reveng; 
+ 
+import org.apache.commons.logging.Log; 
+import org.apache.commons.logging.LogFactory; 
+import org.hibernate.connection.ConnectionProvider; 
+import org.hibernate.exception.SQLExceptionConverter; 
+import org.hibernate.mapping.Column; 
+import org.hibernate.mapping.ForeignKey; 
+import org.hibernate.mapping.Table; 
+import org.hibernate.util.StringHelper; 
+ 
+import java.beans.Introspector; 
+import java.util.*; 
+ 
+public class DefaultReverseEngineeringStrategy implements ReverseEngineeringStrategy { 
+ 
+    static final private Log log = LogFactory.getLog(DefaultReverseEngineeringStrategy.class); 
+ 
+    private static Set AUTO_OPTIMISTICLOCK_COLUMNS; 
+ 
+    private ReverseEngineeringSettings settings = new ReverseEngineeringSettings(this); 
+ 
+    static { 
+        AUTO_OPTIMISTICLOCK_COLUMNS = new HashSet(); 
+        AUTO_OPTIMISTICLOCK_COLUMNS.add("version"); 
+        AUTO_OPTIMISTICLOCK_COLUMNS.add("timestamp"); 
+    } 
+ 
+ 
+    public DefaultReverseEngineeringStrategy() { 
+        super(); 
+    } 
+ 
+    public String columnToPropertyName(TableIdentifier table, String columnName) { 
+        String decapitalize = Introspector.decapitalize(toUpperCamelCase(columnName)); 
+ 
+        return keywordCheck(decapitalize); 
+    } 
+ 
+    private String keywordCheck(String possibleKeyword) { 
+        if (ReverseEngineeringStrategyUtil.isReservedJavaKeyword(possibleKeyword)) { 
+            possibleKeyword = possibleKeyword + "_"; 
+        } 
+        return possibleKeyword; 
+    } 
+ 
+    protected String toUpperCamelCase(String s) { 
+        return ReverseEngineeringStrategyUtil.toUpperCamelCase(s); 
+    } 
+ 
+    /** 
+     * Does some crude english pluralization 
+     * TODO: are the from/to names correct ? 
+     */ 
+    public String foreignKeyToCollectionName(String keyname, TableIdentifier fromTable, List fromColumns, TableIdentifier referencedTable, List referencedColumns, boolean uniqueReference) { 
+        String propertyName = Introspector.decapitalize(StringHelper.unqualify(getRoot().tableToClassName(fromTable))); 
+        propertyName = pluralize(propertyName); 
+ 
+        if (!uniqueReference) { 
+            if (fromColumns != null && fromColumns.size() == 1) { 
+                String columnName = ((Column) fromColumns.get(0)).getName(); 
+                propertyName = propertyName + "For" + toUpperCamelCase(columnName); 
+            } else { // composite key or no columns at all safeguard 
+                propertyName = propertyName + "For" + toUpperCamelCase(keyname); 
+            } 
+        } 
+        return propertyName; 
+    } 
+ 
+    protected String pluralize(String singular) { 
+        return ReverseEngineeringStrategyUtil.simplePluralize(singular); 
+    } 
+ 
+    public String foreignKeyToEntityName(String keyname, TableIdentifier fromTable, List fromColumnNames, TableIdentifier referencedTable, List referencedColumnNames, boolean uniqueReference) { 
+        String propertyName = Introspector.decapitalize(StringHelper.unqualify(getRoot().tableToClassName(referencedTable))); 
+ 
+        if (!uniqueReference) { 
+            if (fromColumnNames != null && fromColumnNames.size() == 1) { 
+                String columnName = ((Column) fromColumnNames.get(0)).getName(); 
+                propertyName = propertyName + "By" + toUpperCamelCase(columnName); 
+            } else { // composite key or no columns at all safeguard 
+                propertyName = propertyName + "By" + toUpperCamelCase(keyname); 
+            } 
+        } 
+ 
+        return propertyName; 
+    } 
+ 
+    public String columnToHibernateTypeName(TableIdentifier table, String columnName, int sqlType, int length, int precision, int scale, boolean nullable, boolean generatedIdentifier) { 
+        String preferredHibernateType = JDBCToHibernateTypeHelper.getPreferredHibernateType(sqlType, length, precision, scale, nullable, generatedIdentifier); 
+ 
+        String location = "<no info>"; 
+        if (log.isDebugEnabled()) { 
+            String info = " t:" + JDBCToHibernateTypeHelper.getJDBCTypeName(sqlType) + " l:" + length + " p:" + precision + " s:" + scale + " n:" + nullable + " id:" + generatedIdentifier; 
+            if (table != null) { 
+                location = Table.qualify(table.getCatalog(), table.getSchema(), table.getName()) + "." + columnName + info; 
+            } else { 
+ 
+                location += " Column: " + columnName + info; 
+            } 
+        } 
+        if (preferredHibernateType == null) { 
+            log.debug("No default type found for [" + location + "] falling back to [serializable]"); 
+            return "serializable"; 
+        } else { 
+            log.debug("Default type found for [" + location + "] to [" + preferredHibernateType + "]"); 
+            return preferredHibernateType; 
+        } 
+    } 
+ 
+    public boolean excludeTable(TableIdentifier ti) { 
+        if (ti.getName().startsWith("BIN$")) 
+            return true; // hard code oracle recycle bin names. Better than requiring users to do it manually. TODO: make it dependent on dialect. 
+        return false; 
+    } 
+ 
+    public boolean excludeColumn(TableIdentifier identifier, String columnName) { 
+        return false; 
+    } 
+ 
+    public String tableToClassName(TableIdentifier tableIdentifier) { 
+ 
+        String pkgName = settings.getDefaultPackageName(); 
+        String className = toUpperCamelCase(tableIdentifier.getName()); 
+ 
+        if (pkgName.length() > 0) { 
+            return StringHelper.qualify(pkgName, className); 
+        } else { 
+            return className; 
+        } 
+ 
+    } 
+ 
+    public List getForeignKeys(TableIdentifier referencedTable) { 
+        return Collections.EMPTY_LIST; 
+    } 
+ 
+    public String getTableIdentifierStrategyName(TableIdentifier identifier) { 
+        return "assigned"; 
+    } 
+ 
+    public Properties getTableIdentifierProperties(TableIdentifier identifier) { 
+        return null; 
+    } 
+ 
+    public List getPrimaryKeyColumnNames(TableIdentifier identifier) { 
+        return null; 
+    } 
+ 
+    public String classNameToCompositeIdName(String className) { 
+        return className + "Id"; 
+    } 
+ 
+    public void configure(ConnectionProvider provider, SQLExceptionConverter sec) { 
+        // noop 
+    } 
+ 
+    public void close() { 
+        // noop 
+    } 
+ 
+    /** 
+     * Return explicit which column name should be used for optimistic lock 
+     */ 
+    public String getOptimisticLockColumnName(TableIdentifier identifier) { 
+        return null; 
+    } 
+ 
+    public boolean useColumnForOptimisticLock(TableIdentifier identifier, String column) { 
+        if (settings.getDetectOptimsticLock()) { 
+            return AUTO_OPTIMISTICLOCK_COLUMNS.contains(column.toLowerCase()) ? true : false; 
+        } else { 
+            return false; 
+        } 
+    } 
+ 
+    public List getSchemaSelections() { 
+        return null; 
+    } 
+ 
+    public String tableToIdentifierPropertyName(TableIdentifier tableIdentifier) { 
+        return null; 
+    } 
+ 
+    public String tableToCompositeIdName(TableIdentifier identifier) { 
+        return null; 
+    } 
+ 
+    public boolean excludeForeignKeyAsCollection(String keyname, TableIdentifier fromTable, List fromColumns, TableIdentifier referencedTable, List referencedColumns) { 
+        return !settings.createCollectionForForeignKey(); 
+    } 
+ 
+    public boolean excludeForeignKeyAsManytoOne(String keyname, TableIdentifier fromTable, List fromColumns, TableIdentifier referencedTable, List referencedColumns) { 
+        return !settings.createManyToOneForForeignKey(); 
+    } 
+ 
+    public boolean isForeignKeyCollectionInverse(String name, TableIdentifier foreignKeyTable, List columns, TableIdentifier foreignKeyReferencedTable, List referencedColumns) { 
+        return true; 
+    } 
+ 
+    public boolean isForeignKeyCollectionLazy(String name, TableIdentifier foreignKeyTable, List columns, TableIdentifier foreignKeyReferencedTable, List referencedColumns) { 
+        return true; 
+    } 
+ 
+    public void setSettings(ReverseEngineeringSettings settings) { 
+        this.settings = settings; 
+    } 
+ 
+    public boolean isManyToManyTable(Table table) { 
+        if (settings.getDetectManyToMany()) { 
+            Iterator foreignKeyIterator = table.getForeignKeyIterator(); 
+            List foreignKeys = new ArrayList(); 
+            while (foreignKeyIterator.hasNext()) { 
+                ForeignKey fkey = (ForeignKey) foreignKeyIterator.next(); 
+                foreignKeys.add(fkey); 
+                if (foreignKeys.size() > 2) { 
+                    return false; // early exit if we have more than two fk. 
+                } 
+            } 
+            if (foreignKeys.size() != 2) { 
+                return false; 
+            } 
+ 
+            Set columns = new HashSet(); 
+            Iterator columnIterator = table.getColumnIterator(); 
+            while (columnIterator.hasNext()) { 
+                Column column = (Column) columnIterator.next(); 
+                columns.add(column); 
+            } 
+ 
+            foreignKeyIterator = table.getForeignKeyIterator(); 
+            while (!columns.isEmpty() && foreignKeyIterator.hasNext()) { 
+                ForeignKey element = (ForeignKey) foreignKeyIterator.next(); 
+                columns.removeAll(element.getColumns()); 
+            } 
+            // what if one of the columns is not the primary key? 
+            return columns.isEmpty(); 
+        } else { 
+            return false; 
+        } 
+    } 
+ 
+    protected ReverseEngineeringStrategy getRoot() { 
+        return settings.getRootStrategy(); 
+    } 
+ 
+    public String foreignKeyToManyToManyName(ForeignKey fromKey, TableIdentifier middleTable, ForeignKey toKey, boolean uniqueReference) { 
+        String propertyName = Introspector.decapitalize(StringHelper.unqualify(getRoot().tableToClassName(TableIdentifier.create(toKey.getReferencedTable())))); 
+        propertyName = pluralize(propertyName); 
+ 
+        if (!uniqueReference) { 
+            //TODO: maybe use the middleTable name here ? 
+            if (toKey.getColumns() != null && toKey.getColumns().size() == 1) { 
+                String columnName = ((Column) toKey.getColumns().get(0)).getName(); 
+                propertyName = propertyName + "For" + toUpperCamelCase(columnName); 
+            } else { // composite key or no columns at all safeguard 
+                propertyName = propertyName + "For" + toUpperCamelCase(toKey.getName()); 
+            } 
+        } 
+        return propertyName; 
+    } 
+ 
+    public boolean useDefaultValueOnHibernateType(String hibernateType) { 
+        return false; 
+    } 
+ 
+    public String convertDefaultValueForColumn(TableIdentifier table, String columnName, String sqlTypeName, String hibernateTypeName, boolean isForeignKey, String value) { 
+        return ""; 
+    } 
+ 
+    public Map tableToMetaAttributes(TableIdentifier tableIdentifier) { 
+        return null; 
+    } 
+ 
+    public Map columnToMetaAttributes(TableIdentifier identifier, String column) { 
+        return null; 
+    } 
+ 
+} 
Index: /media/hdb5/home/sorin/Projects/hibernate-tools/trunk/src/main/java/org/hibernate/tool/hbm2x/pojo/BasicPOJOClass.java
===================================================================
--- /media/hdb5/home/sorin/Projects/hibernate-tools/trunk/src/main/java/org/hibernate/tool/hbm2x/pojo/BasicPOJOClass.java       (revision 341)
+++ /media/hdb5/home/sorin/Projects/hibernate-tools/trunk/src/main/java/org/hibernate/tool/hbm2x/pojo/BasicPOJOClass.java       (revision 328)
@@ -1,878 +1,851 @@
 package org.hibernate.tool.hbm2x.pojo;
 
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
 import org.hibernate.cfg.reveng.ReverseEngineeringStrategyUtil;
 import org.hibernate.mapping.Collection;
-import org.hibernate.mapping.Column;
-import org.hibernate.mapping.Component;
-import org.hibernate.mapping.MetaAttributable;
-import org.hibernate.mapping.MetaAttribute;
-import org.hibernate.mapping.Property;
-import org.hibernate.mapping.PropertyGeneration;
-import org.hibernate.mapping.Selectable;
-import org.hibernate.mapping.SimpleValue;
-import org.hibernate.mapping.Value;
+import org.hibernate.mapping.*;
 import org.hibernate.tool.hbm2x.Cfg2JavaTool;
 import org.hibernate.tool.hbm2x.MetaAttributeConstants;
 import org.hibernate.tool.hbm2x.MetaAttributeHelper;
 import org.hibernate.util.StringHelper;
 
+import java.util.*;
+import java.util.List;
+import java.util.Map;
+
 /**
  * Abstract implementation of POJOClass. To be extended by ComponentPOJO and EntityPOJO
+ *
  * @author max
  * @author <a href="mailto:abhayani@jboss.org">Amit Bhayani</a>
- *
  */
 abstract public class BasicPOJOClass implements POJOClass, MetaAttributeConstants {
 
-       protected ImportContext importContext;
-       protected MetaAttributable meta;
-       protected final Cfg2JavaTool c2j;
-       
-       public BasicPOJOClass(MetaAttributable ma, Cfg2JavaTool c2j) {
-              this.meta = ma;
-              this.c2j = c2j;               
-              
-              if(this.meta==null) {
-                     throw new IllegalArgumentException("class Argument must be not null");
-              }
-              if(this.c2j==null) throw new IllegalArgumentException("c2j must be not null");
-       }
-       
-       // called by subclasses
-       protected void init() {
-              importContext = new ImportContextImpl(getPackageName());
-              
-              MetaAttribute metaAttribute = meta.getMetaAttribute("extra-import");
-              if(metaAttribute!=null) {
-                     Iterator values = metaAttribute.getValues().iterator();
-                     while ( values.hasNext() ) {
-                            String element = (String) values.next();
-                            importContext.importType(element);                          
-                     }
-              }      
-       }
-       
-       protected String getPackageDeclaration(String pkgName) {
-              if (pkgName!=null && pkgName.trim().length()!=0 ) {
-                     return "package " + pkgName + ";";
-              } 
-              else {        
-                     return "// default package";
-              }
-       }
+    private static final Log log = LogFactory.getLog(BasicPOJOClass.class);
 
-       public String getPackageDeclaration() {
-              String pkgName = getPackageName();
-              return getPackageDeclaration(pkgName);               
-       }
+    protected ImportContext importContext;
+    protected MetaAttributable meta;
+    protected final Cfg2JavaTool c2j;
 
-       /** Return package name. Note: Does not handle inner classes */ 
-       public String getPackageName() {
-              String generatedClass = getGeneratedClassName();
-              return StringHelper.qualifier(generatedClass.trim());
-       }
-       
-       public String getShortName() {
-              return qualifyInnerClass(StringHelper.unqualify(getMappedClassName()));
-       }
-       
-       public String getQualifiedDeclarationName() {
-              String generatedName = qualifyInnerClass(getGeneratedClassName());
-              String qualifier = StringHelper.qualifier( getMappedClassName() );
-              if ( "".equals( qualifier ) ) {
-                     return qualifier + "." + generatedName;
-              }
-              else {
-                     return generatedName;
-              }
-       }
-       
-       /**
-        * @return unqualified classname for this class (can be changed by meta attribute "generated-class")
-        */
-       public String getDeclarationName() {
-              return qualifyInnerClass(StringHelper.unqualify( getGeneratedClassName() ));
-       }
-       
-       protected String getGeneratedClassName()
-       {
-              String generatedClass = getMetaAsString(MetaAttributeConstants.GENERATED_CLASS).trim();
-              if(StringHelper.isEmpty(generatedClass) ) {
-                     generatedClass = getMappedClassName();
-              }
-              if(generatedClass==null) return ""; // will occur for <dynamic-component>
-              return generatedClass;
-       }
-       
-       protected String qualifyInnerClass(String className)
-       {
-              return className.replace('$', '.');
-       }
-       
-       protected abstract String getMappedClassName();
+    public BasicPOJOClass(MetaAttributable ma, Cfg2JavaTool c2j) {
+        this.meta = ma;
+        this.c2j = c2j;
 
-       public String getMetaAsString(String attribute) {
-              MetaAttribute c = meta.getMetaAttribute( attribute );
-              return MetaAttributeHelper.getMetaAsString( c );
-       }
+        if (this.meta == null) {
+            throw new IllegalArgumentException("class Argument must be not null");
+        }
+        if (this.c2j == null) throw new IllegalArgumentException("c2j must be not null");
+    }
 
-       public boolean hasMetaAttribute(String attribute) {
-              return meta.getMetaAttribute( attribute ) != null;
-       }
+    // called by subclasses
+    protected void init() {
+        importContext = new ImportContextImpl(getPackageName());
 
-       public String getMetaAsString(String attribute, String seperator) {
-              return MetaAttributeHelper.getMetaAsString( meta.getMetaAttribute( attribute ), seperator );
-       }
+        MetaAttribute metaAttribute = meta.getMetaAttribute("extra-import");
+        if (metaAttribute != null) {
+            Iterator values = metaAttribute.getValues().iterator();
+            while (values.hasNext()) {
+                String element = (String) values.next();
+                importContext.importType(element);
+            }
+        }
+    }
 
-       public boolean getMetaAsBool(String attribute) {
-              return getMetaAsBool( attribute, false );
-       }
+    protected String getPackageDeclaration(String pkgName) {
+        if (pkgName != null && pkgName.trim().length() != 0) {
+            return "package " + pkgName + ";";
+        } else {
+            return "// default package";
+        }
+    }
 
-       public boolean getMetaAsBool(String attribute, boolean defaultValue) {
-              return MetaAttributeHelper.getMetaAsBool( meta.getMetaAttribute( attribute ), defaultValue );
-       }
+    public String getPackageDeclaration() {
+        String pkgName = getPackageName();
+        return getPackageDeclaration(pkgName);
+    }
 
-       public String getClassJavaDoc(String fallback, int indent) {
-              MetaAttribute c = meta.getMetaAttribute( CLASS_DESCRIPTION );
-              if ( c == null ) {
-                     return c2j.toJavaDoc( fallback, indent );
-              }
-              else {
-                     return c2j.toJavaDoc( getMetaAsString( CLASS_DESCRIPTION ), indent );
-              }
-       }
-       
-       public String getClassModifiers() {
-              String classModifiers = null;
+    /**
+     * Return package name. Note: Does not handle inner classes
+     */
+    public String getPackageName() {
+        String generatedClass = getGeneratedClassName();
+        return StringHelper.qualifier(generatedClass.trim());
+    }
 
-              // Get scope (backwards compatibility)
-              if ( meta.getMetaAttribute( SCOPE_CLASS ) != null ) {
-                     classModifiers = getMetaAsString( SCOPE_CLASS ).trim();
-              }
+    public String getShortName() {
+        return qualifyInnerClass(StringHelper.unqualify(getMappedClassName()));
+    }
 
-              // Get modifiers
-              if ( meta.getMetaAttribute( CLASS_MODIFIER ) != null ) {
-                     classModifiers = getMetaAsString( CLASS_MODIFIER ).trim();
-              }
-              return classModifiers == null ? "public" : classModifiers;
-       }
+    public String getQualifiedDeclarationName() {
+        String generatedName = qualifyInnerClass(getGeneratedClassName());
+        String qualifier = StringHelper.qualifier(getMappedClassName());
+        if ("".equals(qualifier)) {
+            return qualifier + "." + generatedName;
+        } else {
+            return generatedName;
+        }
+    }
 
-       public String getDeclarationType() {
-              boolean isInterface = isInterface();
-              if ( isInterface ) {
-                     return INTERFACE;
-              }
-              else {
-                     return "class";
-              }
-       }
-       
-       public boolean isInterface() {
-              return getMetaAsBool( INTERFACE );
-       }
-       
-       public String getExtendsDeclaration() {
-              String extendz = getExtends();
-              if ( extendz == null || extendz.trim().length() == 0 ) {
-                     return "";
-              }
-              else {
-                     return "extends " + extendz;
-              }
-       }
+    /**
+     * @return unqualified classname for this class (can be changed by meta attribute "generated-class")
+     */
+    public String getDeclarationName() {
+        return qualifyInnerClass(StringHelper.unqualify(getGeneratedClassName()));
+    }
 
-       public String getImplementsDeclaration() {
-              String implementz = getImplements();
-              if ( implementz == null || implementz.trim().length() == 0 ) {
-                     return "";
-              }
-              else {
-                     return "implements " + implementz;
-              }
-       }
-       
-       public String generateEquals(String thisName, String otherName, boolean useGenerics) {
-              Iterator allPropertiesIterator = getEqualsHashCodePropertiesIterator();
-              return generateEquals( thisName, otherName, allPropertiesIterator, useGenerics );
-       }
-       
-       public abstract Iterator getAllPropertiesIterator();
+    protected String getGeneratedClassName() {
+        String generatedClass = getMetaAsString(MetaAttributeConstants.GENERATED_CLASS).trim();
+        if (StringHelper.isEmpty(generatedClass)) {
+            generatedClass = getMappedClassName();
+        }
+        if (generatedClass == null) return ""; // will occur for <dynamic-component>
+        return generatedClass;
+    }
 
-       protected String generateEquals(String thisName, String otherName, Iterator allPropertiesIterator, boolean useGenerics) {
-              StringBuffer buf = new StringBuffer();
-              while ( allPropertiesIterator.hasNext() ) {
-                     Property property = (Property) allPropertiesIterator.next();
-                            if ( buf.length() > 0 ) buf.append( "\n && " );
-                            String javaTypeName = c2j.getJavaTypeName( property, useGenerics, this );
-                            buf.append(
-                                          internalgenerateEquals(
-                                                        javaTypeName, thisName + "." + getGetterSignature( property ) + "()",
-                                                        otherName + "." + getGetterSignature( property ) + "()")
-                            );                   
-              }
+    protected String qualifyInnerClass(String className) {
+        return className.replace('$', '.');
+    }
 
-              if ( buf.length() == 0 ) {
-                     return "false";
-              }
-              else {
-                     return buf.toString();
-              }
-       }
+    protected abstract String getMappedClassName();
 
-       private boolean usePropertyInEquals(Property property) {
-              boolean hasEqualsMetaAttribute = c2j.hasMetaAttribute(property, "use-in-equals");             
-              boolean useInEquals = c2j.getMetaAsBool( property, "use-in-equals" );
-              
-              if(property.isNaturalIdentifier()) {
-                     if(hasEqualsMetaAttribute && !useInEquals) {
-                            return false;
-                     } else {
-                            return true;
-                     }
-              } 
-              
-              return useInEquals;
-       }
+    public String getMetaAsString(String attribute) {
+        MetaAttribute c = meta.getMetaAttribute(attribute);
+        return MetaAttributeHelper.getMetaAsString(c);
+    }
 
-       private boolean useCompareTo(String javaTypeName) {
-              // Fix for HBX-400
-              if ("java.math.BigDecimal".equals(javaTypeName)) {
-                     return true;
-              } else {
-                     return false;
-              }
-       } 
+    public boolean hasMetaAttribute(String attribute) {
+        return meta.getMetaAttribute(attribute) != null;
+    }
 
+    public String getMetaAsString(String attribute, String seperator) {
+        return MetaAttributeHelper.getMetaAsString(meta.getMetaAttribute(attribute), seperator);
+    }
 
-       private String internalgenerateEquals(String typeName, String lh, String rh) {
-              if ( c2j.isPrimitive( typeName ) ) {
-                     return "(" + lh + "==" + rh + ")";
-              }
-              else {
-                     if(useCompareTo( typeName )) {
-                            return "( (" + lh + "==" + rh + ") || ( " + lh + "!=null && " + rh + "!=null && " + lh + ".compareTo(" + rh + ")==0 ) )";
-                     } else {
-                            if(typeName.endsWith("[]")) {
-                                   return "( (" + lh + "==" + rh + ") || ( " + lh + "!=null && " + rh + "!=null && " + importType("java.util.Arrays") + ".equals(" + lh + ", " + rh + ") ) )";
-                            } else {
-                                   return "( (" + lh + "==" + rh + ") || ( " + lh + "!=null && " + rh + "!=null && " + lh + ".equals(" + rh + ") ) )";
-                            }
-                     }
+    public boolean getMetaAsBool(String attribute) {
+        return getMetaAsBool(attribute, false);
+    }
 
-              }
-       }
+    public boolean getMetaAsBool(String attribute, boolean defaultValue) {
+        return MetaAttributeHelper.getMetaAsBool(meta.getMetaAttribute(attribute), defaultValue);
+    }
 
-       public String getExtraClassCode() {
-              return getMetaAsString( "class-code", "\n" );
-       }
-       
-       private boolean needsEqualsHashCode(Iterator iter) {
-              while ( iter.hasNext() ) {
-                     Property element = (Property) iter.next();
-                     if ( usePropertyInEquals( element ) ) {
-                            return true;
-                     }
-              }
-              return false;
-       }
+    public String getClassJavaDoc(String fallback, int indent) {
+        MetaAttribute c = meta.getMetaAttribute(CLASS_DESCRIPTION);
+        if (c == null) {
+            return c2j.toJavaDoc(fallback, indent);
+        } else {
+            return c2j.toJavaDoc(getMetaAsString(CLASS_DESCRIPTION), indent);
+        }
+    }
 
-       public boolean needsEqualsHashCode() {
-              Iterator iter = getAllPropertiesIterator();
-              return needsEqualsHashCode( iter );
-       }
+    public String getClassModifiers() {
+        String classModifiers = null;
 
-       public abstract String getExtends();
-       
-       public abstract String getImplements();
+        // Get scope (backwards compatibility)
+        if (meta.getMetaAttribute(SCOPE_CLASS) != null) {
+            classModifiers = getMetaAsString(SCOPE_CLASS).trim();
+        }
 
-       
-       public String importType(String fqcn) {
-              return importContext.importType(fqcn);
-       }
-       
-       public String generateImports() {
-              return importContext.generateImports();
-       }
+        // Get modifiers
+        if (meta.getMetaAttribute(CLASS_MODIFIER) != null) {
+            classModifiers = getMetaAsString(CLASS_MODIFIER).trim();
+        }
+        return classModifiers == null ? "public" : classModifiers;
+    }
 
-       public String staticImport(String fqcn, String member) {
-              return importContext.staticImport(fqcn, member);
-       }
-       
-       public String generateBasicAnnotation(Property property) {
-              StringBuffer annotations = new StringBuffer( "    " );
-              if(property.getValue() instanceof SimpleValue) {
-                     String typeName = ((SimpleValue)property.getValue()).getTypeName();
-                     if("date".equals(typeName) || "java.sql.Date".equals(typeName)) {
-                            buildTemporalAnnotation( annotations, "DATE" );
-                     } else if ("timestamp".equals(typeName) || "java.sql.Timestamp".equals(typeName)) {
-                            //buildTemporalAnnotation( annotations, "TIMESTAMP" ); ..the default so don't generate
-                     } else if ("time".equals(typeName) || "java.sql.Time".equals(typeName)) {
-                            buildTemporalAnnotation(annotations, "TIME");
-                     } //TODO: calendar etc. ?
-              }
-                     
-              return annotations.toString();
-       }
+    public String getDeclarationType() {
+        boolean isInterface = isInterface();
+        if (isInterface) {
+            return INTERFACE;
+        } else {
+            return "class";
+        }
+    }
 
-       private StringBuffer buildTemporalAnnotation(StringBuffer annotations, String temporalTypeValue) {
-              String temporal = importType("javax.persistence.Temporal");
-              String temporalType = importType("javax.persistence.TemporalType");
-              
-              return annotations.append( "@" + temporal +"(" + temporalType + "." + temporalTypeValue + ")");
-       }
-       
-       public String generateAnnColumnAnnotation(Property property) {
-              StringBuffer annotations = new StringBuffer( "    " );
-              boolean insertable = property.isInsertable();
-              boolean updatable = property.isUpdateable();
-              if ( property.isComposite() ) {
-                     annotations.append( "@" + importType("javax.persistence.AttributeOverrides") +"( {" );
-                     Component component = (Component) property.getValue();
-                     Iterator subElements = component.getPropertyIterator();
-                     buildRecursiveAttributeOverride( subElements, null, property, annotations );
-                     annotations.setLength( annotations.length() - 2 );
-                     annotations.append( " } )" );
-              }
-              else {
-                     if ( property.getColumnSpan() == 1 ) {
-                            Selectable selectable = (Selectable) property.getColumnIterator().next();
-                            buildColumnAnnotation( selectable, annotations, insertable, updatable );                            
-                     }
-                     else {
-                            Iterator columns = property.getColumnIterator();
-                            annotations.append("@").append( importType("org.hibernate.annotations.Columns") ).append("( { " );
-                            while ( columns.hasNext() ) {
-                                   Selectable selectable = (Selectable) columns.next();
-       
-                                   if ( selectable.isFormula() ) {
-                                          //TODO formula in multicolumns not supported by annotations
-                                          //annotations.append("/* TODO formula in multicolumns not supported by annotations */");
-                                   }
-                                   else {
-                                          annotations.append( "\n        " );
-                                          buildColumnAnnotation( selectable, annotations, insertable, updatable );
-                                          annotations.append( ", " );
-                                   }
-                            }
-                            annotations.setLength( annotations.length() - 2 );
-                            annotations.append( " } )" );
-                     }
-              }
-              return annotations.toString();
-       }
+    public boolean isInterface() {
+        return getMetaAsBool(INTERFACE);
+    }
 
-       private void buildRecursiveAttributeOverride(Iterator subElements, String path, Property property, StringBuffer annotations) {
-              while ( subElements.hasNext() ) {
-                     Property subProperty = (Property) subElements.next();
-                     if ( subProperty.isComposite() ) {
-                            if ( path != null ) {
-                                   path = path + ".";
-                            }
-                            else {
-                                   path = "";
-                            }
-                            path = path + subProperty.getName();
-                            Component component = (Component) subProperty.getValue();
-                            buildRecursiveAttributeOverride( component.getPropertyIterator(), path, subProperty, annotations );
-                     }
-                     else {
-                            Iterator columns = subProperty.getColumnIterator();
-                            Selectable selectable = (Selectable) columns.next();
-                            if ( selectable.isFormula() ) {
-                                   //TODO formula in multicolumns not supported by annotations
-                            }
-                            else {
-                                   annotations.append( "\n        " ).append("@")
-                                                 .append( importType("javax.persistence.AttributeOverride") ).append("(name=\"" );
-                                   if ( path != null ) {
-                                          annotations.append( path ).append( "." );
-                                   }
-                                   annotations.append( subProperty.getName() ).append( "\"" )
-                                                 .append( ", column=" );
-                                   buildColumnAnnotation(
-                                                 selectable, annotations, subProperty.isInsertable(), subProperty.isUpdateable()
-                                   );
-                                   annotations.append( " ), " );
-                            }
-                     }
-              }
-       }
+    public String getExtendsDeclaration() {
+        String extendz = getExtends();
+        if (extendz == null || extendz.trim().length() == 0) {
+            return "";
+        } else {
+            return "extends " + extendz;
+        }
+    }
 
-       private void buildColumnAnnotation(Selectable selectable, StringBuffer annotations, boolean insertable, boolean updatable) {
-              if ( selectable.isFormula() ) {
-                     annotations.append("@").append( importType("org.hibernate.annotations.Formula") )
-                                   .append("(value=\"" ).append( selectable.getText() ).append( "\")" );
-              }
-              else {
-                     Column column = (Column) selectable;
-                     annotations.append( "@" + importType("javax.persistence.Column") + "(name=\"" ).append( column.getName() ).append( "\"" );
-                     
-                     appendCommonColumnInfo( annotations, column, insertable, updatable );
-                     
-                     if (column.getPrecision() != Column.DEFAULT_PRECISION) { // the default is actually 0 in spec
-                            annotations.append( ", precision=" ).append( column.getPrecision() );
-                     }
-                     if (column.getScale() != Column.DEFAULT_SCALE) { // default is actually 0 in spec
-                            annotations.append( ", scale=" ).append( column.getScale() );
-                     }
-                     else if (column.getLength() != 255){ 
-                            annotations.append( ", length=" ).append( column.getLength() );
-                     }
-                     
-                                   
-                                   
-                     
-                     //TODO support secondary table
-                     annotations.append( ")" );
-              }
-       }
+    public String getImplementsDeclaration() {
+        String implementz = getImplements();
+        if (implementz == null || implementz.trim().length() == 0) {
+            return "";
+        } else {
+            return "implements " + implementz;
+        }
+    }
 
-       protected void appendCommonColumnInfo(StringBuffer annotations, Column column, boolean insertable, boolean updatable) {
-              if(column.isUnique()) {
-                            annotations.append( ", unique=" ).append( column.isUnique() );
-              }
-              if(!column.isNullable()) {
-                            annotations.append( ", nullable=" ).append( column.isNullable() );
-              }
-              
-              if(!insertable) {
-                            annotations.append( ", insertable=" ).append( insertable );
-              }
-              
-              if(!updatable) {
-                            annotations.append( ", updatable=" ).append( updatable );
-              }
-              
-              String sqlType = column.getSqlType();
-              if ( StringHelper.isNotEmpty( sqlType ) ) {
-                     annotations.append( ", columnDefinition=\"" ).append( sqlType ).append( "\"" );
-              }
-                            
-       }
+    public String generateEquals(String thisName, String otherName, boolean useGenerics) {
+        Iterator allPropertiesIterator = getEqualsHashCodePropertiesIterator();
+        return generateEquals(thisName, otherName, allPropertiesIterator, useGenerics);
+    }
 
+    public abstract Iterator getAllPropertiesIterator();
 
-       public Iterator getToStringPropertiesIterator() {
-              Iterator iter = getAllPropertiesIterator();
-              return getToStringPropertiesIterator( iter );
-       }
+    protected String generateEquals(String thisName, String otherName, Iterator allPropertiesIterator, boolean useGenerics) {
+        StringBuffer buf = new StringBuffer();
+        while (allPropertiesIterator.hasNext()) {
+            Property property = (Property) allPropertiesIterator.next();
+            if (buf.length() > 0) buf.append("\n && ");
+            String javaTypeName = c2j.getJavaTypeName(property, useGenerics, this);
+            buf.append(
+                    internalgenerateEquals(
+                            javaTypeName, thisName + "." + getGetterSignature(property) + "()",
+                            otherName + "." + getGetterSignature(property) + "()")
+            );
+        }
 
-       private Iterator getToStringPropertiesIterator(Iterator iter) {
-              List properties = new ArrayList();
+        if (buf.length() == 0) {
+            return "false";
+        } else {
+            return buf.toString();
+        }
+    }
 
-              while ( iter.hasNext() ) {
-                     Property element = (Property) iter.next();
-                     if ( c2j.getMetaAsBool( element, "use-in-tostring" ) ) {
-                            properties.add( element );
-                     }
-              }
+    private boolean usePropertyInEquals(Property property) {
+        boolean hasEqualsMetaAttribute = c2j.hasMetaAttribute(property, "use-in-equals");
+        boolean useInEquals = c2j.getMetaAsBool(property, "use-in-equals");
 
-              return properties.iterator();
-       }
+        if (property.isNaturalIdentifier()) {
+            if (hasEqualsMetaAttribute && !useInEquals) {
+                return false;
+            } else {
+                return true;
+            }
+        }
 
-       public Iterator getEqualsHashCodePropertiesIterator() {
-              Iterator iter = getAllPropertiesIterator();
-              return getEqualsHashCodePropertiesIterator(iter);
-       }
+        return useInEquals;
+    }
 
-       private Iterator getEqualsHashCodePropertiesIterator(Iterator iter) {
-              List properties = new ArrayList();
+    private boolean useCompareTo(String javaTypeName) {
+        // Fix for HBX-400
+        if ("java.math.BigDecimal".equals(javaTypeName)) {
+            return true;
+        } else {
+            return false;
+        }
+    }
 
-              while ( iter.hasNext() ) {
-                     Property element = (Property) iter.next();
-                     if ( usePropertyInEquals(element) ) {
-                            properties.add( element );
-                     }
-              }
 
-              return properties.iterator();
-       }
+    private String internalgenerateEquals(String typeName, String lh, String rh) {
+        if (c2j.isPrimitive(typeName)) {
+            return "(" + lh + "==" + rh + ")";
+        } else {
+            if (useCompareTo(typeName)) {
+                return "( (" + lh + "==" + rh + ") || ( " + lh + "!=null && " + rh + "!=null && " + lh + ".compareTo(" + rh + ")==0 ) )";
+            } else {
+                if (typeName.endsWith("[]")) {
+                    return "( (" + lh + "==" + rh + ") || ( " + lh + "!=null && " + rh + "!=null && " + importType("java.util.Arrays") + ".equals(" + lh + ", " + rh + ") ) )";
+                } else {
+                    return "( (" + lh + "==" + rh + ") || ( " + lh + "!=null && " + rh + "!=null && " + lh + ".equals(" + rh + ") ) )";
+                }
+            }
 
-       public boolean needsToString() {
-              Iterator iter = getAllPropertiesIterator();
-              return needsToString( iter );
-       }
-       
-       private boolean needsToString(Iterator iter) {
-              while ( iter.hasNext() ) {
-                     Property element = (Property) iter.next();
-                     if ( c2j.getMetaAsBool( element, "use-in-tostring" ) ) {
-                            return true;
-                     }
-              }
-              return false;
-       }
+        }
+    }
 
-       public boolean hasMetaAttribute(MetaAttributable pc, String attribute) {
-              return pc.getMetaAttribute( attribute ) != null;
-       }
+    public String getExtraClassCode() {
+        return getMetaAsString("class-code", "\n");
+    }
 
-       public boolean getMetaAttribAsBool(MetaAttributable pc, String attribute, boolean defaultValue) {
-              return MetaAttributeHelper.getMetaAsBool( pc.getMetaAttribute( attribute ), defaultValue );
-       }
-       
-       public boolean hasFieldJavaDoc(Property property) {
-              return property.getMetaAttribute("field-description")!=null;
-       }
-       
-       public String getFieldJavaDoc(Property property, int indent) {
-              MetaAttribute c = property.getMetaAttribute( "field-description" );
-              if ( c == null ) {
-                     return c2j.toJavaDoc( "", indent );
-              }
-              else {
-                     return c2j.toJavaDoc( c2j.getMetaAsString( property, "field-description" ), indent );
-              }
-       }
-       
-       public String getFieldDescription(Property property){
-              MetaAttribute c = property.getMetaAttribute( "field-description" );
-              if ( c == null ) {
-                     return "";
-              }
-              else {
-                     return c2j.getMetaAsString( property, "field-description" );
-              }             
-       }
+    private boolean needsEqualsHashCode(Iterator iter) {
+        while (iter.hasNext()) {
+            Property element = (Property) iter.next();
+            if (usePropertyInEquals(element)) {
+                return true;
+            }
+        }
+        return false;
+    }
 
-       /**
-        * Method getGetterSignature.
-        *
-        * @return String
-        */
-       public String getGetterSignature(Property p) {
-              String prefix = c2j.getJavaTypeName( p, false).equals( "boolean" ) ? "is" : "get";
-              return prefix + beanCapitalize( p.getName() );
-       }
+    public boolean needsEqualsHashCode() {
+        Iterator iter = getAllPropertiesIterator();
+        return needsEqualsHashCode(iter);
+    }
 
-       /**
-        * @param p
-        * @return foo -> Foo, FOo -> FOo
-        */
-       public String getPropertyName(Property p) {
-              return beanCapitalize( p.getName() );
-       }
+    public abstract String getExtends();
 
+    public abstract String getImplements();
 
-       // get the "opposite" collectionnae for a property. Currently a "hack" that just uses the same naming algorithm as in reveng, will fail on more general models!
-       public String getCollectionNameFor(Property property) {
-              String str = getPropertyName(property);
-              return ReverseEngineeringStrategyUtil.simplePluralize(str);
-       }
-       
-       
-       /**
-        * foo -> Foo
-        * FOo -> FOo
-        */
-       static public String beanCapitalize(String fieldname) {
-              if ( fieldname == null || fieldname.length() == 0 ) {
-                     return fieldname;
-              }
 
-              if ( fieldname.length() > 1 && Character.isUpperCase( fieldname.charAt( 1 ) ) ) {
-                     return fieldname;
-              }
-              char chars[] = fieldname.toCharArray();
-              chars[0] = Character.toUpperCase( chars[0] );
-              return new String( chars );
-       }
+    public String importType(String fqcn) {
+        return importContext.importType(fqcn);
+    }
 
+    public String generateImports() {
+        return importContext.generateImports();
+    }
 
-       public boolean isComponent(Property property) {
-              Value value = property.getValue();
-              if ( value != null && value instanceof Component ) {
-                     return true;
-              }
-              else {
-                     return false;
-              }
-       }
+    public String staticImport(String fqcn, String member) {
+        return importContext.staticImport(fqcn, member);
+    }
 
-       public String generateHashCode(Property property, String result, String thisName, boolean jdk5) {
-              StringBuffer buf = new StringBuffer();
-              if ( c2j.getMetaAsBool( property, "use-in-equals" ) ) {
-                     String javaTypeName = c2j.getJavaTypeName( property, jdk5, this );
-                     boolean isPrimitive = c2j.isPrimitive( javaTypeName );
-                     if ( isPrimitive ) {
-                            buf.append( result )
-                            .append( " = 37 * " )
-                            .append( result )
-                            .append( " + " );
-                            String thisValue = thisName + "." + getGetterSignature( property ) + "()";
-                            if("char".equals(javaTypeName)||"int".equals(javaTypeName)||"short".equals(javaTypeName)||"byte".equals(javaTypeName)) {
-                                   buf.append( thisValue );
-                            } else if("boolean".equals(javaTypeName)) {
-                                   buf.append("(" + thisValue + "?1:0)");
-                            } else {
-                                   buf.append( "(int) ");
-                                   buf.append( thisValue );
-                            }
-                            buf.append(";");
-                     }
-                     else {
-                            if(javaTypeName.endsWith("[]")) {
-                                   if(jdk5) {
-                                          buf.append( result )
-                                          .append( " = 37 * " )
-                                          .append( result )
-                                          .append( " + " );
-                                          buf.append( "( " )
-                                          .append( getGetterSignature( property ) )
-                                          .append( "() == null ? 0 : " + importType("java.util.Arrays") + ".hashCode(" )
-                                          .append( thisName )
-                                          .append( "." )
-                                          .append( getGetterSignature( property ) )
-                                          .append( "())" )
-                                          .append( " )" )
-                                          .append(";");                                     
-                                   }
-                                   else {
-                                          buf.append(internalGenerateArrayHashcode(property, javaTypeName, result, thisName));
-                                   }
-                            } else {
-                                   buf.append( result )
-                                   .append( " = 37 * " )
-                                   .append( result )
-                                   .append( " + " );
-                                   buf.append( "( " )
-                                   .append( getGetterSignature( property ) )
-                                   .append( "() == null ? 0 : " )
-                                   .append( thisName )
-                                   .append( "." )
-                                   .append( getGetterSignature( property ) )
-                                   .append( "()" )
-                                   .append( ".hashCode()" )
-                                   .append( " )" )
-                                   .append(";");
-                            }
-                     }
-              }
-              return buf.toString();
-       }
+    public String generateBasicAnnotation(Property property) {
+        StringBuffer annotations = new StringBuffer("    ");
+        if (property.getValue() instanceof SimpleValue) {
+            String typeName = ((SimpleValue) property.getValue()).getTypeName();
+            if ("date".equals(typeName) || "java.sql.Date".equals(typeName)) {
+                buildTemporalAnnotation(annotations, "DATE");
+            } else if ("timestamp".equals(typeName) || "java.sql.Timestamp".equals(typeName)) {
+                //buildTemporalAnnotation( annotations, "TIMESTAMP" ); ..the default so don't generate
+            } else if ("time".equals(typeName) || "java.sql.Time".equals(typeName)) {
+                buildTemporalAnnotation(annotations, "TIME");
+            } //TODO: calendar etc. ?
+        }
 
+        return annotations.toString();
+    }
 
-       private String internalGenerateArrayHashcode(Property property, String javaTypeName, String result, String thisName)
-       {
-              StringBuffer buf = new StringBuffer();
+    private StringBuffer buildTemporalAnnotation(StringBuffer annotations, String temporalTypeValue) {
+        String temporal = importType("javax.persistence.Temporal");
+        String temporalType = importType("javax.persistence.TemporalType");
 
-              String propertyHashVarName = property.getName() + "Hashcode";
-              String propertyArrayName = property.getName() + "Property";
+        return annotations.append("@" + temporal + "(" + temporalType + "." + temporalTypeValue + ")");
+    }
 
+    public String generateAnnColumnAnnotation(Property property) {
+        StringBuffer annotations = new StringBuffer("    ");
+        boolean insertable = property.isInsertable();
+        boolean updatable = property.isUpdateable();
+        if (property.isComposite()) {
+            annotations.append("@" + importType("javax.persistence.AttributeOverrides") + "( {");
+            Component component = (Component) property.getValue();
+            Iterator subElements = component.getPropertyIterator();
+            buildRecursiveAttributeOverride(subElements, null, property, annotations);
+            annotations.setLength(annotations.length() - 2);
+            annotations.append(" } )");
+        } else {
+            if (property.getColumnSpan() == 1) {
+                Selectable selectable = (Selectable) property.getColumnIterator().next();
+                buildColumnAnnotation(selectable, annotations, insertable, updatable);
+            } else {
+                Iterator columns = property.getColumnIterator();
+                annotations.append("@").append(importType("org.hibernate.annotations.Columns")).append("( { ");
+                while (columns.hasNext()) {
+                    Selectable selectable = (Selectable) columns.next();
+
+                    if (selectable.isFormula()) {
+                        //TODO formula in multicolumns not supported by annotations
+                        //annotations.append("/* TODO formula in multicolumns not supported by annotations */");
+                    } else {
+                        annotations.append("\n        ");
+                        buildColumnAnnotation(selectable, annotations, insertable, updatable);
+                        annotations.append(", ");
+                    }
+                }
+                annotations.setLength(annotations.length() - 2);
+                annotations.append(" } )");
+            }
+        }
+        return annotations.toString();
+    }
+
+    private void buildRecursiveAttributeOverride(Iterator subElements, String path, Property property, StringBuffer annotations) {
+        while (subElements.hasNext()) {
+            Property subProperty = (Property) subElements.next();
+            if (subProperty.isComposite()) {
+                if (path != null) {
+                    path = path + ".";
+                } else {
+                    path = "";
+                }
+                path = path + subProperty.getName();
+                Component component = (Component) subProperty.getValue();
+                buildRecursiveAttributeOverride(component.getPropertyIterator(), path, subProperty, annotations);
+            } else {
+                Iterator columns = subProperty.getColumnIterator();
+                Selectable selectable = (Selectable) columns.next();
+                if (selectable.isFormula()) {
+                    //TODO formula in multicolumns not supported by annotations
+                } else {
+                    annotations.append("\n        ").append("@")
+                            .append(importType("javax.persistence.AttributeOverride")).append("(name=\"");
+                    if (path != null) {
+                        annotations.append(path).append(".");
+                    }
+                    annotations.append(subProperty.getName()).append("\"")
+                            .append(", column=");
+                    buildColumnAnnotation(
+                            selectable, annotations, subProperty.isInsertable(), subProperty.isUpdateable()
+                    );
+                    annotations.append(" ), ");
+                }
+            }
+        }
+    }
+
+    private void buildColumnAnnotation(Selectable selectable, StringBuffer annotations, boolean insertable, boolean updatable) {
+        if (selectable.isFormula()) {
+            annotations.append("@").append(importType("org.hibernate.annotations.Formula"))
+                    .append("(value=\"").append(selectable.getText()).append("\")");
+        } else {
+            Column column = (Column) selectable;
+            annotations.append("@" + importType("javax.persistence.Column") + "(name=\"").append(column.getName()).append("\"");
+
+            appendCommonColumnInfo(annotations, column, insertable, updatable);
+
+            if (column.getPrecision() != Column.DEFAULT_PRECISION) { // the default is actually 0 in spec
+                annotations.append(", precision=").append(column.getPrecision());
+            }
+            if (column.getScale() != Column.DEFAULT_SCALE) { // default is actually 0 in spec
+                annotations.append(", scale=").append(column.getScale());
+            } else if (column.getLength() != 255) {
+                annotations.append(", length=").append(column.getLength());
+            }
+
+            //TODO support secondary table
+            annotations.append(")");
+        }
+    }
+
+    protected void appendCommonColumnInfo(StringBuffer annotations, Column column, boolean insertable, boolean updatable) {
+        if (column.isUnique()) {
+            annotations.append(", unique=").append(column.isUnique());
+        }
+        if (!column.isNullable()) {
+            annotations.append(", nullable=").append(column.isNullable());
+        }
+
+        if (!insertable) {
+            annotations.append(", insertable=").append(insertable);
+        }
+
+        if (!updatable) {
+            annotations.append(", updatable=").append(updatable);
+        }
+
+        String sqlType = column.getSqlType();
+        if (StringHelper.isNotEmpty(sqlType)) {
+            annotations.append(", columnDefinition=\"").append(sqlType).append("\"");
+        }
+
+    }
+
+
+    public Iterator getToStringPropertiesIterator() {
+        Iterator iter = getAllPropertiesIterator();
+        return getToStringPropertiesIterator(iter);
+    }
+
+    private Iterator getToStringPropertiesIterator(Iterator iter) {
+        List properties = new ArrayList();
+
+        while (iter.hasNext()) {
+            Property element = (Property) iter.next();
+            if (c2j.getMetaAsBool(element, "use-in-tostring")) {
+                properties.add(element);
+            }
+        }
+
+        return properties.iterator();
+    }
+
+    public Iterator getEqualsHashCodePropertiesIterator() {
+        Iterator iter = getAllPropertiesIterator();
+        return getEqualsHashCodePropertiesIterator(iter);
+    }
+
+    private Iterator getEqualsHashCodePropertiesIterator(Iterator iter) {
+        List properties = new ArrayList();
+
+        while (iter.hasNext()) {
+            Property element = (Property) iter.next();
+            if (usePropertyInEquals(element)) {
+                properties.add(element);
+            }
+        }
+
+        return properties.iterator();
+    }
+
+    public boolean needsToString() {
+        Iterator iter = getAllPropertiesIterator();
+        return needsToString(iter);
+    }
+
+    private boolean needsToString(Iterator iter) {
+        while (iter.hasNext()) {
+            Property element = (Property) iter.next();
+            if (c2j.getMetaAsBool(element, "use-in-tostring")) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public boolean hasMetaAttribute(MetaAttributable pc, String attribute) {
+        return pc.getMetaAttribute(attribute) != null;
+    }
+
+    public boolean getMetaAttribAsBool(MetaAttributable pc, String attribute, boolean defaultValue) {
+        return MetaAttributeHelper.getMetaAsBool(pc.getMetaAttribute(attribute), defaultValue);
+    }
+
+    public boolean hasFieldJavaDoc(Property property) {
+        return property.getMetaAttribute("field-description") != null;
+    }
+
+    public String getFieldJavaDoc(Property property, int indent) {
+        MetaAttribute c = property.getMetaAttribute("field-description");
+        if (c == null) {
+            return c2j.toJavaDoc("", indent);
+        } else {
+            return c2j.toJavaDoc(c2j.getMetaAsString(property, "field-description"), indent);
+        }
+    }
+
+    public String getFieldDescription(Property property) {
+        MetaAttribute c = property.getMetaAttribute("field-description");
+        if (c == null) {
+            return "";
+        } else {
+            return c2j.getMetaAsString(property, "field-description");
+        }
+    }
+
+    /**
+     * Method getGetterSignature.
+     *
+     * @return String
+     */
+    public String getGetterSignature(Property p) {
+        String prefix = c2j.getJavaTypeName(p, false).equals("boolean") ? "is" : "get";
+        return prefix + beanCapitalize(p.getName());
+    }
+
+    /**
+     * @param p
+     * @return foo -> Foo, FOo -> FOo
+     */
+    public String getPropertyName(Property p) {
+        return beanCapitalize(p.getName());
+    }
+
+
+    // get the "opposite" collectionnae for a property. Currently a "hack" that just uses the same naming algorithm as in reveng, will fail on more general models!
+    public String getCollectionNameFor(Property property) {
+        String str = getPropertyName(property);
+        return ReverseEngineeringStrategyUtil.simplePluralize(str);
+    }
+
+
+    /**
+     * foo -> Foo
+     * FOo -> FOo
+     */
+    static public String beanCapitalize(String fieldname) {
+        if (fieldname == null || fieldname.length() == 0) {
+            return fieldname;
+        }
+
+        if (fieldname.length() > 1 && Character.isUpperCase(fieldname.charAt(1))) {
+            return fieldname;
+        }
+        char chars[] = fieldname.toCharArray();
+        chars[0] = Character.toUpperCase(chars[0]);
+        return new String(chars);
+    }
+
+
+    public boolean isComponent(Property property) {
+        Value value = property.getValue();
+        if (value != null && value instanceof Component) {
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    public String generateHashCode(Property property, String result, String thisName, boolean jdk5) {
+        StringBuffer buf = new StringBuffer();
+        if (c2j.getMetaAsBool(property, "use-in-equals")) {
+            String javaTypeName = c2j.getJavaTypeName(property, jdk5, this);
+            boolean isPrimitive = c2j.isPrimitive(javaTypeName);
+            if (isPrimitive) {
+                buf.append(result)
+                        .append(" = 37 * ")
+                        .append(result)
+                        .append(" + ");
+                String thisValue = thisName + "." + getGetterSignature(property) + "()";
+                if ("char".equals(javaTypeName) || "int".equals(javaTypeName) || "short".equals(javaTypeName) || "byte".equals(javaTypeName)) {
+                    buf.append(thisValue);
+                } else if ("boolean".equals(javaTypeName)) {
+                    buf.append("(" + thisValue + "?1:0)");
+                } else {
+                    buf.append("(int) ");
+                    buf.append(thisValue);
+                }
+                buf.append(";");
+            } else {
+                if (javaTypeName.endsWith("[]")) {
+                    if (jdk5) {
+                        buf.append(result)
+                                .append(" = 37 * ")
+                                .append(result)
+                                .append(" + ");
+                        buf.append("( ")
+                                .append(getGetterSignature(property))
+                                .append("() == null ? 0 : " + importType("java.util.Arrays") + ".hashCode(")
+                                .append(thisName)
+                                .append(".")
+                                .append(getGetterSignature(property))
+                                .append("())")
+                                .append(" )")
+                                .append(";");
+                    } else {
+                        buf.append(internalGenerateArrayHashcode(property, javaTypeName, result, thisName));
+                    }
+                } else {
+                    buf.append(result)
+                            .append(" = 37 * ")
+                            .append(result)
+                            .append(" + ");
+                    buf.append("( ")
+                            .append(getGetterSignature(property))
+                            .append("() == null ? 0 : ")
+                            .append(thisName)
+                            .append(".")
+                            .append(getGetterSignature(property))
+                            .append("()")
+                            .append(".hashCode()")
+                            .append(" )")
+                            .append(";");
+                }
+            }
+        }
+        return buf.toString();
+    }
+
+
+    private String internalGenerateArrayHashcode(Property property, String javaTypeName, String result, String thisName) {
+        StringBuffer buf = new StringBuffer();
+
+        String propertyHashVarName = property.getName() + "Hashcode";
+        String propertyArrayName = property.getName() + "Property";
+
 //            int propertyHash = 0;
-              buf.append( "int ")
-              .append( propertyHashVarName )
-              .append( " = 0;\n" );
+        buf.append("int ")
+                .append(propertyHashVarName)
+                .append(" = 0;\n");
 
 //            type[] proterty = getProperty();
-              buf.append( "         " )
-              .append( javaTypeName )
-              .append( " " )
-              .append( propertyArrayName )
-              .append( " = " )
-              .append( thisName )
-              .append( "." )
-              .append( getGetterSignature( property ) )
-              .append( "();\n");
+        buf.append("         ")
+                .append(javaTypeName)
+                .append(" ")
+                .append(propertyArrayName)
+                .append(" = ")
+                .append(thisName)
+                .append(".")
+                .append(getGetterSignature(property))
+                .append("();\n");
 
 //            if(property != null) {
-              buf.append( "         if(" )
-              .append( propertyArrayName )
-              .append( " != null) {\n" );
+        buf.append("         if(")
+                .append(propertyArrayName)
+                .append(" != null) {\n");
 
 //            propertyHash = 1;
-              buf.append( "             " )
-              .append( propertyHashVarName )
-              .append( " = 1;\n" );
+        buf.append("             ")
+                .append(propertyHashVarName)
+                .append(" = 1;\n");
 
 //            for (int i=0; i<property.length; i++)
-              String elementType = javaTypeName.replaceAll("\\[\\]", "");
-              buf.append( "             for (int i=0; i<" )
-              .append( propertyArrayName )
-              .append( ".length; i++) {\n" );
+        String elementType = javaTypeName.replaceAll("\\[\\]", "");
+        buf.append("             for (int i=0; i<")
+                .append(propertyArrayName)
+                .append(".length; i++) {\n");
 
-              if(javaTypeName.startsWith("long")) {
+        if (javaTypeName.startsWith("long")) {
 //                   int elementHash = (int)(propertyArray[i] ^ (propertyArray[i] >>> 32));
-                     buf.append( "                 int elementHash = (int)(" )
-                     .append( propertyArrayName )
-                     .append( "[i] ^ (" )
-                     .append( propertyArrayName )
-                     .append( "[i] >>> 32));\n" );
+            buf.append("                 int elementHash = (int)(")
+                    .append(propertyArrayName)
+                    .append("[i] ^ (")
+                    .append(propertyArrayName)
+                    .append("[i] >>> 32));\n");
 
 //                   propertyHash = 37 * propertyHash + elementHash;
-                     buf.append( "                 " )
-                     .append( propertyHashVarName )
-                     .append( " = 37 * " )
-                     .append( propertyHashVarName )
-                     .append( " + elementHash;\n" );
-              } else if(javaTypeName.startsWith("boolean")) {
+            buf.append("                 ")
+                    .append(propertyHashVarName)
+                    .append(" = 37 * ")
+                    .append(propertyHashVarName)
+                    .append(" + elementHash;\n");
+        } else if (javaTypeName.startsWith("boolean")) {
 //                   propertyHash = 37 * propertyHash + (propertyArray[i] ? 1231 : 1237);
-                     buf.append( "                 " )
-                     .append( propertyHashVarName )
-                     .append( " = 37 * " )
-                     .append( propertyHashVarName )
-                     .append( " + (" )
-                     .append( propertyArrayName )
-                     .append( "[i] ? 1231 : 1237);\n" );
-              } else if(javaTypeName.startsWith("float")) {
+            buf.append("                 ")
+                    .append(propertyHashVarName)
+                    .append(" = 37 * ")
+                    .append(propertyHashVarName)
+                    .append(" + (")
+                    .append(propertyArrayName)
+                    .append("[i] ? 1231 : 1237);\n");
+        } else if (javaTypeName.startsWith("float")) {
 //                   propertyHash = 37 * propertyHash + Float.floatToIntBits(propertyArray[i]);
-                     buf.append( "                 " )
-                     .append( propertyHashVarName )
-                     .append( " = 37 * " )
-                     .append( propertyHashVarName )
-                     .append( " + Float.floatToIntBits(" )
-                     .append( propertyArrayName )
-                     .append( "[i]);\n" );
-              } else if(javaTypeName.startsWith("double")) {
+            buf.append("                 ")
+                    .append(propertyHashVarName)
+                    .append(" = 37 * ")
+                    .append(propertyHashVarName)
+                    .append(" + Float.floatToIntBits(")
+                    .append(propertyArrayName)
+                    .append("[i]);\n");
+        } else if (javaTypeName.startsWith("double")) {
 //                   long bits = Double.doubleToLongBits(propertyArray[i]);
-                     buf.append( "                 long bits = Double.doubleToLongBits(" )
-                     .append( propertyArrayName )
-                     .append( "[i]);\n" );
+            buf.append("                 long bits = Double.doubleToLongBits(")
+                    .append(propertyArrayName)
+                    .append("[i]);\n");
 
 //                   propertyHash = 37 * propertyHash + (int)(bits ^ (bits >>> 32));
-                     buf.append( "                 " )
-                     .append( propertyHashVarName )
-                     .append( " = 37 * " )
-                     .append( propertyHashVarName )
-                     .append( " + (int)(bits ^ (bits >>> 32));\n" );
-              } else if(javaTypeName.startsWith("int")
-                            || javaTypeName.startsWith("short")
-                            || javaTypeName.startsWith("char")
-                            || javaTypeName.startsWith("byte")) {
+            buf.append("                 ")
+                    .append(propertyHashVarName)
+                    .append(" = 37 * ")
+                    .append(propertyHashVarName)
+                    .append(" + (int)(bits ^ (bits >>> 32));\n");
+        } else if (javaTypeName.startsWith("int")
+                || javaTypeName.startsWith("short")
+                || javaTypeName.startsWith("char")
+                || javaTypeName.startsWith("byte")) {
 //                   propertyHash = 37 * propertyHash + propertyArray[i];
-                     buf.append( "                 " )
-                     .append( propertyHashVarName )
-                     .append( " = 37 * " )
-                     .append( propertyHashVarName )
-                     .append( " + " )
-                     .append( propertyArrayName )
-                     .append( "[i];\n" );
-              } else {// Object[]
+            buf.append("                 ")
+                    .append(propertyHashVarName)
+                    .append(" = 37 * ")
+                    .append(propertyHashVarName)
+                    .append(" + ")
+                    .append(propertyArrayName)
+                    .append("[i];\n");
+        } else {// Object[]
 //                   propertyHash = 37 * propertyHash + propertyArray[i].hashCode();
-                     buf.append( "                 " )
-                     .append( propertyHashVarName )
-                     .append( " = 37 * " )
-                     .append( propertyHashVarName )
-                     .append( " + " )
-                     .append( propertyArrayName )
-                     .append( "[i].hashCode();\n" );
-              }
+            buf.append("                 ")
+                    .append(propertyHashVarName)
+                    .append(" = 37 * ")
+                    .append(propertyHashVarName)
+                    .append(" + ")
+                    .append(propertyArrayName)
+                    .append("[i].hashCode();\n");
+        }
 
-              buf.append( "             }\n" );
-              buf.append( "         }\n\n" );
+        buf.append("             }\n");
+        buf.append("         }\n\n");
 
 //            result = 37 * result + arrayHashcode;
-              buf.append( "         " )
-              .append( result )
-              .append( " = 37 * " )
-              .append( result )
-              .append( " + " )
-              .append( propertyHashVarName )
-              .append( ";\n" );
+        buf.append("         ")
+                .append(result)
+                .append(" = 37 * ")
+                .append(result)
+                .append(" + ")
+                .append(propertyHashVarName)
+                .append(";\n");
 
-              return buf.toString();
-       }
+        return buf.toString();
+    }
 
 
-       public String getFieldModifiers(Property property) {
-              return getModifiers( property, "scope-field", "private" );
-       }
+    public String getFieldModifiers(Property property) {
+        return getModifiers(property, "scope-field", "private");
+    }
 
-       public String getPropertyGetModifiers(Property property) {
-              return getModifiers( property, "scope-get", "public" );
-       }
+    public String getPropertyGetModifiers(Property property) {
+        return getModifiers(property, "scope-get", "public");
+    }
 
-       public String getPropertySetModifiers(Property property) {
-              return getModifiers( property, "scope-set", "public" );
-       }
+    public String getPropertySetModifiers(Property property) {
+        return getModifiers(property, "scope-set", "public");
+    }
 
-       //TODO defaultModifiers
-       private String getModifiers(Property property, String modifiername, String defaultModifiers) {
-              MetaAttribute override = property.getMetaAttribute( modifiername );
-              if ( override != null ) {
-                     return MetaAttributeHelper.getMetaAsString( override );
-              }
-              else {
-                     return defaultModifiers;
-              }
-       }
+    //TODO defaultModifiers
+    private String getModifiers(Property property, String modifiername, String defaultModifiers) {
+        MetaAttribute override = property.getMetaAttribute(modifiername);
+        if (override != null) {
+            return MetaAttributeHelper.getMetaAsString(override);
+        } else {
+            return defaultModifiers;
+        }
+    }
 
-       protected boolean isRequiredInConstructor(Property field) {
-              if(hasMetaAttribute(field, "default-value")) {
-                     return false;
-              }
-              if(field.getValue()!=null) {                 
-                     if (!field.isOptional() && field.getGeneration().equals(PropertyGeneration.NEVER)) {                        
-                            return true;
-                     } else if (field.getValue() instanceof Component) {
-                            Component c = (Component) field.getValue();
-                            Iterator it = c.getPropertyIterator();
-                            while ( it.hasNext() ) {
-                                   Property prop = (Property) it.next();
-                                   if(isRequiredInConstructor(prop)) {
-                                          return true;
-                                   }
-                            }
-                     }
-              }
-              
-              return false;
-       }
+    protected boolean isRequiredInConstructor(Property field) {
+        if (hasMetaAttribute(field, "default-value")) {
+            return false;
+        }
+        if (field.getValue() != null) {
+            if (!field.isOptional() && field.getGeneration().equals(PropertyGeneration.NEVER)) {
+                return true;
+            } else if (field.getValue() instanceof Component) {
+                Component c = (Component) field.getValue();
+                Iterator it = c.getPropertyIterator();
+                while (it.hasNext()) {
+                    Property prop = (Property) it.next();
+                    if (isRequiredInConstructor(prop)) {
+                        return true;
+                    }
+                }
+            }
+        }
 
-       public boolean needsMinimalConstructor() {
-              List propClosure = getPropertyClosureForMinimalConstructor();
-              if(propClosure.isEmpty()) return false; // minimal=default
-              if(propClosure.equals(getPropertyClosureForFullConstructor())) return false; // minimal=full
-              return true;
-       }
+        return false;
+    }
 
-       public boolean needsFullConstructor() {
-              return !getPropertyClosureForFullConstructor().isEmpty();             
-       }
-       
-       public String getJavaTypeName(Property p, boolean useGenerics) {
-              return c2j.getJavaTypeName(p, useGenerics, this);
-       }
-       
-       static Map defaultInitializors = new HashMap();
-       static {
-              defaultInitializors.put("java.util.List", "java.util.ArrayList");
-              defaultInitializors.put("java.util.Map", "java.util.HashMap");
-              defaultInitializors.put("java.util.Set", "java.util.HashSet");        
-       }
-       
-       public boolean hasFieldInitializor(Property p, boolean useGenerics) {
-              return getFieldInitialization(p, useGenerics)!=null;
-       }
-       
-       public String getFieldInitialization(Property p, boolean useGenerics) {
-              String javaTypeName = c2j.getJavaTypeName(p, false);
-              if(hasMetaAttribute(p, "default-value")) {
-                     return MetaAttributeHelper.getMetaAsString( p.getMetaAttribute( "default-value" ) );
-              }
-              if(javaTypeName==null) {
-                     return null;
-              } else if (p.getValue() instanceof Collection) {
-                     String initialization = (String) defaultInitializors.get(javaTypeName);
-                     
-                     String decl = null;
-                     
-                     if(useGenerics) {
-                            decl = c2j.getGenericCollectionDeclaration((Collection) p.getValue(), true, importContext);
-                     }
-                     if(initialization!=null) {                   
-                            return "new " + importType(initialization) + (decl==null?"":decl) + "(0)";
-                     } else {
-                            return null;
-                     }
-              } else {
-                     return null;
-              }
-       }      
-       
+    public boolean needsMinimalConstructor() {
+        List propClosure = getPropertyClosureForMinimalConstructor();
+        if (propClosure.isEmpty()) return false; // minimal=default
+        if (propClosure.equals(getPropertyClosureForFullConstructor())) return false; // minimal=full
+        return true;
+    }
+
+    public boolean needsFullConstructor() {
+        return !getPropertyClosureForFullConstructor().isEmpty();
+    }
+
+    public String getJavaTypeName(Property p, boolean useGenerics) {
+        return c2j.getJavaTypeName(p, useGenerics, this);
+    }
+
+    static Map defaultInitializors = new HashMap();
+
+    static {
+        defaultInitializors.put("java.util.List", "java.util.ArrayList");
+        defaultInitializors.put("java.util.Map", "java.util.HashMap");
+        defaultInitializors.put("java.util.Set", "java.util.HashSet");
+    }
+
+    public boolean hasFieldInitializor(Property p, boolean useGenerics) {
+        return getFieldInitialization(p, useGenerics) != null;
+    }
+
+    public String getFieldInitialization(Property p, boolean useGenerics) {
+        String javaTypeName = c2j.getJavaTypeName(p, false);
+        if (hasMetaAttribute(p, "default-value")) {
+            String defaultValue = MetaAttributeHelper.getMetaAsString(p.getMetaAttribute("default-value"));
+            if ("".equals(defaultValue)) {
+                return "new " + javaTypeName.substring(javaTypeName.lastIndexOf(".") + 1) + "()";
+            }
+            return MetaAttributeHelper.getMetaAsString(p.getMetaAttribute("default-value"));
+        }
+        if (javaTypeName == null) {
+            return null;
+        } else if (p.getValue() instanceof Collection) {
+            String initialization = (String) defaultInitializors.get(javaTypeName);
+
+            String decl = null;
+
+            if (useGenerics) {
+                decl = c2j.getGenericCollectionDeclaration((Collection) p.getValue(), true, importContext);
+            }
+            if (initialization != null) {
+                return "new " + importType(initialization) + (decl == null ? "" : decl) + "(0)";
+            } else {
+                return null;
+            }
+        } else {
+            return null;
+        }
+    }
+
 } 
