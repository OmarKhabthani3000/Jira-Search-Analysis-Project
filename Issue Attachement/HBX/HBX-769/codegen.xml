<?xml version="1.0" encoding="ISO-8859-1"?>
<chapter id="codegen">
  <title>Controlling POJO code generation</title>
  <para>When using &lt;hbm2java&gt; or the eclipse plugin to generate
    POJO java code you have the possibility to control certain aspects of the
    code generation. This is primarily done through the &lt;meta&gt; tag
    in the mapping files. The following section describes the possible meta tags
    and their use.</para>
  <section>
    <title>The <literal>&lt;meta&gt;</literal> attribute</title>
    <para>The <literal>&lt;meta&gt;</literal> tag is a simple way of
      annotating the <literal>hbm.xml</literal> with information, so tools have
      a natural place to store/read information that is not directly related to
      the Hibernate core.</para>
    <para>You can use the <literal>&lt;meta&gt;</literal> tag to e.g.
      tell <literal>hbm2java</literal> to only generate "protected" setters,
      have classes always implement a certain set of interfaces or even have
      them extend a certain base class and even more.</para>
    <para>The following example shows how to use various &lt;meta&gt;
      attributes and the resulting java code.</para>
    <programlisting><![CDATA[<class name="Person">
    <meta attribute="class-description">
        Javadoc for the Person class
        @author Frodo
    </meta>
    <meta attribute="implements">IAuditable</meta>
    <id name="id" type="long">
        <meta attribute="scope-set">protected</meta>
        <generator class="increment"/>
    </id>
    <property name="name" type="string">
        <meta attribute="field-description">The name of the person</meta>
    </property>
</class>]]></programlisting>
    <para>The above hbm.xml will produce something like the following (code
      shortened for better understanding). Notice the Javadoc comment and the
      protected set methods:</para>
    <programlisting><![CDATA[// default package

import java.io.Serializable;
import org.apache.commons.lang.builder.EqualsBuilder;
import org.apache.commons.lang.builder.HashCodeBuilder;
import org.apache.commons.lang.builder.ToStringBuilder;

/** 
 *         Javadoc for the Person class
 *         @author Frodo
 */
public class Person implements Serializable, IAuditable {

    public Long id;

    public String name;

    public Person(java.lang.String name) {
        this.name = name;
    }

    public Person() {
    }

    public java.lang.Long getId() {
        return this.id;
    }

    protected void setId(java.lang.Long id) {
        this.id = id;
    }

    /** 
     * The name of the person
     */
    public java.lang.String getName() {
        return this.name;
    }

    public void setName(java.lang.String name) {
        this.name = name;
    }

}]]></programlisting>
    <table frame="topbot">
      <title>Supported meta tags</title>
      <tgroup cols="2">
        <colspec colwidth="1.5*"/>
        <colspec colwidth="2*"/>
        <thead>
          <row>
            <entry>Attribute</entry>
            <entry>Description</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>
              <literal>class-description</literal>
            </entry>
            <entry>inserted into the javadoc for classes</entry>
          </row>
          <row>
            <entry>
              <literal>field-description</literal>
            </entry>
            <entry>inserted into the javadoc for fields/properties</entry>
          </row>
          <row>
            <entry>
              <literal>interface</literal>
            </entry>
            <entry>If true an interface is generated instead of an
            class.</entry>
          </row>
          <row>
            <entry>
              <literal>implements</literal>
            </entry>
            <entry>interface the class should implement</entry>
          </row>
          <row>
            <entry>
              <literal>extends</literal>
            </entry>
            <entry>class the class should extend (ignored for
            subclasses)</entry>
          </row>
          <row>
            <entry>
              <literal>generated-class</literal>
            </entry>
            <entry>overrule the name of the actual class generated</entry>
          </row>
          <row>
            <entry>
              <literal>scope-class</literal>
            </entry>
            <entry>scope for class</entry>
          </row>
          <row>
            <entry>
              <literal>scope-set</literal>
            </entry>
            <entry>scope for setter method</entry>
          </row>
          <row>
            <entry>
              <literal>scope-get</literal>
            </entry>
            <entry>scope for getter method</entry>
          </row>
          <row>
            <entry>
              <literal>scope-field</literal>
            </entry>
            <entry>scope for actual field</entry>
          </row>
          <row>
            <entry>
              <literal>default-value</literal>
            </entry>
            <entry>default initializatioin value for a field</entry>
          </row>
          <row>
            <entry>
              <literal>use-in-tostring</literal>
            </entry>
            <entry>include this property in the
            <literal>toString()</literal></entry>
          </row>
          <row>
            <entry>
              <literal>use-in-equals</literal>
            </entry>
            <entry>include this property in the <literal>equals()</literal> and
                <literal>hashCode()</literal> method. If no use-in-equals is
              specificed, no equals/hashcode will be generated.</entry>
          </row>
          <row>
            <entry>
              <literal>gen-property</literal>
            </entry>
            <entry>property will not be generated if false (use with
            care)</entry>
          </row>
          <row>
            <entry>
              <literal>property-type</literal>
            </entry>
            <entry>Overrides the default type of property. Use this with any
              tag's to specify the concrete type instead of just Object.</entry>
          </row>
          <row>
            <entry>
              <literal>class-code</literal>
            </entry>
            <entry>Extra code that will inserted at the end of the class</entry>
          </row>
          <row>
            <entry>
              <literal>extra-import</literal>
            </entry>
            <entry>Extra import that will inserted at the end of all other
              imports</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <para>Attributes declared via the <literal>&lt;meta&gt;</literal>
      tag are per default "inherited" inside an <literal>hbm.xml</literal> file.</para>
    <para>What does that mean? It means that if you e.g want to have all your
      classes implement <literal>IAuditable</literal> then you just add an
        <literal>&lt;meta
        attribute="implements"&gt;IAuditable&lt;/meta&gt;</literal>
      in the top of the <literal>hbm.xml</literal> file, just after
        <literal>&lt;hibernate-mapping&gt;</literal>. Now all classes
      defined in that <literal>hbm.xml</literal> file will implement
        <literal>IAuditable</literal>!</para>
    <para>Note: This applies to <emphasis>all</emphasis>
      <literal>&lt;meta&gt;</literal>-tags. Thus it can also e.g. be
      used to specify that all fields should be declare protected, instead of
      the default private. This is done by adding <literal>&lt;meta
        attribute="scope-field"&gt;protected&lt;/meta&gt;</literal>
      at e.g. just under the <literal>&lt;class&gt;</literal> tag and
      all fields of that class will be protected.</para>
    <para>To avoid having a <literal>&lt;meta&gt;</literal>-tag
      inherited then you can simply specify <literal>inherit="false"</literal>
      for the attribute, e.g. <literal>&lt;meta attribute="scope-class"
        inherit="false"&gt;public abstract&lt;/meta&gt;</literal>
      will restrict the "class-scope" to the current class, not the subclasses.</para>
    <section>
      <title>Recomendations</title>
      <para>We expound here some good practices when using
          <literal>&lt;meta&gt;</literal> attributes.</para>
      <section>
        <title>Be aware putting at class scope level <literal>use-in-string,
            use-in-equals</literal> meta attributes when using collections with
            <literal>inverse=true</literal>.</title>
        <para>Le'ts we have two entities: <literal>Person</literal> and
            <literal>Event</literal> and there is bi-directional association
          between them, so we provide the methods:
          <literal>Event.getPersons()</literal> and
          <literal>Person.getEvents()</literal>. If we define at class scope
          level of the <literal>Persona.hbm, Event.hbm</literal> the meta
          attributes: <literal>use-in-string, use-in-equals</literal>:</para>
        <programlisting><![CDATA[<hibernate-mapping>
  <class name="Person">
    <meta attribute="use-in-tostring">true</meta>
    <meta attribute="use-in-equals">true</meta>
    ...
  </class>
</hibernate-mapping>]]></programlisting>
        <para>and for <literal>Event.hbm</literal> file:</para>
        <programlisting><![CDATA[<hibernate-mapping>              
  <class name="events.Event" table="EVENTS">
    <meta attribute="use-in-tostring">true</meta>
    <meta attribute="use-in-equals">true</meta>                  
    <id name="id" column="EVENT_ID">
        <generator class="native"/>
    </id>
    <property name="date" type="timestamp" column="EVENT_DATE"/>
    <property name="title"/>
    <set name="participants" table="PERSON_EVENT" inverse="true">
        <key column="EVENT_ID"/>
        <many-to-many column="PERSON_ID" class="events.Person"/>
    </set>                    
  </class>
</hibernate-mapping>]]></programlisting>
        <para><literal>&lt;hbm2java&gt;</literal> will assume you want
          to include all properties and collections on the
            <literal>toSring()/equals()</literal> methods.</para>
        <para>The generated code will produce infinite loop on the generated
          methods: <literal>toString()/equals()</literal>, for example:</para>
        <programlisting><![CDATA[// default package
// Person Class:
import java.io.Serializable;
public class Person implements Serializable {
  // .... (Omitted)   
  public Set getEvents() {
    return this.events;
  }
  public void setEvents(Set events) {
    this.events = events;
  }
 /**
   * toString
   * @return String
   */
   public String toString() {
    StringBuffer buffer = new StringBuffer();        
      buffer.append(getClass().getName()).append("@").append(Integer.toHexString(hashCode())).append(" [");
      //...			
      buffer.append("events").append("='").append(getEvents()).append("' ");			
      buffer.append("]");              
      return buffer.toString();
   }
   // ...}]]></programlisting>
        <para>and for Event.java:</para>
        <programlisting><![CDATA[// default package
// Event Class:
import java.io.Serializable;
public class Person implements Serializable {
  // .... (Omitted)   
  public Set getPersons() {
    return this.persons;
  }
  public void setParticipants(Set persons) {
    this.participants = participants;
  }
  /**
   * toString
   * @return String
   */
   public String toString() {
     StringBuffer buffer = new StringBuffer();        
     buffer.append(getClass().getName()).append("@").append(Integer.toHexString(hashCode())).append(" [");
     //...			
     buffer.append("participants").append("='").append(getParticipants()).append("' ");			
     buffer.append("]");              
     return buffer.toString();
   }
   // ...}]]></programlisting>
        <para>So when invoking <literal>Person.toString()</literal> you get an
          infinite loop, because it internally invokes the method:
            <literal>Person.getEvents()</literal> and the
            <literal>Set.toString()</literal> method will invoke for each
          element of the set the <literal>toString()</literal> method, so the
          method <literal>Event.toString()</literal> internally invokes
            <literal>Event.getParticipants()</literal>, that again uses
            <literal>Person.toString()</literal> for each element of
            <literal>Event.getParticipantss()</literal> method.</para>
        <para>The same occurs for the <literal>equals()</literal> method. You
          have to decide which side of the association will include the other
          part on the <literal>toString()/equals()</literal> definition.
          Therefore it is not a good practice to put at class scope such meta
          attributes, unless you are defining a leap class (with no inverse
          association)</para>
        <para>We recomend instead of putting the
          <literal>&lt;meta&gt;</literal> attributes
            <literal>use-in-tostring</literal> and
          <literal>use-in-equals</literal> at class scope level just select the
          properties you want to include on methods
          <literal>toString()/equals()</literal> at property scope level:</para>
        <programlisting><![CDATA[<hibernate-mapping>              
  <class name="events.Event" table="EVENTS">                  
    <id name="id" column="EVENT_ID">
      <meta attribute="use-in-tostring">true</meta>
      <meta attribute="use-in-equals">true</meta>      
        <generator class="native"/>
    </id>
    <property name="date" type="timestamp" column="EVENT_DATE"/>
    <property name="title"/>
    <set name="participants" table="PERSON_EVENT" inverse="true">
      <meta attribute="use-in-tostring">true</meta>
      <meta attribute="use-in-equals">true</meta>      
        <key column="EVENT_ID"/>
        <many-to-many column="PERSON_ID" class="events.Person"/>
    </set>                    
  </class>
</hibernate-mapping>]]></programlisting>
        <para>and now for <literal>Person</literal>:</para>
        <programlisting><![CDATA[<hibernate-mapping>
    <class name="Person">
    <meta attribute="class-description">
        Javadoc for the Person class
        @author Frodo
    </meta>
    <meta attribute="implements">IAuditable</meta>
    <id name="id" type="long">
        <meta attribute="scope-set">protected</meta>
        <meta attribute="use-in-tostring">true</meta>        
        <generator class="increment"/>
    </id>
    <property name="name" type="string">
        <meta attribute="field-description">The name of the person</meta>
        <meta attribute="use-in-tostring">true</meta>
    </property>
  </class>
</hibernate-mapping>]]></programlisting>
      </section>
      <section>
        <title>Be aware of putting at class scope level
            <literal>&lt;meta&gt;</literal> attribute
            <literal>use-in-equals</literal></title>
        <para>For <literal>equal()/hashCode()</literal> method generation, you
          also have to take into account that the attributes that participate on
          such method definition, should take into account only attributes with
          business meaning (the name, social security number, etc, but no
          generated id's, for example).</para>
        <para>Hibernate needs a way to distinguish that two instances created
          independently if they are transient object or not, mainly for
          collections. Otherwise there is no way to add new elements to a set if
          Hibernate considers via <literal>equals()/hashCode()</literal> are the
          same. If we define <literal>equals()</literal> method that delegate
          only on information that will be generated when the object become
          persistent, there is no way to distinguish transient element.</para>
        <para>Therefore automatically configuration the generation of
            <literal>equals()/hashCode()</literal> methods specifying at class
          scope level the <literal>&lt;meta&gt;</literal> attribute
            <literal>use-in-equals</literal> could be a dangerous decision that
          could produce non expected side-effect.</para>
      </section>
    </section>
    <section>
      <title>Advanced <literal>&lt;meta&gt;</literal> attribute examples</title>
      <para>On this section we consider some advanced example for configurating
        the code generation via <literal>&lt;meta&gt;</literal>
        attributes, for example defining new custom
          <literal>&lt;meta&gt;</literal> attributes </para>
      <section>
        <title>Generate pre/post-conditions for methods</title>
        <para>Using <literal>source-code</literal>
          <literal>&lt;meta&gt;</literal> attribute, you can add
          addional methods on a given class, nevertheless such
            <literal>&lt;meta&gt;</literal> attribute can not be used at
          property scope level and Hibernatetools does not provide such
            <literal>&lt;meta&gt;</literal> attributes.</para>
        <para>A solution for that is "create" a new template, for example
          modifying the freemarker template responsable for generating the
          POJO's. If you look inside <literal>hibernate-tools.jar</literal>, you can find the
          template: <literal>pojo/PojoPropertyAccessor.ftl</literal></para>
        <para>Extract the <literal>PojoPropertyAccessor.ftl</literal> into a
          local folder i.e. <literal>${hbm.template.path}</literal>, respecting
          the hole path, for example:
            <literal>${hbm.template.path}/pojo/PojoPropertyAccessor.ftl</literal></para>
        <para>If you look in to the file you can detect easy where is generated
          the <literal>set</literal> method.</para>
        <programlisting><![CDATA[${pojo.getPropertySetModifiers(property)} void set${pojo.getPropertyName(property)}(${pojo.getJavaTypeName(property, jdk5)} ${property.name}) {
  this.${property.name} = ${property.name};
}]]></programlisting>
        <para>We can add conditionally pre/post-conditions on our <literal>set</literal>
        method generation just adding a little Freemarker syntax to the
        above source code:</para>
        <programlisting><![CDATA[${pojo.getPropertySetModifiers(property)} void set${pojo.getPropertyName(property)}(${pojo.getJavaTypeName(property, jdk5)} ${property.name}) {
  <#if pojo.hasMetaAttribute(property, "pre-cond")> 
    ${c2j.getMetaAsString(property, "pre-cond","\n")} 
  </#if>      
  this.${property.name} = ${property.name};
  <#if pojo.hasMetaAttribute(property, "post-cond")> 
    ${c2j.getMetaAsString(property, "post-cond","\n")} 
  </#if>        
}]]></programlisting>
        <para>Now if in any <literal>*hbm.xml</literal> file we define
        the <literal>&lt;meta&gt;</literal> attributes: <literal>pre-cond</literal>
        or <literal>post-cond</literal>, its values will be introduced on the 
        body of the generated <literal>set</literal> method.</para>
        
        <para>Let's say we want to add pre-condition for property 
        <literal>name</literal> preventing no <literal>Person</literal> can have
        an empty name. So we have to modify the <literal>Person.hbm.xml</literal>
        file like this:</para>
        <programlisting><![CDATA[<hibernate-mapping>
  <class name="Person">
  <id name="id" type="long">        
      <generator class="increment"/>
  </id>
  <property name="name" type="string">
      <meta attribute="pre-cond"><![CDATA[
      if ((${property.name} != null) && (${property.name}.length() == 0) ) {
        throw new IllegalArgumentException("name can not be an empty String");
      }]]>]]&gt;<![CDATA[
      </meta>
  </property>
</class>
</hibernate-mapping>]]></programlisting>
        <para>Notes: i) If you don't use
          <literal>&lt;[[CDATA[]]&gt;</literal> you have to scape the
          &amp; symbol, i.e.: &amp;amp; ii) We can use an <literal>assert</literal>
          condition, but remember it is not a good practice for public methods.</para>
        <para>Finally we have to generate the <literal>Person.java</literal>
          class, so we have to configure
          <literal>&lt;hibernatetool&gt;</literal> task in order to look into
          our modified template class first. We can do this via
            <literal>templatepath</literal> attribute on: </para>
        <programlisting><![CDATA[
    <target name="hbm2java">
        <taskdef name="hibernatetool"
          classname="org.hibernate.tool.ant.HibernateToolTask"
          classpathref="lib.classpath"/>
        <hibernatetool destdir="${hbm2java.dest.dir}"
          templatepath="${hbm.template.path}">
          <classpath>
            <path refid="junit.classpath"/>
          </classpath>        
          <configuration>
            <fileset dir="${hbm2java.src.dir}">
              <include name="**/*.hbm.xml"/>
              <exclude name="**/queries*.hbm.xml"/>
            </fileset>
          </configuration>
          <hbm2java/>
        </hibernatetool>
    </target>]]></programlisting>
        <para>Invoking the target <literal>&lt;hbm2java&gt;</literal>
          will generate on the <literal>${hbm2java.dest.dir}</literal> the file:
            <literal>Person.java</literal>:</para>
        <programlisting><![CDATA[// default package
import java.io.Serializable;
public class Person implements Serializable {

    public Long id;

    public String name;

    public Person(java.lang.String name) {
        this.name = name;
    }

    public Person() {
    }

    public java.lang.Long getId() {
        return this.id;
    }

    public void setId(java.lang.Long id) {
        this.id = id;
    }
    
    public java.lang.String getName() {
        return this.name;
    }

    public void setName(java.lang.String name) {
        if ((name != null) && (name.length() == 0)) {
            throw new IllegalArgumentException("name can not be an empty String");
        }
        this.name = name;
    }
}]]></programlisting>
        <para>In a similar way a post-condition could be added.</para>
      </section>
    </section>
  </section>
</chapter>
