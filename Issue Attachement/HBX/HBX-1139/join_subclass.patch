Index: tools/src/java/org/hibernate/cfg/DelegatedJoinedSubclass.java
===================================================================
--- tools/src/java/org/hibernate/cfg/DelegatedJoinedSubclass.java	(revision 0)
+++ tools/src/java/org/hibernate/cfg/DelegatedJoinedSubclass.java	(revision 0)
@@ -0,0 +1,500 @@
+package org.hibernate.cfg;
+
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+
+import org.hibernate.EntityMode;
+import org.hibernate.MappingException;
+import org.hibernate.dialect.Dialect;
+import org.hibernate.engine.ExecuteUpdateResultCheckStyle;
+import org.hibernate.engine.Mapping;
+import org.hibernate.mapping.Component;
+import org.hibernate.mapping.Join;
+import org.hibernate.mapping.JoinedSubclass;
+import org.hibernate.mapping.KeyValue;
+import org.hibernate.mapping.MetaAttribute;
+import org.hibernate.mapping.PersistentClass;
+import org.hibernate.mapping.Property;
+import org.hibernate.mapping.RootClass;
+import org.hibernate.mapping.Subclass;
+import org.hibernate.mapping.Table;
+import org.hibernate.mapping.Value;
+
+public class DelegatedJoinedSubclass extends JoinedSubclass {
+
+	private final PersistentClass subclass;
+
+	public DelegatedJoinedSubclass(PersistentClass superclass, PersistentClass subclass) {
+		super(superclass);
+		this.subclass= subclass;
+		setKey(superclass.getKey());
+		setTable(subclass.getTable());
+		superclass.addSubclass(this);
+	}
+
+	public void addFilter(String name, String condition) {
+		subclass.addFilter(name, condition);
+	}
+
+	public void addJoin(Join join) {
+		subclass.addJoin(join);
+	}
+
+	public void addProperty(Property p) {
+		subclass.addProperty(p);
+	}
+
+	public void addSynchronizedTable(String table) {
+		subclass.addSynchronizedTable(table);
+	}
+
+	public void addTuplizer(EntityMode entityMode, String implClassName) {
+		subclass.addTuplizer(entityMode, implClassName);
+	}
+
+	public void createPrimaryKey() {
+		subclass.createPrimaryKey();
+	}
+
+	public boolean equals(Object obj) {
+		return subclass.equals(obj);
+	}
+
+	public int getBatchSize() {
+		return subclass.getBatchSize();
+	}
+
+	public String getCacheConcurrencyStrategy() {
+		return subclass.getCacheConcurrencyStrategy();
+	}
+
+	public String getClassName() {
+		return subclass.getClassName();
+	}
+
+	public String getCustomSQLDelete() {
+		return subclass.getCustomSQLDelete();
+	}
+
+	public ExecuteUpdateResultCheckStyle getCustomSQLDeleteCheckStyle() {
+		return subclass.getCustomSQLDeleteCheckStyle();
+	}
+
+	public String getCustomSQLInsert() {
+		return subclass.getCustomSQLInsert();
+	}
+
+	public ExecuteUpdateResultCheckStyle getCustomSQLInsertCheckStyle() {
+		return subclass.getCustomSQLInsertCheckStyle();
+	}
+
+	public String getCustomSQLUpdate() {
+		return subclass.getCustomSQLUpdate();
+	}
+
+	public ExecuteUpdateResultCheckStyle getCustomSQLUpdateCheckStyle() {
+		return subclass.getCustomSQLUpdateCheckStyle();
+	}
+
+	public Iterator getDirectSubclasses() {
+		return subclass.getDirectSubclasses();
+	}
+
+	public Value getDiscriminator() {
+		return subclass.getDiscriminator();
+	}
+
+	public String getDiscriminatorValue() {
+		return subclass.getDiscriminatorValue();
+	}
+
+	public String getEntityName() {
+		return subclass.getEntityName();
+	}
+
+	public Class getEntityPersisterClass() {
+		return subclass.getEntityPersisterClass();
+	}
+
+	public Map getFilterMap() {
+		return subclass.getFilterMap();
+	}
+
+	public KeyValue getIdentifier() {
+		return subclass.getIdentifier();
+	}
+
+	public Component getIdentifierMapper() {
+		return subclass.getIdentifierMapper();
+	}
+
+	public Property getIdentifierProperty() {
+		return subclass.getIdentifierProperty();
+	}
+
+	public Table getIdentityTable() {
+		return subclass.getIdentityTable();
+	}
+
+	public Iterator getJoinClosureIterator() {
+		return subclass.getJoinClosureIterator();
+	}
+
+	public int getJoinClosureSpan() {
+		return subclass.getJoinClosureSpan();
+	}
+
+	public Iterator getJoinIterator() {
+		return subclass.getJoinIterator();
+	}
+
+	public int getJoinNumber(Property prop) {
+		return subclass.getJoinNumber(prop);
+	}
+
+	public Iterator getKeyClosureIterator() {
+		return subclass.getKeyClosureIterator();
+	}
+
+	public String getLoaderName() {
+		return subclass.getLoaderName();
+	}
+
+	public Class getMappedClass() throws MappingException {
+		return subclass.getMappedClass();
+	}
+
+	public MetaAttribute getMetaAttribute(String name) {
+		return subclass.getMetaAttribute(name);
+	}
+
+	public Map getMetaAttributes() {
+		return subclass.getMetaAttributes();
+	}
+
+	public String getNodeName() {
+		return subclass.getNodeName();
+	}
+
+	public int getOptimisticLockMode() {
+		return subclass.getOptimisticLockMode();
+	}
+
+	public Property getProperty(String propertyName) throws MappingException {
+		return subclass.getProperty(propertyName);
+	}
+
+	public Iterator getPropertyClosureIterator() {
+		return subclass.getPropertyClosureIterator();
+	}
+
+	public int getPropertyClosureSpan() {
+		return subclass.getPropertyClosureSpan();
+	}
+
+	public Iterator getPropertyIterator() {
+		return subclass.getPropertyIterator();
+	}
+
+	public Class getProxyInterface() {
+		return subclass.getProxyInterface();
+	}
+
+	public String getProxyInterfaceName() {
+		return subclass.getProxyInterfaceName();
+	}
+
+	public Property getRecursiveProperty(String propertyPath)
+			throws MappingException {
+		return subclass.getRecursiveProperty(propertyPath);
+	}
+
+	public Property getReferencedProperty(String propertyPath)
+			throws MappingException {
+		return subclass.getReferencedProperty(propertyPath);
+	}
+
+	public RootClass getRootClass() {
+		return subclass.getRootClass();
+	}
+
+	public Table getRootTable() {
+		return subclass.getRootTable();
+	}
+
+	public Iterator getSubclassClosureIterator() {
+		return subclass.getSubclassClosureIterator();
+	}
+
+	public int getSubclassId() {
+		return subclass.getSubclassId();
+	}
+
+	public Iterator getSubclassIterator() {
+		return subclass.getSubclassIterator();
+	}
+
+	public Iterator getSubclassJoinClosureIterator() {
+		return subclass.getSubclassJoinClosureIterator();
+	}
+
+	public Iterator getSubclassPropertyClosureIterator() {
+		return subclass.getSubclassPropertyClosureIterator();
+	}
+
+	public int getSubclassSpan() {
+		return subclass.getSubclassSpan();
+	}
+
+	public Iterator getSubclassTableClosureIterator() {
+		return subclass.getSubclassTableClosureIterator();
+	}
+
+	public Set getSynchronizedTables() {
+		return subclass.getSynchronizedTables();
+	}
+
+	public Iterator getTableClosureIterator() {
+		return subclass.getTableClosureIterator();
+	}
+
+	public String getTemporaryIdTableDDL() {
+		return subclass.getTemporaryIdTableDDL();
+	}
+
+	public String getTemporaryIdTableName() {
+		return subclass.getTemporaryIdTableName();
+	}
+
+	public String getTuplizerImplClassName(EntityMode mode) {
+		return subclass.getTuplizerImplClassName(mode);
+	}
+
+	public Map getTuplizerMap() {
+		return subclass.getTuplizerMap();
+	}
+
+	public Iterator getUnjoinedPropertyIterator() {
+		return subclass.getUnjoinedPropertyIterator();
+	}
+
+	public Property getVersion() {
+		return subclass.getVersion();
+	}
+
+	public String getWhere() {
+		return subclass.getWhere();
+	}
+
+	public boolean hasDom4jRepresentation() {
+		return subclass.hasDom4jRepresentation();
+	}
+
+	public boolean hasEmbeddedIdentifier() {
+		return subclass.hasEmbeddedIdentifier();
+	}
+
+	public int hashCode() {
+		return subclass.hashCode();
+	}
+
+	public boolean hasIdentifierMapper() {
+		return subclass.hasIdentifierMapper();
+	}
+
+	public boolean hasIdentifierProperty() {
+		return subclass.hasIdentifierProperty();
+	}
+
+	public boolean hasNaturalId() {
+		return subclass.hasNaturalId();
+	}
+
+	public boolean hasPojoRepresentation() {
+		return subclass.hasPojoRepresentation();
+	}
+
+	public boolean hasSelectBeforeUpdate() {
+		return subclass.hasSelectBeforeUpdate();
+	}
+
+	public boolean hasSubclasses() {
+		return subclass.hasSubclasses();
+	}
+
+	public boolean hasSubselectLoadableCollections() {
+		return subclass.hasSubselectLoadableCollections();
+	}
+
+	public Boolean isAbstract() {
+		return subclass.isAbstract();
+	}
+
+	public boolean isClassOrSuperclassJoin(Join join) {
+		return subclass.isClassOrSuperclassJoin(join);
+	}
+
+	public boolean isClassOrSuperclassTable(Table closureTable) {
+		return subclass.isClassOrSuperclassTable(closureTable);
+	}
+
+	public boolean isCustomDeleteCallable() {
+		return subclass.isCustomDeleteCallable();
+	}
+
+	public boolean isCustomInsertCallable() {
+		return subclass.isCustomInsertCallable();
+	}
+
+	public boolean isCustomUpdateCallable() {
+		return subclass.isCustomUpdateCallable();
+	}
+
+	public boolean isDiscriminatorInsertable() {
+		return subclass.isDiscriminatorInsertable();
+	}
+
+	public boolean isDiscriminatorValueNotNull() {
+		return subclass.isDiscriminatorValueNotNull();
+	}
+
+	public boolean isDiscriminatorValueNull() {
+		return subclass.isDiscriminatorValueNull();
+	}
+
+	public boolean isExplicitPolymorphism() {
+		return subclass.isExplicitPolymorphism();
+	}
+
+	public boolean isForceDiscriminator() {
+		return subclass.isForceDiscriminator();
+	}
+
+	public boolean isInherited() {
+		return subclass.isInherited();
+	}
+
+	public boolean isJoinedSubclass() {
+		return subclass.isJoinedSubclass();
+	}
+
+	public boolean isLazy() {
+		return subclass.isLazy();
+	}
+
+	public boolean isLazyPropertiesCacheable() {
+		return subclass.isLazyPropertiesCacheable();
+	}
+
+	public boolean isMutable() {
+		return subclass.isMutable();
+	}
+
+	public boolean isPolymorphic() {
+		return subclass.isPolymorphic();
+	}
+
+	public boolean isVersioned() {
+		return subclass.isVersioned();
+	}
+
+	public void prepareTemporaryTables(Mapping mapping, Dialect dialect) {
+		subclass.prepareTemporaryTables(mapping, dialect);
+	}
+
+	public void setAbstract(Boolean isAbstract) {
+		subclass.setAbstract(isAbstract);
+	}
+
+	public void setBatchSize(int batchSize) {
+		subclass.setBatchSize(batchSize);
+	}
+
+	public void setClassName(String className) {
+		subclass.setClassName(className);
+	}
+
+	public void setCustomSQLDelete(String customSQLDelete, boolean callable,
+			ExecuteUpdateResultCheckStyle checkStyle) {
+		subclass.setCustomSQLDelete(customSQLDelete, callable, checkStyle);
+	}
+
+	public void setCustomSQLInsert(String customSQLInsert, boolean callable,
+			ExecuteUpdateResultCheckStyle checkStyle) {
+		subclass.setCustomSQLInsert(customSQLInsert, callable, checkStyle);
+	}
+
+	public void setCustomSQLUpdate(String customSQLUpdate, boolean callable,
+			ExecuteUpdateResultCheckStyle checkStyle) {
+		subclass.setCustomSQLUpdate(customSQLUpdate, callable, checkStyle);
+	}
+
+	public void setDiscriminatorValue(String discriminatorValue) {
+		subclass.setDiscriminatorValue(discriminatorValue);
+	}
+
+	public void setDynamicInsert(boolean dynamicInsert) {
+		subclass.setDynamicInsert(dynamicInsert);
+	}
+
+	public void setDynamicUpdate(boolean dynamicUpdate) {
+		subclass.setDynamicUpdate(dynamicUpdate);
+	}
+
+	public void setEntityName(String entityName) {
+		subclass.setEntityName(entityName);
+	}
+
+	public void setEntityPersisterClass(Class classPersisterClass) {
+		subclass.setEntityPersisterClass(classPersisterClass);
+	}
+
+	public void setIdentifierMapper(Component handle) {
+		subclass.setIdentifierMapper(handle);
+	}
+
+	public void setLazy(boolean lazy) {
+		subclass.setLazy(lazy);
+	}
+
+	public void setLoaderName(String loaderName) {
+		subclass.setLoaderName(loaderName);
+	}
+
+	public void setMetaAttributes(Map metas) {
+		subclass.setMetaAttributes(metas);
+	}
+
+	public void setNodeName(String nodeName) {
+		subclass.setNodeName(nodeName);
+	}
+
+	public void setOptimisticLockMode(int optimisticLockMode) {
+		subclass.setOptimisticLockMode(optimisticLockMode);
+	}
+
+	public void setProxyInterfaceName(String proxyInterfaceName) {
+		subclass.setProxyInterfaceName(proxyInterfaceName);
+	}
+
+	public void setSelectBeforeUpdate(boolean selectBeforeUpdate) {
+		subclass.setSelectBeforeUpdate(selectBeforeUpdate);
+	}
+
+	public void setSubselectLoadableCollections(boolean hasSubselectCollections) {
+		subclass.setSubselectLoadableCollections(hasSubselectCollections);
+	}
+
+	public String toString() {
+		return subclass.toString();
+	}
+
+	public boolean useDynamicInsert() {
+		return subclass.useDynamicInsert();
+	}
+
+	public boolean useDynamicUpdate() {
+		return subclass.useDynamicUpdate();
+	}
+}
Index: tools/src/java/org/hibernate/cfg/JDBCBinder.java
===================================================================
--- tools/src/java/org/hibernate/cfg/JDBCBinder.java	(revision 17381)
+++ tools/src/java/org/hibernate/cfg/JDBCBinder.java	(working copy)
@@ -21,9 +21,8 @@
 import org.hibernate.DuplicateMappingException;
 import org.hibernate.FetchMode;
 import org.hibernate.MappingException;
+import org.hibernate.cfg.reveng.AssociationInfo;
 import org.hibernate.cfg.reveng.DatabaseCollector;
-import org.hibernate.cfg.reveng.ForeignKeyCollectionInfo;
-import org.hibernate.cfg.reveng.AssociationInfo;
 import org.hibernate.cfg.reveng.JDBCReader;
 import org.hibernate.cfg.reveng.JDBCToHibernateTypeHelper;
 import org.hibernate.cfg.reveng.MappingsDatabaseCollector;
@@ -37,11 +36,12 @@
 import org.hibernate.mapping.Component;
 import org.hibernate.mapping.DependantValue;
 import org.hibernate.mapping.ForeignKey;
+import org.hibernate.mapping.JoinedSubclass;
 import org.hibernate.mapping.KeyValue;
 import org.hibernate.mapping.ManyToOne;
-import org.hibernate.mapping.OneToOne;
 import org.hibernate.mapping.MetaAttribute;
 import org.hibernate.mapping.OneToMany;
+import org.hibernate.mapping.OneToOne;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
 import org.hibernate.mapping.RootClass;
@@ -185,7 +185,8 @@
 			updatePrimaryKey(rc, pki);
 
 		}
-
+		
+		cfg.inheritenceSecondPass();
 	}
 
 	private void updatePrimaryKey(RootClass rc, PrimaryKeyInfo pki) {
@@ -243,7 +244,9 @@
 						TableIdentifier.create(foreignKey.getReferencedTable() ),
 						foreignKey.getReferencedColumns())) {
 					log.debug("Rev.eng excluded one-to-many or one-to-one for foreignkey " + foreignKey.getName());
-				} else if (revengStrategy.isOneToOne(foreignKey)){
+	            } else if (revengStrategy.isJoinSubclass(foreignKey)){
+	            	// nothing to do
+				} else if (revengStrategy.isOneToOne(foreignKey)){				
 					Property property = bindOneToOne(rc, foreignKey.getTable(), foreignKey, processed, false, true);
 					rc.addProperty(property);
 				} else {
@@ -254,12 +257,24 @@
 		}
 	}
 
-
+	private void bindJoinedSubclass(final String superClassName, final PersistentClass subClass) {
+		mappings.addSecondPass(new JDBCMetaDataConfiguration.InheritenceSecondPass() {
+			public void doSecondPass(Map persistentClasses) throws MappingException {
+				PersistentClass superClass= (PersistentClass) persistentClasses.get(superClassName);
+				if(superClass==null) {
+					throw new JDBCBinderException("Missing superclass '" + superClassName + "' for '" + subClass.getClassName());
+				}
+				JoinedSubclass jsc= new DelegatedJoinedSubclass(superClass, subClass);
+				persistentClasses.put(jsc.getClassName(), jsc);
+			}
+		});
+	}
+	
     private Property bindOneToOne(PersistentClass rc, Table targetTable,
             ForeignKey fk, Set processedColumns, boolean constrained, boolean inverseProperty) {
 
 
-        OneToOne value = new OneToOne(targetTable, rc);
+        OneToOne value = new OneToOne(fk.getTable(), rc);
         value.setReferencedEntityName(revengStrategy
                 .tableToClassName(TableIdentifier.create(targetTable)));
 
@@ -675,6 +690,8 @@
         			foreignKey.getReferencedColumns())) {
             	// TODO: if many-to-one is excluded should the column be marked as processed so it won't show up at all ?
             	log.debug("Rev.eng excluded *-to-one for foreignkey " + foreignKey.getName());
+            } else if (revengStrategy.isJoinSubclass(foreignKey)){
+            	bindJoinedSubclass(foreignKey.getReferencedEntityName(), rc);
             } else if (revengStrategy.isOneToOne(foreignKey)){
 				Property property = bindOneToOne(rc, foreignKey.getReferencedTable(), foreignKey, processedColumns, true, false);
 				rc.addProperty(property);
@@ -1129,5 +1146,4 @@
 
         }
     }
-
 }
Index: tools/src/java/org/hibernate/cfg/JDBCMetaDataConfiguration.java
===================================================================
--- tools/src/java/org/hibernate/cfg/JDBCMetaDataConfiguration.java	(revision 17381)
+++ tools/src/java/org/hibernate/cfg/JDBCMetaDataConfiguration.java	(working copy)
@@ -4,6 +4,7 @@
  */
 package org.hibernate.cfg;
 
+import java.util.Iterator;
 import java.util.Set;
 
 import org.apache.commons.logging.Log;
@@ -106,4 +107,17 @@
 		return revEngStrategy;
 	}
 
+	public void inheritenceSecondPass() {
+		for(Iterator spi= secondPasses.iterator(); spi.hasNext();) {
+			Object sp= spi.next();
+			if(sp instanceof InheritenceSecondPass) {
+				((InheritenceSecondPass)sp).doSecondPass(classes);
+				spi.remove();
+			}
+		}
+	}
+
+	public static interface InheritenceSecondPass extends SecondPass {
+	}
+
 }
Index: tools/src/java/org/hibernate/cfg/reveng/DefaultReverseEngineeringStrategy.java
===================================================================
--- tools/src/java/org/hibernate/cfg/reveng/DefaultReverseEngineeringStrategy.java	(revision 17381)
+++ tools/src/java/org/hibernate/cfg/reveng/DefaultReverseEngineeringStrategy.java	(working copy)
@@ -16,6 +16,7 @@
 import org.hibernate.mapping.ForeignKey;
 import org.hibernate.mapping.PrimaryKey;
 import org.hibernate.mapping.Table;
+import org.hibernate.mapping.UniqueKey;
 import org.hibernate.util.StringHelper;
 
 public class DefaultReverseEngineeringStrategy implements ReverseEngineeringStrategy {
@@ -238,30 +239,114 @@
 		this.settings = settings;		
 	}
 
-	public boolean isOneToOne(ForeignKey foreignKey) {
-		if(settings.getDetectOneToOne()) {
-			// add support for non-PK associations
-			List fkColumns = foreignKey.getColumns();
-			List pkForeignTableColumns = null;
-			
-			if (foreignKey.getTable().hasPrimaryKey())
-				pkForeignTableColumns = foreignKey.getTable().getPrimaryKey().getColumns();
+	static private Set getColumns(Iterator it) {
+		Set columns = new HashSet();
+		while ( it.hasNext() ) {
+			columns.add( it.next() );
+		}
+		return columns;
+	}
 
-			boolean equals =
-				fkColumns != null && pkForeignTableColumns != null
-				&& fkColumns.size() == pkForeignTableColumns.size();
+	static private boolean hasEqualColumns(Set joinColumns, Iterator it) {
+		while(it.hasNext()) {
+			if( !joinColumns.contains(it.next()) ) {
+				return false;
+			}
+		}
+		return true;
+	}	
 
-			Iterator columns = foreignKey.getColumnIterator();
-			while (equals && columns.hasNext()) {
-				Column fkColumn = (Column) columns.next();
-				equals = equals && pkForeignTableColumns.contains(fkColumn);
+	private static boolean isMatch(Iterator left, Iterator right) {		
+		while(right.hasNext()) {
+			if(!left.hasNext()) {
+				return false;
 			}
-
-			return equals;
+			if(!left.next().equals(right.next())) {
+				return false;
+			}
+		}
+		return !left.hasNext();
+	}
+	
+	private static UniqueKey findLocalUniqueKey(ForeignKey foreignKey) {
+		Set joinColumns= getColumns(foreignKey.columnIterator());
+		Iterator uniqueKeys= foreignKey.getTable().getUniqueKeyIterator();
+		while(uniqueKeys.hasNext()) {
+			UniqueKey key= (UniqueKey)uniqueKeys.next();
+			if(hasEqualColumns(joinColumns, key.getColumnIterator())) {
+				return key;
+			}
+		}
+		return null;
+	}
+	
+	private static UniqueKey findReferencedUniqueKey(ForeignKey foreignKey) {
+		Set joinColumns;
+		if(foreignKey.isReferenceToPrimaryKey()) {
+			joinColumns= getColumns(foreignKey.getReferencedTable().getPrimaryKey().getColumnIterator());
+		}
+		else {
+			joinColumns= getColumns(foreignKey.getColumnIterator());
+		}
+		
+		Iterator uniqueKeys= foreignKey.getReferencedTable().getUniqueKeyIterator();
+		while(uniqueKeys.hasNext()) {
+			UniqueKey key= (UniqueKey)uniqueKeys.next();
+			if(hasEqualColumns(joinColumns, key.getColumnIterator())) {
+				return key;
+			}
+		}
+		return null;
+	}
+	
+	/**
+	 * Determine the degreeOfConstraint that the ForeignKey has
+	 * @param foreignKey The fk to check
+	 * @param checkPrimaryKeys true to additionally check that matched unique keys are primary
+	 * @return if checkPrimaryKeys is false and ForeignKey represents 1:1 relation (unique keys on each side)
+	 * or checkPrimaryKeys is true ForeignKey represents 1:1 relation on primary keys; otherwise false
+	 */
+	private static boolean degreeOfConstraint(ForeignKey foreignKey, boolean checkPrimaryKeys) {
+		UniqueKey remoteUnique= null;
+		if(!foreignKey.isReferenceToPrimaryKey()) {
+			remoteUnique= findReferencedUniqueKey(foreignKey);
+			if(remoteUnique==null) {
+				return false;
+			}
+		}
+		
+		UniqueKey localUnique= findLocalUniqueKey(foreignKey);
+		if(localUnique==null) {
+			return false;
+		}
+		if(!checkPrimaryKeys) {
+			return true;
+		}
+		
+		if(!isMatch(foreignKey.getTable().getPrimaryKey().columnIterator(), localUnique.columnIterator())) {
+			return false;
+		}
+		if(remoteUnique!=null && !isMatch(foreignKey.getReferencedTable().getPrimaryKey().columnIterator(), remoteUnique.columnIterator())) {
+			return false;
+		}
+		return true;
+	}
+	
+	public boolean isOneToOne(ForeignKey foreignKey) {
+		if(settings.getDetectOneToOne()) {
+			return degreeOfConstraint(foreignKey, false);
 		} else {
 			return false;
 		}
     }
+	
+	public boolean isJoinSubclass(ForeignKey foreignKey) {
+		if(settings.getDetectOneToOne()) {
+			return degreeOfConstraint(foreignKey, true);
+		} else {
+			return false;
+		}
+    }
 
 	public boolean isManyToManyTable(Table table) {
 		if(settings.getDetectManyToMany()) {
Index: tools/src/java/org/hibernate/cfg/reveng/DelegatingReverseEngineeringStrategy.java
===================================================================
--- tools/src/java/org/hibernate/cfg/reveng/DelegatingReverseEngineeringStrategy.java	(revision 17381)
+++ tools/src/java/org/hibernate/cfg/reveng/DelegatingReverseEngineeringStrategy.java	(working copy)
@@ -119,13 +119,16 @@
 	}
 
 	public boolean isManyToManyTable(Table table) {
-		return delegate==null?true:delegate.isManyToManyTable( table );
+		return delegate==null?false:delegate.isManyToManyTable( table );
 	}
 	
 	public boolean isOneToOne(ForeignKey foreignKey) { 
-		return delegate==null?true:delegate.isOneToOne( foreignKey );
+		return delegate==null?false:delegate.isOneToOne( foreignKey );
     }
 
+	public boolean isJoinSubclass(ForeignKey foreignKey) { 
+		return delegate==null?false:delegate.isJoinSubclass( foreignKey );
+    }
 
 	public String foreignKeyToManyToManyName(ForeignKey fromKey, TableIdentifier middleTable, ForeignKey toKey, boolean uniqueReference) {
 		return delegate==null?null:delegate.foreignKeyToManyToManyName( fromKey, middleTable, toKey, uniqueReference );
Index: tools/src/testsupport/NoopReverseEngineeringStrategy.java
===================================================================
--- tools/src/testsupport/NoopReverseEngineeringStrategy.java	(revision 17381)
+++ tools/src/testsupport/NoopReverseEngineeringStrategy.java	(working copy)
@@ -169,6 +169,10 @@
 		return false;
 	}
 
+	public boolean isJoinSubclass(ForeignKey foreignKey) {
+		// TODO Auto-generated method stub
+		return false;
+	}
 	
 	public AssociationInfo foreignKeyToAssociationInfo(ForeignKey foreignKey) {
 		// TODO Auto-generated method stub
