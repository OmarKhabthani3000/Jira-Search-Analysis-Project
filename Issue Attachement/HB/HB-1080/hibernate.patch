diff -urb hibernate-2.1/src/net/sf/hibernate/connection/DBCPConnectionProvider.java hibernate-2.1.p/src/net/sf/hibernate/connection/DBCPConnectionProvider.java
--- hibernate-2.1/src/net/sf/hibernate/connection/DBCPConnectionProvider.java	2004-04-26 01:57:02.000000000 +0200
+++ hibernate-2.1.p/src/net/sf/hibernate/connection/DBCPConnectionProvider.java	2004-07-12 19:14:48.000000000 +0200
@@ -76,12 +76,12 @@
 			// actual pool of connections.
 			connectionPool = new GenericObjectPool(
 				null,
-				Integer.parseInt( props.getProperty(Environment.DBCP_MAXACTIVE) ),
-				Byte.parseByte( props.getProperty(Environment.DBCP_WHENEXHAUSTED) ),
-				Long.parseLong( props.getProperty(Environment.DBCP_MAXWAIT) ),
-				Integer.parseInt( props.getProperty(Environment.DBCP_MAXIDLE) ),
-				PropertiesHelper.getBoolean( Environment.DBCP_VALIDATION_ONBORROW, props ),
-				PropertiesHelper.getBoolean( Environment.DBCP_VALIDATION_ONRETURN, props )
+                                PropertiesHelper.getInt(     Environment.DBCP_MAXACTIVE, props, 8),
+				PropertiesHelper.getByte(    Environment.DBCP_WHENEXHAUSTED, props, (byte) 1),
+				PropertiesHelper.getLong(    Environment.DBCP_MAXWAIT, props, -1),
+				PropertiesHelper.getInt(     Environment.DBCP_MAXIDLE, props, 8),
+				PropertiesHelper.getBoolean( Environment.DBCP_VALIDATION_ONBORROW, props , true),
+				PropertiesHelper.getBoolean( Environment.DBCP_VALIDATION_ONRETURN, props , false)
 			);
 			
 			//check whether we use prepare statement caching or not
@@ -94,10 +94,10 @@
 				log.info("DBCP prepared statement pooling enabled");
 				statementPool = new GenericKeyedObjectPoolFactory(
 					null,
-					Integer.parseInt( props.getProperty(Environment.DBCP_PS_MAXACTIVE) ),
-					Byte.parseByte( props.getProperty(Environment.DBCP_PS_WHENEXHAUSTED) ),
-					Long.parseLong( props.getProperty(Environment.DBCP_PS_MAXWAIT) ),
-					Integer.parseInt( props.getProperty(Environment.DBCP_PS_MAXIDLE) )	
+                                        PropertiesHelper.getInt(     Environment.DBCP_PS_MAXACTIVE, props, 8),
+                                        PropertiesHelper.getByte(    Environment.DBCP_PS_WHENEXHAUSTED, props, (byte) 1),
+                                        PropertiesHelper.getLong(    Environment.DBCP_PS_MAXWAIT, props, -1),
+                                        PropertiesHelper.getInt(     Environment.DBCP_PS_MAXIDLE, props, 8)
 				);
 			}
 			
@@ -109,7 +109,8 @@
 			// Now we'll create the PoolableConnectionFactory, which wraps
 			// the "real" Connections created by the ConnectionFactory with
 			// the classes that implement the pooling functionality.
-			String validationQuery = props.getProperty(Environment.DBCP_VALIDATION_QUERY);
+			String validationQuery = PropertiesHelper.getString(Environment.DBCP_VALIDATION_QUERY, props, "SELECT 1");
+
 			new PoolableConnectionFactory(connectionFactory, connectionPool, statementPool, validationQuery, false, false);
 			
 			// Finally, we create the PoolingDriver itself,
diff -urb hibernate-2.1/src/net/sf/hibernate/util/PropertiesHelper.java hibernate-2.1.p/src/net/sf/hibernate/util/PropertiesHelper.java
--- hibernate-2.1/src/net/sf/hibernate/util/PropertiesHelper.java	2004-06-02 14:15:57.000000000 +0200
+++ hibernate-2.1.p/src/net/sf/hibernate/util/PropertiesHelper.java	2004-07-12 19:14:23.000000000 +0200
@@ -38,6 +38,11 @@
 		return (propValue==null) ? null : Integer.valueOf(propValue);
 	}
 	
+	public static byte getByte(String property, Properties properties, byte defaultValue) {
+		String propValue = properties.getProperty(property);
+		return (propValue==null) ? defaultValue : Byte.parseByte(propValue);
+	}
+	
 	public static Map toMap(String property, String delim, Properties properties) {
 		Map map = new HashMap();
 		String propValue = properties.getProperty(property);
