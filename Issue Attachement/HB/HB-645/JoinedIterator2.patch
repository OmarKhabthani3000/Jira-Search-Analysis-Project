Index: JoinedIterator.java
===================================================================
retrieving revision 1.3.2.1
diff -u -r1.3.2.1 JoinedIterator.java
--- JoinedIterator.java	9 Nov 2003 01:46:25 -0000	1.3.2.1
+++ JoinedIterator.java	26 Jan 2004 20:30:21 -0000
@@ -3,13 +3,35 @@
 
 import java.util.Iterator;
 
+import org.apache.commons.collections.IteratorUtils;
+
+/**
+ * An JoinedIterator is an Iterator that wraps a number of Iterators. 
+ * 
+ * This class makes multiple iterators look like one to the caller. 
+ * When any method from the Iterator interface is called, the JoinedIterator
+ * will delegate to a single underlying Iterator. The JoinedIterator will 
+ * invoke the Iterators in sequence until all Iterators are exhausted. 
+ * 
+ */
 public class JoinedIterator implements Iterator {
+    // wrapped iterators
 	private Iterator[] iterators;
-	private int current;
 	
+	// index of current iterator in the wrapped iterators array
+	private int currentIteratorIndex;
+	
+	// the current iterator
+	private Iterator currentIterator;
+	
+	// the last used iterator
+	private Iterator lastUsedIterator;
+	
+
 	public JoinedIterator(Iterator[] iterators) {
+	    if( iterators==null )
+	        throw new NullPointerException("Unexpected NULL iterators argument");
 		this.iterators = iterators;
-		this.current = 0;
 	}
 	
 	public JoinedIterator(Iterator first, Iterator second) {
@@ -17,31 +39,40 @@
 	}
 	
 	public boolean hasNext() {
-		for ( int i = current; i<iterators.length; i++ ) {
-			if ( iterators[i].hasNext() ) return true;
-		}
-		return false;
+	    updateCurrentIterator();
+	    return currentIterator.hasNext();
 	}
 	
 	public Object next() {
-		if ( iterators[current].hasNext() ) {
-			return iterators[current].next();
-		}
-		else {
-			current++;
-			return next();
-		}
+	    updateCurrentIterator();
+	    return currentIterator.next();
 	}
 	
 	public void remove() {
-		iterators[current].remove();
+	    updateCurrentIterator();
+		lastUsedIterator.remove();
 	}
 	
+	
+	// call this before any Iterator method to make sure that the current Iterator
+	// is not exhausted
+	protected void updateCurrentIterator() {
+	    
+	    if (currentIterator == null) {
+	        if( iterators.length==0  ) {
+	            currentIterator = IteratorUtils.EMPTY_ITERATOR;
+	        } 
+	        else {
+	            currentIterator = iterators[0];
+	        }
+	        // set last used iterator here, in case the user calls remove
+	        // before calling hasNext() or next() (although they shouldn't)
+	        lastUsedIterator = currentIterator;
+	    }
+
+	    while (currentIterator.hasNext() == false && currentIteratorIndex < iterators.length - 1) {
+	        currentIteratorIndex++;
+	        currentIterator = iterators[currentIteratorIndex];
+	    }
+	}
 }
-
-
-
-
-
-
-
