Index: JoinedIterator.java
===================================================================
retrieving revision 1.3.2.1
diff -u -r1.3.2.1 JoinedIterator.java
--- JoinedIterator.java	9 Nov 2003 01:46:25 -0000	1.3.2.1
+++ JoinedIterator.java	26 Jan 2004 10:47:32 -0000
@@ -3,11 +3,29 @@
 
 import java.util.Iterator;
 
+/**
+ * An JoinedIterator is an Iterator that wraps a number of Iterators. 
+ * 
+ * This class makes multiple iterators look like one to the caller. 
+ * When any method from the Iterator interface is called, the JoinedIterator
+ * will delegate to a single underlying Iterator. The JoinedIterator will 
+ * invoke the Iterators in sequence until all Iterators are exhausted. 
+ * 
+ * Remark: the JoinedIterator must contain at least one Iterator.
+ */
 public class JoinedIterator implements Iterator {
+    // wrapped iterators
 	private Iterator[] iterators;
+	
+	// index of current iterator in the wrapped iterators array
 	private int current;
 	
+
 	public JoinedIterator(Iterator[] iterators) {
+	    // must have at least one iterator in the array
+	    if( (iterators.length<1) ) {
+	        throw new IllegalArgumentException("JoinedIterator must contain at least one Iterator");
+	    }
 		this.iterators = iterators;
 		this.current = 0;
 	}
@@ -17,26 +35,31 @@
 	}
 	
 	public boolean hasNext() {
-		for ( int i = current; i<iterators.length; i++ ) {
-			if ( iterators[i].hasNext() ) return true;
-		}
-		return false;
+	    updateCurrentIterator();
+	    return iterators[current].hasNext();
 	}
 	
 	public Object next() {
-		if ( iterators[current].hasNext() ) {
-			return iterators[current].next();
-		}
-		else {
-			current++;
-			return next();
-		}
+	    updateCurrentIterator();
+	    return iterators[current].next();
 	}
 	
 	public void remove() {
+	    updateCurrentIterator();
 		iterators[current].remove();
 	}
 	
+	
+	// call this before any Iterator method to make sure that the current Iterator
+	// is not exhausted
+	protected void updateCurrentIterator() {
+
+	    // go to the next iterator until one with some content is found
+	    // or all iterators are exhausted
+	    while ( (iterators[current].hasNext() == false) && (current < (iterators.length - 1)) ) {
+	        ++current;
+	    }
+	}
 }
 
 
