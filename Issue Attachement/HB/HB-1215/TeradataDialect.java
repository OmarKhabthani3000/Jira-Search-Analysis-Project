package net.sf.hibernate.dialect;

import java.sql.Types;

import org.apache.log4j.Logger;

import net.sf.hibernate.MappingException;
import net.sf.hibernate.dialect.Dialect;

/**
 * Teradata Dialect
 *
 * Describe the aspects if Terdata's implementation of SQL that are required
 * to provide Hibernate O/R mapping services.
 *
 * @author John Pianezze jpianezze@telephia.com
 */

public class TeradataDialect extends Dialect
{
	private static final Logger logger = Logger.getLogger(TeradataDialect.class);

	public TeradataDialect()
	{
		super();

		registerColumnType(	Types.BIT, "CHAR");
		registerColumnType(	Types.SMALLINT, "SMALLINT");
		registerColumnType( Types.CHAR, "CHAR" );
		registerColumnType( Types.TINYINT, "BYTEINT");
		registerColumnType( Types.DATE, "DATE" );
		registerColumnType( Types.DOUBLE, "DOUBLE PRECISION" );
		registerColumnType( Types.FLOAT, "FLOAT" );
		registerColumnType( Types.INTEGER, "INTEGER" );
		registerColumnType( Types.NUMERIC, "NUMERIC(19, $l)" );
		registerColumnType(	Types.REAL, "REAL");
		registerColumnType( Types.SMALLINT, "SMALLINT" );
		registerColumnType( Types.TIME, "TIME" );
		registerColumnType( Types.TIMESTAMP, "TIMESTAMP" );
		registerColumnType( Types.VARCHAR, "VARCHAR($l)" );
	}


	// ====================== SEQUENCE NUMBERS ============================
	/*
	 * Teradata does not support sequences, however it is possible to implement
	 * them with a special table, and a Macro to increment the sequence value
	 *
	 * Teradata does support Identity Columns, and Hibernate also supports this type
	 * of key-generation, however, the Teradata support is not sufficient, because
	 * there is no way to know the value of the number that was just generated,
	 * such as Sybase's "select @@identity" or DB2's "IDENTITY_VAL_LOCAL()".
	 *
	 * Since there is no viable way to generate sequence number that is safe for
	 * a multi-user enterprise application, we implement our own Sequence capability.
	 *
	 * Sequence support assumes the following script has been run against the database:
	 * (the arbitrary key exists to anchor the rows to one AMP, for efficiency)
	 *
	 * Create Table hibernate_sequence (
	 * 		sequence_name char(32),
	 *  	sequence_number integer )
	 * 	Unique Primary Index(sequence_name);
	 *
	 * Create Macro next_seq_num (name char(20)) As (
	 * 	Begin transaction;
	 * 		Update hibernate_sequence
	 * 			Set sequence_number = sequence_number + 1
	 *			Where sequence_name = :name;
	 * 		Select sequence_number
	 *			From hibernate_sequence
	 *			Where sequence_name = :name;
	 * 	End transaction;
	 * );
	 *
	 * Insert	Into hibernate_sequence Values( 'hibernate_sequence', 1000 );
	 *
	 * The sequence "hibernate_sequence" is the default name used by hibernate, however
	 * this is customizable by setting a "generator parameter" in the hbm.xml file.
	 * This insert statement is also generated by the Schema generator in the project's ant build.
	 *
	 * @see net.sf.hibernate.dialect.Dialect#supportsSequences()
	 */
	public boolean supportsSequences()
	{
		return true;
	}

	/*
	 * Answer the SQL used to create a new sequence. In this case, we simply insert
	 * a row into the sequence table.
	 *
	 * @see net.sf.hibernate.dialect.Dialect#getCreateSequenceString(java.lang.String)
	 */
	public String getCreateSequenceString(String sequenceName) throws MappingException
	{
		return "INSERT INTO hibernate_sequence VALUES( '"+ sequenceName+"', 1000 )";
	}

	/*
	 * Answer the SQL used to destroy a sequence. In this case, we simply delete
	 * a row from the sequence table.
	 *
	 * @see net.sf.hibernate.dialect.Dialect#getDropSequenceString(java.lang.String)
	 */
	public String getDropSequenceString(String sequenceName) throws MappingException
	{
		return "DELETE FROM hibernate_sequence WHERE sequence_name='"+ sequenceName+"'";
	}

	/*
	 * Answer the SQL used to get a list of sequences that currently exist.
	 * This is used by the Hibernate schema generator, to generate the DDL.
	 *
	 * @see net.sf.hibernate.dialect.Dialect#getQuerySequencesString()
	 */
	public String getQuerySequencesString()
	{
		return "select sequence_name from hibernate_sequence";
	}

	/*
	 * Answer the SQL used to get the next sequence number for a sequenceName.
	 * In this case, we execute the macro, which was previously defined in the database.
	 *
	 * @see net.sf.hibernate.dialect.Dialect#getSequenceNextValString(java.lang.String)
	 */
	public String getSequenceNextValString(String sequenceName) throws MappingException
	{
		return "execute next_seq_num('" + sequenceName + "')";
	}

}
