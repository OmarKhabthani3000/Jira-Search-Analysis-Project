Index: doc/reference/src/collection_mapping.xml
===================================================================
RCS file: /cvsroot/hibernate/Hibernate2/doc/reference/src/collection_mapping.xml,v
retrieving revision 1.6
diff -u -p -B -r1.6 collection_mapping.xml
--- doc/reference/src/collection_mapping.xml	1 Aug 2003 16:33:06 -0000	1.6
+++ doc/reference/src/collection_mapping.xml	23 Sep 2003 20:03:59 -0000
@@ -18,27 +18,27 @@
                 <literal>java.util.SortedMap</literal>,
                 <literal>java.util.SortedSet</literal>,
                 <literal>java.util.List</literal>,
-                and any array of persistent entities or values. Properties of type 
+                and any array of persistent entities or values. Properties of type
                 <literal>java.util.Collection</literal> or
                 <literal>java.util.List</literal>
                 may also be persisted with "bag" semantics.
             </para>
-            
+
             <para>
-                Now the caveat: persistent collections do not retain any extra semantics added by the class 
-                implementing the collection interface (eg. iteration order of a <literal>LinkedHashSet</literal>). 
+                Now the caveat: persistent collections do not retain any extra semantics added by the class
+                implementing the collection interface (eg. iteration order of a <literal>LinkedHashSet</literal>).
                 The persistent collections actually behave like
                 <literal>HashMap</literal>,
                 <literal>HashSet</literal>,
                 <literal>TreeMap</literal>,
                 <literal>TreeSet</literal> and
-                <literal>ArrayList</literal> 
-                respectively. Furthermore, the Java type of a property holding a collection must be 
+                <literal>ArrayList</literal>
+                respectively. Furthermore, the Java type of a property holding a collection must be
                 the interface type (ie. <literal>Map</literal>, <literal>Set</literal> or
                 <literal>List</literal>; never <literal>HashMap</literal>, <literal>TreeSet</literal> or
-                <literal>ArrayList</literal>). This restriction exists because, when you're not looking, 
-                Hibernate sneakily replaces your instances of <literal>Map</literal>, <literal>Set</literal> 
-                and <literal>List</literal> with instances of its own persistent implementations of 
+                <literal>ArrayList</literal>). This restriction exists because, when you're not looking,
+                Hibernate sneakily replaces your instances of <literal>Map</literal>, <literal>Set</literal>
+                and <literal>List</literal> with instances of its own persistent implementations of
                 <literal>Map</literal>, <literal>Set</literal> or <literal>List</literal>. (So also be careful
                 when using <literal>==</literal> on your collections.)
             </para>
@@ -74,11 +74,11 @@ kittens = cat.getKittens(); //Okay, kitt
                 <literal>&lt;composite-element&gt;</literal>, <literal>&lt;one-to-many&gt;</literal> or
                 <literal>&lt;many-to-many&gt;</literal>.
             </para>
-            
+
             <para>
                 All collection types except <literal>Set</literal> and bag have an <emphasis>index
-                </emphasis> column - a column that maps to an array or <literal>List</literal> index or 
-                <literal>Map</literal> key. The index of a <literal>Map</literal> may be of any 
+                </emphasis> column - a column that maps to an array or <literal>List</literal> index or
+                <literal>Map</literal> key. The index of a <literal>Map</literal> may be of any
                 basic type, an entity type or even a composite type (it may not be a collection). The
                 index of an array or list is always of type <literal>integer</literal>. Indexes are
                 mapped using <literal>&lt;index&gt;</literal>, <literal>&lt;index-many-to-many&gt;</literal>
@@ -99,7 +99,7 @@ kittens = cat.getKittens(); //Okay, kitt
             <title>Mapping a Collection</title>
 
             <para>
-                Collections are declared by the 
+                Collections are declared by the
                 <literal>&lt;set&gt;</literal>,
                 <literal>&lt;list&gt;</literal>,
                 <literal>&lt;map&gt;</literal>,
@@ -141,72 +141,72 @@ kittens = cat.getKittens(); //Okay, kitt
                         <para>
                             <literal>name</literal> the collection property name
                         </para>
-                    </callout>                   
+                    </callout>
                     <callout arearefs="mappingcollection2">
                         <para>
                             <literal>table</literal> (optional - defaults to property name) the
                             name of the collection table (not used for one-to-many associations)
                         </para>
-                    </callout>                   
+                    </callout>
                     <callout arearefs="mappingcollection3">
                         <para>
                             <literal>schema</literal> (optional) the name of a table schema to
                             override the schema declared on the root element
                         </para>
-                    </callout>                   
+                    </callout>
                     <callout arearefs="mappingcollection4">
                         <para>
                             <literal>lazy</literal> (optional - defaults to <literal>false</literal>)
                             enable lazy initialization (not used for arrays)
                         </para>
-                    </callout>                   
+                    </callout>
                     <callout arearefs="mappingcollection5">
                         <para>
                             <literal>inverse</literal> (optional - defaults to <literal>false</literal>)
                             mark this collection as the "inverse" end of a bidirectional association
                         </para>
-                    </callout>                   
+                    </callout>
                     <callout arearefs="mappingcollection6">
                         <para>
                             <literal>cascade</literal> (optional - defaults to <literal>none</literal>)
                             enable operations to cascade to child entities
                         </para>
-                    </callout>                   
+                    </callout>
                     <callout arearefs="mappingcollection7">
                         <para>
                             <literal>sort</literal> (optional) specify a sorted collection with
                             <literal>natural</literal> sort order, or a given comparator class
                         </para>
-                    </callout>                   
+                    </callout>
                     <callout arearefs="mappingcollection8">
                         <para>
                             <literal>order-by</literal> (optional, JDK1.4 only) specify a table column (or columns)
-                            that define the iteration order of the <literal>Map</literal>, <literal>Set</literal> 
+                            that define the iteration order of the <literal>Map</literal>, <literal>Set</literal>
                             or bag, together with an optional <literal>asc</literal> or <literal>desc</literal>
                         </para>
-                    </callout>                   
+                    </callout>
                     <callout arearefs="mappingcollection9">
                         <para>
-                            <literal>where</literal> (optional) specify an arbitrary SQL <literal>WHERE</literal> 
-                            condition to be used when retrieving or removing the collection (useful if the 
+                            <literal>where</literal> (optional) specify an arbitrary SQL <literal>WHERE</literal>
+                            condition to be used when retrieving or removing the collection (useful if the
                             collection should contain only a subset of the available data)
                         </para>
-                    </callout>                   
+                    </callout>
                 </calloutlist>
             </programlistingco>
 
             <para>
-                The mapping of a <literal>List</literal> or array requires a seperate table column holding the array 
-                or list index (the <literal>i</literal> in <literal>foo[i]</literal>). If your relational model doesn't 
+                The mapping of a <literal>List</literal> or array requires a seperate table column holding the array
+                or list index (the <literal>i</literal> in <literal>foo[i]</literal>). If your relational model doesn't
                 have an index column, e.g. if you're working with legacy data, use an unordered <literal>Set</literal>
                 instead. This seems to put people off who assume that <literal>List</literal> should just be a more
                 convenient way of accessing an unordered collection. Hibernate collections strictly obey the actual
-                semantics attached to the <literal>Set</literal>, <literal>List</literal> and <literal>Map</literal> 
+                semantics attached to the <literal>Set</literal>, <literal>List</literal> and <literal>Map</literal>
                 interfaces. <literal>List</literal> elements don't just spontaneously rearrange themselves!
             </para>
 
             <para>
-                On the other hand, people who planned to use the <literal>List</literal> to emulate 
+                On the other hand, people who planned to use the <literal>List</literal> to emulate
                 <emphasis>bag</emphasis> semantics have a legitimate grievance here.
                 A bag is an unordered, unindexed collection which may contain the same element multiple times.
                 The Java collections framework lacks a <literal>Bag</literal> interface (though you can emulate
@@ -217,7 +217,7 @@ kittens = cat.getKittens(); //Okay, kitt
             </para>
 
             <para>
-                Large Hibernate bags mapped with <literal>inverse="false"</literal> are inefficient and should be avoided; 
+                Large Hibernate bags mapped with <literal>inverse="false"</literal> are inefficient and should be avoided;
                 Hibernate can't create, delete or update rows individually, because there is no key that may be used to
                 identify an individual row.
             </para>
@@ -228,14 +228,14 @@ kittens = cat.getKittens(); //Okay, kitt
             <title>Collections of Values and Many To Many Associations</title>
 
             <para>
-                A collection table is required for any collection of values and any collection of entities 
-                mapped as a many-to-many association (the natural semantics for a Java collection). The 
+                A collection table is required for any collection of values and any collection of entities
+                mapped as a many-to-many association (the natural semantics for a Java collection). The
                 table requires (foreign) key column(s), element column(s) and possibly index column(s).
             </para>
 
             <para>
                 A collection of entities with its own table corresponds to the relational notion
-                of <emphasis>many-to-many association</emphasis>. A many to many association is the 
+                of <emphasis>many-to-many association</emphasis>. A many to many association is the
                 most natural mapping of a Java collection but is not usually the best relational model.
             </para>
 
@@ -307,7 +307,7 @@ kittens = cat.getKittens(); //Okay, kitt
             <para>
                 A <emphasis>one to many association</emphasis> links the tables of two classes
                 <emphasis>directly</emphasis>, with no intervening collection table.
-                (This implements a <emphasis>one-to-many</emphasis> relational model.) This 
+                (This implements a <emphasis>one-to-many</emphasis> relational model.) This
                 relational model loses some of the semantics of Java collections:
             </para>
 
@@ -332,8 +332,8 @@ kittens = cat.getKittens(); //Okay, kitt
             </itemizedlist>
 
             <para>
-                An association from <literal>Foo</literal> to <literal>Bar</literal> requires the 
-                addition of a key column and possibly an index column to the table of the contained 
+                An association from <literal>Foo</literal> to <literal>Bar</literal> requires the
+                addition of a key column and possibly an index column to the table of the contained
                 entity class, <literal>Bar</literal>.
             </para>
 
@@ -415,36 +415,36 @@ Integer accessLevel = (Integer) permissi
 </set>]]></programlisting>
 
             <para>
-                In some application architectures, particularly where the code that accesses data 
+                In some application architectures, particularly where the code that accesses data
                 using Hibernate, and the code that uses it are in different application layers, it
-                can be a problem to ensure that the <literal>Session</literal> is open when a 
+                can be a problem to ensure that the <literal>Session</literal> is open when a
                 collection is initialized. They are two basic ways to deal with this issue:
             </para>
 
             <itemizedlist>
                 <listitem>
                     <para>
-                        In a web-based application, a servlet filter can be used to close the 
-                        <literal>Session</literal> only at the very end of a user request, once 
-                        the rendering of the view is complete. Of course, this places heavy 
-                        demands upon the correctness of the exception handling of your application 
-                        infrastructure. It is vitally important that the <literal>Session</literal> 
-                        is closed and the transaction ended before returning to the user, even 
-                        when an exception occurs during rendering of the view. The servlet filter 
-                        has to be able to access the <literal>Session</literal> for this approach. 
-                        We recommend that a <literal>ThreadLocal</literal> variable be used to 
+                        In a web-based application, a servlet filter can be used to close the
+                        <literal>Session</literal> only at the very end of a user request, once
+                        the rendering of the view is complete. Of course, this places heavy
+                        demands upon the correctness of the exception handling of your application
+                        infrastructure. It is vitally important that the <literal>Session</literal>
+                        is closed and the transaction ended before returning to the user, even
+                        when an exception occurs during rendering of the view. The servlet filter
+                        has to be able to access the <literal>Session</literal> for this approach.
+                        We recommend that a <literal>ThreadLocal</literal> variable be used to
                         hold the current <literal>Session</literal>.
                     </para>
                 </listitem>
                 <listitem>
                     <para>
                         In an application with a seperate business tier, the business logic must
-                        "prepare" all collections that will be needed by the web tier before 
-                        returning. Usually, the application calls 
+                        "prepare" all collections that will be needed by the web tier before
+                        returning. Usually, the application calls
                         <literal>Hibernate.initialize()</literal> for each collection that will
-                        be needed in the web tier (this call must occur before the session is closed) 
-                        or retrieves the collection eagerly using a query with a <literal>FETCH</literal> 
-                        clause. 
+                        be needed in the web tier (this call must occur before the session is closed)
+                        or retrieves the collection eagerly using a query with a <literal>FETCH</literal>
+                        clause.
                     </para>
                 </listitem>
             </itemizedlist>
@@ -455,13 +455,13 @@ Integer accessLevel = (Integer) permissi
             </para>
 
             <programlisting><![CDATA[( (Integer) s.filter( collection, "select count(*)" ).get(0) ).intValue()]]></programlisting>
-            
+
             <para>
-                <literal>filter()</literal> or <literal>createFilter()</literal> are also used to 
+                <literal>filter()</literal> or <literal>createFilter()</literal> are also used to
                 efficiently retrieve subsets of a collection without needing to initialize the whole
                 collection.
             </para>
-            
+
         </sect1>
 
 
@@ -495,19 +495,19 @@ Integer accessLevel = (Integer) permissi
                 <literal>java.util.TreeMap</literal>.
             </para>
         </sect1>
-        
+
         <sect1 id="collections-s1-8b">
             <title>Other Ways To Sort a Collection</title>
 
             <para>
-                If you want the database itself to order the collection elements use the 
-                <literal>order-by</literal> attribute of <literal>set</literal>, <literal>bag</literal> 
+                If you want the database itself to order the collection elements use the
+                <literal>order-by</literal> attribute of <literal>set</literal>, <literal>bag</literal>
                 or <literal>map</literal> mappings. This solution is only available under
-                JDK 1.4 or higher (it is implemented using <literal>LinkedHashSet</literal> or 
-                <literal>LinkedHashMap</literal>). This performs the ordering in the SQL query, not in 
+                JDK 1.4 or higher (it is implemented using <literal>LinkedHashSet</literal> or
+                <literal>LinkedHashMap</literal>). This performs the ordering in the SQL query, not in
                 memory.
             </para>
-            
+
             <programlisting><![CDATA[<set name="aliases" table="person_aliases" order-by="name asc">
     <key column="person"/>
     <element column="name" type="string"/>
@@ -520,12 +520,12 @@ Integer accessLevel = (Integer) permissi
 </map>]]></programlisting>
 
             <para>
-                Note that the value of the <literal>order-by</literal> attribute is an SQL ordering, not 
+                Note that the value of the <literal>order-by</literal> attribute is an SQL ordering, not
                 a HQL ordering!
             </para>
 
             <para>
-                Associations may even be sorted by some arbitrary criteria at runtime using a 
+                Associations may even be sorted by some arbitrary criteria at runtime using a
                 <literal>filter()</literal>.
             </para>
 
@@ -573,7 +573,7 @@ Integer accessLevel = (Integer) permissi
                         </listitem>
                     </varlistentry>
                 </variablelist>
-            
+
             </para>
 
             <para>
@@ -581,7 +581,7 @@ Integer accessLevel = (Integer) permissi
                 list, map or array values (indexed collections) for the "many" end of a
                 one-to-many association!
             </para>
-            
+
             <para>
                 You may specify a bidirectional many-to-many association simply by mapping two
                 many-to-many associations to the same database table and declaring one end as
@@ -604,13 +604,13 @@ Integer accessLevel = (Integer) permissi
 </class>]]></programlisting>
 
             <para>
-                Changes made only to the inverse end of the association are <emphasis>not</emphasis> 
+                Changes made only to the inverse end of the association are <emphasis>not</emphasis>
                 persisted.
             </para>
 
             <para>
-                You may map a bidirectional one-to-many association by mapping a one-to-many association 
-                to the same table column(s) as a many-to-one association and declaring the many-valued 
+                You may map a bidirectional one-to-many association by mapping a one-to-many association
+                to the same table column(s) as a many-to-one association and declaring the many-valued
                 end <literal>inverse="true"</literal>.
             </para>
 
@@ -640,25 +640,25 @@ Integer accessLevel = (Integer) permissi
         <sect1 id="collections-s1-11a">
             <title>Ternary Associations</title>
             <para>
-            	There are two possible approaches to mapping a ternary association. One approach is to use 
+            	There are two possible approaches to mapping a ternary association. One approach is to use
             	composite elements (discussed below). Another is to use a <literal>Map</literal> with an
             	association as its index.
             </para>
-            	
+
             <programlisting><![CDATA[<map name="contracts" lazy="true">
     <key column="employer_id"/>
     <index-many-to-many column="employee_id" class="Employee"/>
     <one-to-many column="contract_id" class="Contract"/>
 </map>]]></programlisting>
-            
+
             <programlisting><![CDATA[<map name="connections" lazy="true">
     <key column="node1_id"/>
     <index-many-to-many column="node2_id" class="Node"/>
     <many-to-many column="connection_id" class="Connection"/>
 </map>]]></programlisting>
-            
+
 	</sect1>
-	
+
 	<sect1 id="collections-s1-11b">
 	    <title>Heterogeneous Associations</title>
 	    <para>
@@ -764,8 +764,49 @@ alter table child add constraint childfk
 create table child ( id bigint not null primary key, name varchar(255), parent_id bigint not null )
 alter table child add constraint childfk0 (parent_id) references parent]]></programlisting>
 
+            <para>Imagine you wanted the bidirectional relationship above to be an
+            ordered list, and you want Hibernate to manage the order for you. That
+            would look like this:<programlisting>&#60;hibernate-mapping&#62;
+
+            &#60;class name=&#34;eg.Parent&#34;&#62;
+                &#60;id name=&#34;id&#34;&#62;
+                    &#60;generator class=&#34;sequence&#34;/&#62;
+                &#60;/id&#62;
+                &#60;list name=&#34;children&#34; lazy=&#34;true&#34;&#62;
+                    &#60;key column=&#34;parent_id&#34;/&#62;
+                    &#60;index column=&#34;child_order&#34;/&#62;
+                    &#60;one-to-many class=&#34;eg.Child&#34;/&#62;
+                &#60;/list&#62;
+            &#60;/class&#62;
+
+            &#60;class name=&#34;eg.Child&#34;&#62;
+                &#60;id name=&#34;id&#34;&#62;
+                    &#60;generator class=&#34;sequence&#34;/&#62;
+                &#60;/id&#62;
+                &#60;property name=&#34;name&#34;/&#62;
+                &#60;property name=&#34;child_order&#34; type=&#34;int&#34;/&#62;
+                &#60;many-to-one name=&#34;parent&#34; class=&#34;eg.Parent&#34; column=&#34;parent_id&#34; not-null=&#34;true&#34;/&#62;
+            &#60;/class&#62;
+
+        &#60;/hibernate-mapping&#62;</programlisting></para>
+
+            <para>Notice how the inverse was removed from the parent collection (now a
+            list). This is because if the list is to be ordered and managed by
+            hibernate, you need to work directly with that list for the changes to the
+            order to be computed. As an example, if you had a Child object and you set
+            it&#39;s parent to null, that wouldn&#39;t be good enough because the list
+            in the Parent has to be updated as well so the ordering can be redone. The
+            short version of all of this is that if you have ordered lists that you
+            want to change, you must change the list directly at some point via a
+            children.remve(child) or children.add(child), etc. The tables would look
+            something like:</para>
+
+            <programlisting>create table parent ( id bigint not null primary key )
+        create table child ( id bigint not null primary key, name varchar(255), parent_id bigint not null, child_order bigint )
+        alter table child add constraint childfk0 (parent_id) references parent</programlisting>
+
             <para>
-                On the other hand, if a child might have multiple parents, a many-to-many 
+                On the other hand, if a child might have multiple parents, a many-to-many
                 association is appropriate:
             </para>
 
@@ -809,18 +850,18 @@ alter table childset add constraint chil
                 entities should have synthetic identifiers (surrogate keys), then you might
                 find it a bit odd that the many to many associations and collections of values
                 that we've shown so far all map to tables with composite keys! Now, this point
-                is quite arguable; a pure association table doesn't seem to benefit much from 
+                is quite arguable; a pure association table doesn't seem to benefit much from
                 a surrogate key (though a collection of composite values <emphasis>might</emphasis>).
                 Nevertheless, Hibernate provides a (slightly experimental) feature that allows
                 you to map many to many associations and collections of values to a table with
                 a surrogate key.
             </para>
-            
+
             <para>
-                The <literal>&lt;idbag&gt;</literal> element lets you map a <literal>List</literal> 
+                The <literal>&lt;idbag&gt;</literal> element lets you map a <literal>List</literal>
                 (or <literal>Collection</literal>) with bag semantics.
             </para>
-            
+
 <programlisting><![CDATA[<idbag name="lovers" table="LOVERS" lazy="true">
     <collection-id column="ID" type="long">
         <generator class="hilo"/>
@@ -832,22 +873,22 @@ alter table childset add constraint chil
             <para>
                 As you can see, an <literal>&lt;idbag&gt;</literal> has a synthetic id generator,
                 just like an entity class! A different surrogate key is assigned to each collection
-                row. Hibernate does not provide any mechanism to discover the surrogate key value 
+                row. Hibernate does not provide any mechanism to discover the surrogate key value
                 of a particular row, however.
             </para>
-            
+
             <para>
-                Note that the update performance of an <literal>&lt;idbag&gt;</literal> is 
+                Note that the update performance of an <literal>&lt;idbag&gt;</literal> is
                 <emphasis>much</emphasis> better than a regular <literal>&lt;bag&gt;</literal>!
                 Hibernate can locate individual rows efficiently and update or delete them
                 individually, just like a list, map or set.
             </para>
-            
+
             <para>
                 In the current implementation, the <literal>identity</literal> identifier generation
                 strategy is not supported.
             </para>
-    
+
         </sect1>
-             
+
     </chapter>
