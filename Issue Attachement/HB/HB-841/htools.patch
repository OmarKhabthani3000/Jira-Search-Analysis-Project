Index: tools/src/java/net/sf/hibernate/tool/hbm2java/MetaAttributeHelper.java
===================================================================
RCS file: /cvsroot/hibernate/HibernateExt/tools/src/java/net/sf/hibernate/tool/hbm2java/MetaAttributeHelper.java,v
retrieving revision 1.3
diff -u -u -r1.3 MetaAttributeHelper.java
--- tools/src/java/net/sf/hibernate/tool/hbm2java/MetaAttributeHelper.java	16 Dec 2003 20:15:14 -0000	1.3
+++ tools/src/java/net/sf/hibernate/tool/hbm2java/MetaAttributeHelper.java	24 Mar 2004 11:23:23 -0000
@@ -74,7 +74,7 @@
 	 */
 	static public MultiMap mergeMetaMaps(MultiMap local, MultiMap inherited) {
 		MultiHashMap result = new MultiHashMap();
-		result.putAll(local);
+		copyMultiMap(result, local);
 		
 		if (inherited != null) {
 			for (Iterator iter = inherited.keySet().iterator();
@@ -84,7 +84,7 @@
 
 				if (!local.containsKey(key)) {
 					// inheriting a meta attribute only if it is inheritable
-					ArrayList ml = (ArrayList) inherited.get(key);
+					Collection ml = (Collection) inherited.get(key);
 					for (Iterator iterator = ml.iterator();
 						iterator.hasNext();
 						) {
@@ -145,5 +145,26 @@
 		    return sb.toString();
 		}
 	}
+
+    /**
+     * Copies all the values from one MultiMap to another.
+     * This method is needed because the (undocumented) behaviour of 
+     * MultiHashMap.putAll in versions of Commons Collections prior to 3.0
+     * was to replace the collection in the destination, whereas in 3.0
+     * it adds the collection from the source as an _element_ of the collection
+     * in the destination.  This method makes no assumptions about the implementation
+     * of the MultiMap, and should work with all versions.
+     * 
+     * @param destination
+     * @param source
+     */
+    static public void copyMultiMap(MultiMap destination, MultiMap source) {
+        for (Iterator keyIterator = source.keySet().iterator(); keyIterator.hasNext(); ) {
+            Object key = keyIterator.next();
+            Collection c = (Collection) source.get(key);
+            for (Iterator valueIterator = c.iterator(); valueIterator.hasNext(); ) 
+                destination.put(key, valueIterator.next());
+        }
+    }
 
 }
