Index: net/sf/hibernate/cfg/Binder.java
===================================================================
RCS file: /cvsroot/hibernate/Hibernate2/src/net/sf/hibernate/cfg/Binder.java,v
retrieving revision 1.26.2.21
diff -u -r1.26.2.21 Binder.java
--- net/sf/hibernate/cfg/Binder.java	13 Sep 2003 16:42:24 -0000	1.26.2.21
+++ net/sf/hibernate/cfg/Binder.java	7 Oct 2003 19:04:19 -0000
@@ -445,6 +445,20 @@
 			model.setBatchSize( Integer.parseInt( batchNode.getValue() ) );
 		}
 
+		//		PERSISTER
+		Attribute persisterNode = node.attribute("persister");
+		if (persisterNode==null) {
+			//persister = CollectionPersisterImpl.class;
+		}
+		else {
+			try {
+				model.setPersister( ReflectHelper.classForName( persisterNode.getValue() ) );
+			}
+			catch (ClassNotFoundException cnfe) {
+				throw new MappingException( "Could not find collection persister class: " + persisterNode.getValue() );
+			}
+		}
+		
 		initOuterJoinFetchSetting(node, model);
 
 		Element oneToManyNode = node.element("one-to-many");
Index: net/sf/hibernate/collection/CollectionPersister.java
===================================================================
RCS file: /cvsroot/hibernate/Hibernate2/src/net/sf/hibernate/collection/CollectionPersister.java,v
retrieving revision 1.29.2.24
diff -u -r1.29.2.24 CollectionPersister.java
--- net/sf/hibernate/collection/CollectionPersister.java	27 Sep 2003 13:34:46 -0000	1.29.2.24
+++ net/sf/hibernate/collection/CollectionPersister.java	7 Oct 2003 19:04:19 -0000
@@ -5,55 +5,20 @@
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
-import java.util.HashSet;
-import java.util.Iterator;
 
-import net.sf.hibernate.AssertionFailure;
 import net.sf.hibernate.HibernateException;
-import net.sf.hibernate.JDBCException;
-import net.sf.hibernate.MappingException;
 import net.sf.hibernate.QueryException;
 import net.sf.hibernate.cache.CacheConcurrencyStrategy;
 import net.sf.hibernate.cache.CacheException;
-import net.sf.hibernate.cfg.Configuration;
-import net.sf.hibernate.dialect.Dialect;
-import net.sf.hibernate.engine.SessionFactoryImplementor;
 import net.sf.hibernate.engine.SessionImplementor;
 import net.sf.hibernate.id.IdentifierGenerator;
-import net.sf.hibernate.impl.MessageHelper;
 import net.sf.hibernate.loader.CollectionInitializer;
-import net.sf.hibernate.loader.CollectionLoader;
-import net.sf.hibernate.loader.BatchingCollectionInitializer;
-import net.sf.hibernate.loader.Loader;
-import net.sf.hibernate.loader.OneToManyLoader;
-import net.sf.hibernate.loader.OuterJoinLoader;
-import net.sf.hibernate.mapping.Collection;
-import net.sf.hibernate.mapping.Column;
-import net.sf.hibernate.mapping.IdentifierCollection;
-import net.sf.hibernate.mapping.IndexedCollection;
-import net.sf.hibernate.mapping.PersistentClass;
-import net.sf.hibernate.mapping.Table;
 import net.sf.hibernate.metadata.CollectionMetadata;
-import net.sf.hibernate.persister.ClassPersister;
 import net.sf.hibernate.persister.Joinable;
 import net.sf.hibernate.persister.Loadable;
 import net.sf.hibernate.persister.PropertyMapping;
-import net.sf.hibernate.sql.Alias;
-import net.sf.hibernate.sql.Delete;
-import net.sf.hibernate.sql.Insert;
-import net.sf.hibernate.sql.SelectFragment;
-import net.sf.hibernate.sql.Template;
-import net.sf.hibernate.sql.Update;
-import net.sf.hibernate.type.AbstractComponentType;
-import net.sf.hibernate.type.AssociationType;
-import net.sf.hibernate.type.EntityType;
 import net.sf.hibernate.type.PersistentCollectionType;
 import net.sf.hibernate.type.Type;
-import net.sf.hibernate.util.ArrayHelper;
-import net.sf.hibernate.util.StringHelper;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
 
 /**
  * Plugs into an instance of <tt>PersistentCollection</tt>.
@@ -68,945 +33,146 @@
  * 
  * @author Gavin King
  */
-public final class CollectionPersister implements CollectionMetadata, PropertyMapping, Joinable {
-	
-	//private final String sqlSelectString;
-	private final String sqlDeleteString;
-	private final String sqlInsertRowString;
-	private final String sqlUpdateRowString;
-	private final String sqlDeleteRowString;
-	private final String sqlOrderByString;
-	private final String sqlWhereString;
-	private final String sqlOrderByStringTemplate;
-	private final String sqlWhereStringTemplate;
-	private final boolean hasOrder;
-	private final boolean hasWhere;
-	private final boolean hasOrphanDelete;
-	//private final boolean isSet;
-	private final Type keyType;
-	private final Type indexType;
-	private final Type elementType;
-	private final String[] keyColumnNames;
-	private final String[] indexColumnNames;
-	private final String[] elementColumnNames;
-	//private final String[] unquotedIndexColumnNames;
-	//private final String[] unquotedElementColumnNames;
-	//private final String[] unquotedKeyColumnNames;
-	private final String[] rowSelectColumnNames;
-	private final String[] indexColumnAliases;
-	private final String[] elementColumnAliases;
-	private final String[] keyColumnAliases;
-	private final Type rowSelectType;
-	private final boolean primitiveArray;
-	private final boolean array;
-	private final boolean isOneToMany;
-	private final boolean isManyToMany;
-	private final String qualifiedTableName;
-	private final boolean hasIndex;
-	private final boolean isLazy;
-	private final boolean isInverse;
-	private final int batchSize;
-	private final Class elementClass;
-	private final CacheConcurrencyStrategy cache;
-	private final PersistentCollectionType collectionType;
-	private final int enableJoinedFetch;
-	private final Class ownerClass;
-	//private final boolean isSorted;
-	private final IdentifierGenerator identifierGenerator;
-	private final String unquotedIdentifierColumnName;
-	private final Type identifierType;
-	private final boolean hasIdentifier;
-	private final String identifierColumnName;
-	private final String identifierColumnAlias;
-	private final Dialect dialect;
-	private final PropertyMapping elementPropertyMapping;
-	private final Loadable elementPersister;
-	
-	private final CollectionInitializer loader;
-	
-	private final String role;
-	//private final SessionFactoryImplementor factory;
-	
-	private static final Log log = LogFactory.getLog(CollectionPersister.class);
-	
-	public CollectionPersister(Collection collection, Configuration datastore, SessionFactoryImplementor factory) 
-		throws MappingException, CacheException {
-		
-		dialect = factory.getDialect();
-		collectionType = collection.getType();
-		role = collection.getRole();
-		ownerClass = collection.getOwnerClass();
-		Alias alias = new Alias("__");
-		
-		sqlOrderByString = collection.getOrderBy();
-		hasOrder = sqlOrderByString!=null;
-		sqlOrderByStringTemplate = hasOrder ? Template.renderOrderByStringTemplate(sqlOrderByString, dialect) : null;
-		sqlWhereString = collection.getWhere();
-		hasWhere = sqlWhereString!=null;
-		sqlWhereStringTemplate = hasWhere ? Template.renderWhereStringTemplate(sqlWhereString, dialect) : null;
-		
-		hasOrphanDelete = collection.hasOrphanDelete();
-		
-		batchSize = collection.getBatchSize();
-		
-		cache=collection.getCache();
-		
-		keyType = collection.getKey().getType();
-		Iterator iter = collection.getKey().getColumnIterator();
-		int span = collection.getKey().getColumnSpan();
-		keyColumnNames = new String[span];
-		String[] keyAliases = new String[span];
-		int k=0;
-		while ( iter.hasNext() ) {
-			Column col = ( (Column) iter.next() );
-			keyColumnNames[k] = col.getQuotedName(dialect);
-			keyAliases[k] = col.getAlias();
-			k++;
-		}
-		keyColumnAliases = alias.toAliasStrings(keyAliases);
-		//unquotedKeyColumnNames = StringHelper.unQuote(keyColumnAliases);
-		java.util.Set distinctColumns = new HashSet();
-		checkColumnDuplication( distinctColumns, collection.getKey().getColumnIterator() );
-		
-		//isSet = collection.isSet();
-		//isSorted = collection.isSorted();
-		isOneToMany = collection.isOneToMany();
-		primitiveArray = collection.isPrimitiveArray();
-		array = collection.isArray();
-		
-		Table table;
-		if (isOneToMany) {
-			isManyToMany = false;
-			EntityType type = collection.getOneToMany().getType();
-			elementType = type;
-			PersistentClass associatedClass = datastore.getClassMapping( type.getAssociatedClass() );
-			span = associatedClass.getIdentifier().getColumnSpan();
-			iter = associatedClass.getKey().getColumnIterator();
-			table = associatedClass.getTable();
-			enableJoinedFetch = OuterJoinLoader.EAGER;
-			//don't do this check, since it is actually valid for a one-to-many <key> 
-			//or <index> to consist of some columns of a composite-id
-			//checkColumnDuplication( distinctColumns, associatedClass.getKey().getColumnIterator() );
-		}
-		else {
-			table = collection.getTable();
-			elementType = collection.getElement().getType();
-			isManyToMany = elementType.isEntityType();
-			span = collection.getElement().getColumnSpan();
-			enableJoinedFetch = collection.getElement().getOuterJoinFetchSetting();			
-			iter = collection.getElement().getColumnIterator();
-			checkColumnDuplication( distinctColumns, collection.getElement().getColumnIterator() );
-		}
-		
-		if ( elementType.isEntityType() ) {
-			//TODO: what if it is just an ordinary ClassPersister, not Loadable
-			//      can the collection fwk even handle that?
-			elementPersister = (Loadable) factory.getPersister( ( (EntityType) elementType ).getAssociatedClass() );
-		}
-		else {
-			elementPersister = null;
-		}
-
-		qualifiedTableName = table.getQualifiedName( dialect, factory.getDefaultSchema() );
-		String[] aliases = new String[span];
-		elementColumnNames = new String[span];
-		int j=0;
-		while ( iter.hasNext() ) {
-			Column col = (Column) iter.next();
-			elementColumnNames[j] = col.getQuotedName(dialect);
-			aliases[j] = col.getAlias();
-			j++;
-		}
-		
-		elementColumnAliases = alias.toAliasStrings(aliases);
-		//unquotedElementColumnNames = StringHelper.unQuote(elementColumnAliases);
-		
-		Type selectColumns;
-		String[] selectType;
-		if ( hasIndex = collection.isIndexed() ) {
-			IndexedCollection indexedCollection = (IndexedCollection) collection;
-			indexType = indexedCollection.getIndex().getType();
-			int indexSpan = indexedCollection.getIndex().getColumnSpan();
-			iter = indexedCollection.getIndex().getColumnIterator();
-			indexColumnNames = new String[indexSpan];
-			String[] indexAliases = new String[indexSpan];
-			int i=0;
-			while ( iter.hasNext() ) {
-				Column indexCol = (Column) iter.next();
-				indexAliases[i] = indexCol.getAlias();
-				indexColumnNames[i] = indexCol.getQuotedName(dialect);
-				i++;
-			}
-			selectType = indexColumnNames;
-			selectColumns = indexType;
-			indexColumnAliases = alias.toAliasStrings(indexAliases);
-			//unquotedIndexColumnNames = StringHelper.unQuote(indexColumnAliases);
-			checkColumnDuplication( distinctColumns, indexedCollection.getIndex().getColumnIterator() );
-		}
-		else {
-			indexType = null;
-			indexColumnNames = null;
-			indexColumnAliases = null;
-			selectType = elementColumnNames;
-			selectColumns = elementType;
-		}
-		
-		if ( hasIdentifier = collection.isIdentified() ) {
-			if (isOneToMany) throw new MappingException("one-to-many collections with identifiers are not supported");
-			IdentifierCollection idColl = (IdentifierCollection) collection;
-			identifierType = idColl.getIdentifier().getType();
-			iter = idColl.getIdentifier().getColumnIterator();
-			Column col = (Column) iter.next();
-			identifierColumnName = col.getQuotedName(dialect);
-			selectType = new String[] { identifierColumnName };
-			selectColumns = identifierType;
-			identifierColumnAlias = alias.toAliasString( col.getAlias() );
-			//unquotedIdentifierColumnName = StringHelper.unQuote(identifierColumnAlias);
-			unquotedIdentifierColumnName = identifierColumnAlias;
-			identifierGenerator = idColl.getIdentifier().createIdentifierGenerator( factory.getDialect() );
-			checkColumnDuplication( distinctColumns, idColl.getIdentifier().getColumnIterator() );
-		}
-		else {
-			identifierType = null;
-			identifierColumnName = null;
-			identifierColumnAlias = null;
-			unquotedIdentifierColumnName = null;
-			identifierGenerator = null;
-		}
-		
-		rowSelectColumnNames = selectType;
-		rowSelectType = selectColumns;
-		
-		//sqlSelectString = sqlSelectString();
-		sqlDeleteString = generateDeleteString();
-		//sqlSelectRowString = sqlSelectRowString();
-		sqlInsertRowString = generateInsertRowString();
-		sqlUpdateRowString = generateUpdateRowString();
-		sqlDeleteRowString = generateDeleteRowString();
-		isLazy = collection.isLazy();
-		
-		isInverse = collection.isInverse();
-		
-		if ( collection.isArray() ) {
-			elementClass = ( (net.sf.hibernate.mapping.Array) collection ).getElementClass();
-		}
-		else {
-			// for non-arrays, we don't need to know the element class
-			elementClass = null; //elementType.returnedClass();
-		}
-		
-		loader = createCollectionInitializer(factory);
-		
-		if ( elementType.isComponentType() ) {
-			elementPropertyMapping = new CompositeElementPropertyMapping( 
-				elementColumnNames, (AbstractComponentType) elementType, factory 
-			);
-		}
-		else if ( !elementType.isEntityType() ) {
-			elementPropertyMapping = new ElementPropertyMapping(elementColumnNames, elementType);
-		}
-		else {
-			ClassPersister persister = factory.getPersister( ( (EntityType) elementType ).getAssociatedClass() );
-			if ( persister instanceof PropertyMapping ) { //not all classpersisters implement PropertyMapping!
-				elementPropertyMapping = (PropertyMapping) persister;
-			}
-			else {
-				elementPropertyMapping = new ElementPropertyMapping(elementColumnNames, elementType);
-			} 
-		}
-		
-	}
-	
-	public CollectionInitializer getInitializer() {
-		return loader;
-	}
-	
-	private CollectionInitializer createCollectionInitializer(SessionFactoryImplementor factory) throws MappingException {
-		Loader nonbatchLoader = isOneToMany() ?
-			(Loader) new OneToManyLoader(this, factory) :
-			(Loader) new CollectionLoader(this, factory);
-		if (batchSize>1) {
-			Loader batchLoader = isOneToMany() ?
-				(Loader) new OneToManyLoader(this, batchSize, factory) :
-				(Loader) new CollectionLoader(this, batchSize, factory);
-			int smallBatchSize = (int) Math.round( Math.sqrt(batchSize) );
-			Loader smallBatchLoader = isOneToMany() ?
-				(Loader) new OneToManyLoader(this, smallBatchSize, factory) :
-				(Loader) new CollectionLoader(this, smallBatchSize, factory);
-			// the strategy for choosing batch or single load:
-			return new BatchingCollectionInitializer(this, batchSize, batchLoader, smallBatchSize, smallBatchLoader, nonbatchLoader);
-		}
-		else {
-			// don't do batch loading
-			return (CollectionInitializer) nonbatchLoader;
-		}
-	}
-	
-	public void cache(Serializable id, PersistentCollection coll, SessionImplementor s) throws HibernateException {
-		if (cache!=null) {
-			if ( log.isDebugEnabled() ) log.debug("Caching collection: " + role + '#' + id);
-			cache.put( id, coll.disassemble(this), s.getTimestamp() );
-		}
-	}
-	
-	public CacheConcurrencyStrategy getCache() {
-		return cache;
-	}
-	
-	public boolean hasCache() {
-		return cache!=null;
-	}
-	
-	public PersistentCollection getCachedCollection(Serializable id, Object owner, SessionImplementor s) throws HibernateException {
-		if (cache==null) {
-			return null;
-		}
-		else {
-			if ( log.isDebugEnabled() ) log.debug("Searching for collection in cache: " + role + '#' + id);
-			Serializable cached = (Serializable) cache.get( id, s.getTimestamp() );
-			if (cached==null) {
-				return null;
-			}
-			else {
-				return collectionType.assembleCachedCollection(s, this, cached, owner);
-			}
-		}
-	}
-	
-	public void softlock(Serializable id) throws CacheException {
-		if (cache!=null) cache.lock(id);
-	}
-	public void releaseSoftlock(Serializable id) throws CacheException {
-		if (cache!=null) cache.release(id);
-	}
-	
-	public PersistentCollectionType getCollectionType() {
-		return collectionType;
-	}
-	
-	public String getSQLWhereString(String alias) {
-		return StringHelper.replace(sqlWhereStringTemplate, Template.TEMPLATE, alias);
-	}
-	
-	public String getSQLOrderByString(String alias) {
-		return StringHelper.replace(sqlOrderByStringTemplate, Template.TEMPLATE, alias);
-	}
-	
-	public int enableJoinedFetch() {
-		return enableJoinedFetch;
-	}
-	
-	public boolean hasOrdering() {
-		return hasOrder;
-	}
-	
-	public boolean hasWhere() {
-		return hasWhere; 
-	}
-	
-	private String getSQLDeleteString() {
-		return sqlDeleteString;
-	}
-	
-	private String getSQLInsertRowString() {
-		return sqlInsertRowString;
-	}
-	
-	private String getSQLUpdateRowString() {
-		return sqlUpdateRowString;
-	}
-	
-	private String getSQLDeleteRowString() {
-		return sqlDeleteRowString;
-	}
-	
-	public Type getKeyType() {
-		return keyType;
-	}
-	
-	public Type getIndexType() {
-		return indexType;
-	}
-	
-	public Type getElementType() {
-		return elementType;
-	}
-	
-	/**
-	 * Return the element class of an array, or null otherwise
-	 */
-	public Class getElementClass() { //needed by arrays
-		return elementClass;
-	}
-	
-	public Object readElement(ResultSet rs, Object owner, SessionImplementor session) throws HibernateException, SQLException {
-		Object element = getElementType().nullSafeGet(rs, elementColumnAliases, session, owner);
-		return element;
-	}
-	public Object readIndex(ResultSet rs, SessionImplementor session) throws HibernateException, SQLException {
-		Object index = getIndexType().nullSafeGet(rs, indexColumnAliases, session, null);
-		if (index==null) throw new HibernateException("null index column for collection: " + role);
-		return index;
-	}
-	
-	public Object readIdentifier(ResultSet rs, SessionImplementor session) throws HibernateException, SQLException {
-		Object id = getIdentifierType().nullSafeGet(rs, unquotedIdentifierColumnName, session, null);
-		if (id==null) throw new HibernateException("null identifier column for collection: " + role);
-		return id;
-	}
-	
-	public Object readKey(ResultSet rs, SessionImplementor session) throws HibernateException, SQLException {
-		return getKeyType().nullSafeGet(rs, keyColumnAliases, session, null);
-	}
-	
-	public void writeElement(PreparedStatement st, Object elt, boolean writeOrder, SessionImplementor session)
-	throws HibernateException, SQLException {
-		getElementType().nullSafeSet(
-			st, 
-			elt, 
-			1+(writeOrder?0:keyColumnNames.length+(hasIndex?indexColumnNames.length:0)+(hasIdentifier?1:0)), 
-			session
-		);
-	}
-	
-	public void writeIndex(PreparedStatement st, Object idx, boolean writeOrder, SessionImplementor session)
-	throws HibernateException, SQLException {
-		getIndexType().nullSafeSet(st, idx, 1+keyColumnNames.length + (writeOrder?elementColumnNames.length:0), session);
-	}
-	
-	public void writeIdentifier(PreparedStatement st, Object idx, boolean writeOrder, SessionImplementor session)
-	throws HibernateException, SQLException {
-		getIdentifierType().nullSafeSet(st, idx, 1+(writeOrder?elementColumnNames.length:keyColumnNames.length), session);
-	}
-	
-	private void writeRowSelect(PreparedStatement st, Object idx, SessionImplementor session)
-	throws HibernateException, SQLException {
-		rowSelectType.nullSafeSet(st, idx, 1+(hasIdentifier?0:keyColumnNames.length), session);
-	}
-	
-	public void writeKey(PreparedStatement st, Serializable id, boolean writeOrder, SessionImplementor session)
-	throws HibernateException, SQLException {
-		if (id==null) throw new NullPointerException("null key for collection: " + role);  //an assertion
-		getKeyType().nullSafeSet(st, id, 1+(writeOrder?elementColumnNames.length:0), session);
-	}
-	
-	public boolean isPrimitiveArray() {
-		return primitiveArray;
-	}
-	
-	public boolean isArray() {
-		return array;
-	}
-	
-	/**
-	 * Generate a list of collection index and element columns
-	 */
-	public String selectClauseFragment(String alias) {
-		SelectFragment frag = new SelectFragment()
-			.setSuffix(StringHelper.EMPTY_STRING)
-			.addColumns(alias, elementColumnNames, elementColumnAliases)
-			.addColumns(alias, keyColumnNames, keyColumnAliases);
-		if (hasIndex) frag.addColumns(alias, indexColumnNames, indexColumnAliases);
-		if (hasIdentifier) frag.addColumn(alias, identifierColumnName, identifierColumnAlias);
-		return frag.toFragmentString()
-			.substring(2); //strip leading ','
-	}
-	
-	/**
-	 * Generate a list of collection index, key and element columns
-	 */
-	public String multiselectClauseFragment(String alias) {
-		SelectFragment frag = new SelectFragment()
-			.setSuffix(StringHelper.EMPTY_STRING)
-			.addColumns(alias, elementColumnNames, elementColumnAliases)
-			.addColumns(alias, keyColumnNames, keyColumnAliases);
-		if (hasIndex) frag.addColumns(alias, indexColumnNames, indexColumnAliases);
-		if (hasIdentifier) frag.addColumn(alias, identifierColumnName, identifierColumnAlias);
-		return frag.toFragmentString()
-			.substring(2); //strip leading ','
-	}
-	
-	/*private String sqlSelectString() {
-		//we no longer have Jon Lipsky's patch to allow a Map from id's to objects
-		SimpleSelect select = new SimpleSelect()
-			.setTableName(qualifiedTableName)
-			.addColumns(elementColumnNames);
-		if (hasIndex) select.addColumns(indexColumnNames);
-		select.addCondition( keyColumnNames, "=?" );
-		if (hasWhere) select.addWhereToken( " and " + sqlWhereString );
-		if (hasOrder) select.setOrderBy(sqlOrderByString);
-		return select.toStatementString();
-	}*/
-	
-	private String generateDeleteString() {
-		if (isOneToMany) {
-			Update update = new Update()
-				.setTableName(qualifiedTableName)
-				.addColumns(keyColumnNames, "null")
-				.setPrimaryKeyColumnNames(keyColumnNames);
-			if (hasIndex) update.addColumns(indexColumnNames, "null");
-			if (hasWhere) update.setWhere(sqlWhereString);
-			return update.toStatementString();
-		}
-		else {
-			Delete delete = new Delete()
-				.setTableName(qualifiedTableName)
-				.setPrimaryKeyColumnNames(keyColumnNames);
-			if (hasWhere) delete.setWhere(sqlWhereString);
-			return delete.toStatementString();
-		}
-	}
+public interface CollectionPersister extends PropertyMapping, Joinable /* Will every CollectionPersister be Joinable */ {
 	
-	private String generateInsertRowString() {
-		if (isOneToMany) {
-			Update update = new Update()
-				.setTableName(qualifiedTableName)
-				.addColumns(keyColumnNames);
-			if (hasIndex) update.addColumns(indexColumnNames); 
-			//identifier collections not supported for 1-to-many 
-			return update.setPrimaryKeyColumnNames(elementColumnNames)
-				.toStatementString();
-		}
-		else {
-			Insert insert = new Insert(null)
-				.setTableName(qualifiedTableName)
-				.addColumns(keyColumnNames);
-			if (hasIndex) insert.addColumns(indexColumnNames);
-			if (hasIdentifier) insert.addColumn(identifierColumnName);
-			return insert.addColumns(elementColumnNames)
-				.toStatementString();
-		}
-	}
-
-	private String generateUpdateRowString() {
-		if (isOneToMany) {
-			return null;
-		}
-		else {
-			Update update = new Update()
-				.setTableName(qualifiedTableName)
-				.addColumns(elementColumnNames);
-			if (hasIdentifier) {
-				update.setPrimaryKeyColumnNames(rowSelectColumnNames);
-			}
-			else {
-				update.setPrimaryKeyColumnNames( ArrayHelper.join(keyColumnNames, rowSelectColumnNames) );
-			}
-			return update.toStatementString();
-		}
-	}
-	
-	private String generateDeleteRowString() {
-		final String[] pkColumns;
-		if (hasIdentifier) {
-			pkColumns = rowSelectColumnNames;
-		}
-		else {
-			pkColumns = ArrayHelper.join(keyColumnNames, rowSelectColumnNames);
-		}
-		if (isOneToMany) {
-			Update update = new Update()
-				.setTableName(qualifiedTableName)
-				.addColumns(keyColumnNames, "null");
-			if (hasIndex) update.addColumns(indexColumnNames, "null");
-			return update.setPrimaryKeyColumnNames(pkColumns)
-				.toStatementString();
-		}
-		else {
-			return new Delete()
-				.setTableName(qualifiedTableName)
-				.setPrimaryKeyColumnNames(pkColumns)
-				.toStatementString();
-		}
-	}
-	
-	
-	public String[] getIndexColumnNames() {
-		return indexColumnNames;
-	}
-	
-	public String[] getElementColumnNames() {
-		return elementColumnNames;
-	}
-	
-	public String[] getKeyColumnNames() {
-		return keyColumnNames;
-	}
-	
-	public boolean isOneToMany() {
-		return isOneToMany;
-	}
-	
-	public boolean hasIndex() {
-		return hasIndex;
-	}
-	
-	public boolean isLazy() { return isLazy; }
-	
-	public boolean isInverse() {
-		return isInverse;
-	}
-	
-	public String getTableName() {
-		return qualifiedTableName;
-	}
-	
-	public final void remove(Serializable id, SessionImplementor session) throws HibernateException {
-		
-		if ( !isInverse ) {
-			
-			if ( log.isDebugEnabled() ) log.debug( "Deleting collection: " + MessageHelper.infoString(this, id) );
-			
-			// Remove all the old entries
-			
-			try {
-				PreparedStatement st = session.getBatcher().prepareBatchStatement( getSQLDeleteString() );
-				
-				try {
-					writeKey(st, id, false, session);
-					session.getBatcher().addToBatch(-1);
-				}
-				catch (SQLException sqle) {
-					session.getBatcher().abortBatch(sqle);
-					throw sqle;
-				}
-				
-				if ( log.isDebugEnabled() ) log.debug("done deleting collection");
-			}
-			catch (SQLException sqle) {
-				throw new JDBCException("could not delete collection: " + MessageHelper.infoString(this, id), sqle );
-			}
-			
-		}
-		
-	}
-	
-	public final void recreate(PersistentCollection collection, Serializable id, SessionImplementor session)
-	throws HibernateException {
-		
-		if (!isInverse) {
-			
-			if ( log.isDebugEnabled() ) log.debug( "Inserting collection: " + MessageHelper.infoString(this, id) );
-			
-			try {
-				//create all the new entries
-				Iterator entries = collection.entries();
-				if ( entries.hasNext() ) {
-					try {
-						collection.preInsert(this);
-						int i=0;
-						while ( entries.hasNext() ) {
-							Object entry = entries.next();
-							if ( collection.entryExists(entry, i) ) {
-								PreparedStatement st = session.getBatcher().prepareBatchStatement( getSQLInsertRowString() );
-								writeKey(st, id, false, session);
-								collection.writeTo(st, this, entry, i, false);
-								session.getBatcher().addToBatch(1);
-								collection.afterRowInsert(this, entry, i);
-							}
-							i++;
-						}
-					}
-					catch (SQLException sqle) {
-						session.getBatcher().abortBatch(sqle);
-						throw sqle;
-					}
-					
-					if ( log.isDebugEnabled() ) log.debug("done inserting collection");
-				}
-				else {
-					if ( log.isDebugEnabled() ) log.debug("collection was empty");
-				}
-			}
-			catch (SQLException sqle) {
-				throw new JDBCException("could not insert collection: " + MessageHelper.infoString(this, id), sqle );
-			}
-		}
-	}
-	
-	public final void deleteRows(PersistentCollection collection, Serializable id, SessionImplementor session)
-	throws HibernateException {
-		
-		if (!isInverse) {
-			
-			if ( log.isDebugEnabled() ) log.debug( "Deleting rows of collection: " + MessageHelper.infoString(this, id) );
-			
-			try {
-				//delete all the deleted entries
-				Iterator entries = collection.getDeletes(elementType);
-				if ( entries.hasNext() ) {
-					
-					PreparedStatement st = session.getBatcher().prepareBatchStatement( getSQLDeleteRowString() );
-					
-					try {
-						while ( entries.hasNext() ) {
-							if (!hasIdentifier) writeKey(st, id, false, session );
-							writeRowSelect( st, entries.next(), session );
-							session.getBatcher().addToBatch(-1);
-						}
-					}
-					catch (SQLException sqle) {
-						session.getBatcher().abortBatch(sqle);
-						throw sqle;
-					}
-					
-					if ( log.isDebugEnabled() ) log.debug("done deleting collection rows");
-				}
-				else {
-					if ( log.isDebugEnabled() ) log.debug("no rows to delete");
-				}
-			}
-			catch (SQLException sqle) {
-				throw new JDBCException("could not delete collection rows: " + MessageHelper.infoString(this, id), sqle );
-			}
-		}
-	}
-	
-	private final void update(Serializable id, PersistentCollection collection, SessionImplementor session) 
-	throws HibernateException {
-		
-		try {
-			PreparedStatement st = null;
-			Iterator entries = collection.entries();
-			int i=0;
-			try {
-				while ( entries.hasNext() ) {
-					Object entry = entries.next();
-					if ( collection.needsUpdating(entry, i, elementType) ) {
-						if (st==null) st = session.getBatcher().prepareBatchStatement( getSQLUpdateRowString() );
-						if (!hasIdentifier) writeKey(st, id, true, session);
-						collection.writeTo( st, this, entry, i, true );
-						session.getBatcher().addToBatch(1);
-					}
-					i++;
-				}
-			}
-			catch (SQLException sqle) {
-				session.getBatcher().abortBatch(sqle);
-				throw sqle;
-			}
-		}
-		catch (SQLException sqle) {
-			throw new JDBCException("could not update collection rows: " + MessageHelper.infoString(this, id), sqle );
-		}
-	}
-	
-	private final void updateOneToMany(Serializable id, PersistentCollection collection, SessionImplementor session) 
-	throws HibernateException {
-
-		try {		
-			PreparedStatement rmvst = null;
-			int i=0;
-			Iterator entries = collection.entries();
-			try {
-				while ( entries.hasNext() ) {
-					Object entry = entries.next();
-					if ( collection.needsUpdating(entry, i, elementType) ) {  // will still be issued when it used to be null
-						if (rmvst==null) rmvst = session.getBatcher().prepareBatchStatement( getSQLDeleteRowString() );
-						writeKey(rmvst, id, false, session);
-						writeIndex(rmvst, collection.getIndex(entry, i), false, session);
-						session.getBatcher().addToBatch(-1);
-					}
-					i++;
-				}
-			}
-			catch (SQLException sqle) {
-				session.getBatcher().abortBatch(sqle);
-				throw sqle;
-			}
-			// finish all the "removes" first to take care of possible unique constraints
-			// and so that we can take advantage of batching
-			PreparedStatement insst = null;
-			i=0;
-			entries = collection.entries();
-			try {
-				while ( entries.hasNext() ) {
-					Object entry = entries.next();
-					if ( collection.needsUpdating(entry, i, elementType) ) {
-						if (insst==null) insst = session.getBatcher().prepareBatchStatement( getSQLInsertRowString() );
-						writeKey(insst, id, false, session);
-						collection.writeTo(insst, this, entry, i, false);
-						session.getBatcher().addToBatch(1);
-					}
-					i++;
-				}
-			}
-			catch (SQLException sqle) {
-				session.getBatcher().abortBatch(sqle);
-				throw sqle;
-			}
-		}
-		catch (SQLException sqle) {
-			throw new JDBCException("could not update collection rows: " + MessageHelper.infoString(this, id), sqle );
-		}
-	}
-	
-	public final void updateRows(PersistentCollection collection, Serializable id, SessionImplementor session) throws HibernateException {
-		
-		if (!isInverse) {
-			
-			if ( log.isDebugEnabled() ) log.debug("Updating rows of collection: " + role + "#" + id);
-			
-			//update all the modified entries
-			if (isOneToMany) {
-				updateOneToMany(id, collection, session);
-			}
-			else {
-				update(id, collection, session);
-			}
-			
-			if ( log.isDebugEnabled() ) log.debug("done updating rows");
-		}
-	}
-	
-	public final void insertRows(PersistentCollection collection, Serializable id, SessionImplementor session)
-	throws HibernateException {
-		
-		if (!isInverse) {
-			
-			if ( log.isDebugEnabled() ) log.debug( "Inserting rows of collection: " + MessageHelper.infoString(this, id) );
-			
-			try {
-				//insert all the new entries
-				Iterator entries = collection.entries();
-				try {
-					collection.preInsert(this);
-					int i=0;
-					while ( entries.hasNext() ) {
-						Object entry = entries.next();
-						if ( collection.needsInserting(entry, i, elementType) ) {
-							PreparedStatement st = session.getBatcher().prepareBatchStatement( getSQLInsertRowString() );
-							writeKey(st, id, false, session);
-							collection.writeTo( st, this, entry, i, false );
-							session.getBatcher().addToBatch(1);
-							collection.afterRowInsert(this, entry, i);
-						}
-						i++;
-					}
-				}
-				catch (SQLException sqle) {
-					session.getBatcher().abortBatch(sqle);
-					throw sqle;
-				}
-			}
-			catch (SQLException sqle) {
-				throw new JDBCException("could not insert collection rows: " + MessageHelper.infoString(this, id), sqle );
-			}
-			
-			if ( log.isDebugEnabled() ) log.debug("done inserting rows");
-		}
-	}
-	
-	
-	public String getRole() {
-		return role;
-	}
-	
-	public Class getOwnerClass() {
-		return ownerClass;
-	}
-	
-	/*public boolean isSet() {
-		return isSet;
-	}
-	
-	public boolean isSorted() {
-		return isSorted;
-	}*/
-	
-	public IdentifierGenerator getIdentifierGenerator() {
-		return identifierGenerator;
-	}
-	
-	public Type getIdentifierType() {
-		return identifierType;
-	}
-	
-	public boolean hasOrphanDelete() {
-		return hasOrphanDelete;
-	}
-	
-	private void checkColumnDuplication(java.util.Set distinctColumns, Iterator columns) throws MappingException {
-		while ( columns.hasNext() ) {
-			Column col = (Column) columns.next();
-			if ( !distinctColumns.add( col.getName() ) ) throw new MappingException(
-				"Repeated column in mapping for collection: " +
-				role +
-				" column: " + 
-				col.getName()
-			);
-		}
-	}
-
-	public Type toType(String propertyName) throws QueryException {
-		if ( "index".equals(propertyName) ) return indexType;
-		return elementPropertyMapping.toType(propertyName);
-	}
-
-	public String[] toColumns(String alias, String propertyName)
-		throws QueryException {
-		
-		if ( "index".equals(propertyName) ) {
-			if (isManyToMany) throw new QueryException("index() function not supported for many-to-many association");
-			return StringHelper.prefix(indexColumnNames, alias + StringHelper.DOT);
-		}
-		return elementPropertyMapping.toColumns(alias, propertyName);
-	}
-
-	public Type getType() {
-		return elementPropertyMapping.getType(); //==elementType ??
-	}
-
-	public String fromJoinFragment(String alias, boolean innerJoin, boolean includeSubclasses) {
-		return StringHelper.EMPTY_STRING;
-	}
-
-	public String[] getJoinKeyColumnNames() {
-		return getKeyColumnNames();
-	}
-
-	public String getName() {
-		return getRole();
-	}
-
-	public String joinSelectFragment(String alias, String suffix) {
-		
-		StringBuffer buf = new StringBuffer();
-		buf.append( selectClauseFragment(alias) );
-		if ( isOneToMany() ) {
-			buf.append(StringHelper.COMMA_SPACE)
-				.append( elementPersister.identifierSelectFragment(alias, suffix) )
-				.append( elementPersister.propertySelectFragment(alias, suffix) );
-		}
-		return buf.toString();
-
-	}
-	
-	public Loadable getElementPersister() {
-		if (elementPersister==null) throw new AssertionFailure("not an association");
-		return elementPersister;
-	}
-
-	public String whereJoinFragment(String alias, boolean innerJoin, boolean includeSubclasses) {
-		return StringHelper.EMPTY_STRING;
-	}
-
-	public boolean isCollection() {
-		return true;
-	}
-
-	public boolean consumesAlias() {
-		return isOneToMany;
-	}
-	
-	public Serializable getCollectionSpace() {
-		return getTableName();
-	}
-
-	public boolean isManyToMany() {
-		return !isOneToMany && elementType instanceof AssociationType;
-	}
-
+	public abstract CollectionInitializer getInitializer();
+	public abstract void cache(Serializable id,
+			PersistentCollection coll,
+			SessionImplementor s)
+			throws HibernateException;
+		public abstract CacheConcurrencyStrategy getCache();
+		public abstract boolean hasCache();
+		public abstract PersistentCollection getCachedCollection(
+			Serializable id,
+			Object owner,
+			SessionImplementor s)
+			throws HibernateException;
+		public abstract void softlock(Serializable id) throws CacheException;
+		public abstract void releaseSoftlock(Serializable id)
+			throws CacheException;
+		public abstract PersistentCollectionType getCollectionType();
+		public abstract String getSQLWhereString(String alias);
+		public abstract String getSQLOrderByString(String alias);
+		public abstract int enableJoinedFetch();
+		public abstract boolean hasOrdering();
+		public abstract boolean hasWhere();
+		public CollectionMetadata getCollectionMetadata();
+		public abstract Type getKeyType();
+		public abstract Type getIndexType();
+		public abstract Type getElementType();
+		/**
+		 * Return the element class of an array, or null otherwise
+		 */
+		public abstract Class getElementClass();
+		public abstract Object readElement(
+			ResultSet rs,
+			Object owner,
+			SessionImplementor session)
+			throws HibernateException, SQLException;
+		public abstract Object readIndex(ResultSet rs, SessionImplementor session)
+			throws HibernateException, SQLException;
+		public abstract Object readIdentifier(
+			ResultSet rs,
+			SessionImplementor session)
+			throws HibernateException, SQLException;
+		public abstract Object readKey(ResultSet rs, SessionImplementor session)
+			throws HibernateException, SQLException;
+		public abstract void writeElement(
+			PreparedStatement st,
+			Object elt,
+			boolean writeOrder,
+			SessionImplementor session)
+			throws HibernateException, SQLException;
+		public abstract void writeIndex(
+			PreparedStatement st,
+			Object idx,
+			boolean writeOrder,
+			SessionImplementor session)
+			throws HibernateException, SQLException;
+		public abstract void writeIdentifier(
+			PreparedStatement st,
+			Object idx,
+			boolean writeOrder,
+			SessionImplementor session)
+			throws HibernateException, SQLException;
+		public abstract void writeKey(
+			PreparedStatement st,
+			Serializable id,
+			boolean writeOrder,
+			SessionImplementor session)
+			throws HibernateException, SQLException;
+		public abstract boolean isPrimitiveArray();
+		public abstract boolean isArray();
+		/**
+		 * Generate a list of collection index and element columns
+		 */
+		public abstract String selectClauseFragment(String alias);
+		/**
+		 * Generate a list of collection index, key and element columns
+		 */
+		public abstract String multiselectClauseFragment(String alias);
+		public abstract String[] getIndexColumnNames();
+		public abstract String[] getElementColumnNames();
+		public abstract String[] getKeyColumnNames();
+		public abstract boolean isOneToMany();
+		public abstract boolean hasIndex();
+		public abstract boolean isLazy();
+		public abstract boolean isInverse();
+		public abstract String getTableName();
+		public abstract void remove(Serializable id, SessionImplementor session)
+			throws HibernateException;
+		public abstract void recreate(
+			PersistentCollection collection,
+			Serializable id,
+			SessionImplementor session)
+			throws HibernateException;
+		public abstract void deleteRows(
+			PersistentCollection collection,
+			Serializable id,
+			SessionImplementor session)
+			throws HibernateException;
+		public abstract void updateRows(
+			PersistentCollection collection,
+			Serializable id,
+			SessionImplementor session)
+			throws HibernateException;
+		public abstract void insertRows(
+			PersistentCollection collection,
+			Serializable id,
+			SessionImplementor session)
+			throws HibernateException;
+		public abstract String getRole();
+		public abstract Class getOwnerClass();
+		/*public boolean isSet() {
+			return isSet;
+		}
+	
+		public boolean isSorted() {
+			return isSorted;
+		}*/
+		public abstract IdentifierGenerator getIdentifierGenerator();
+		public abstract Type getIdentifierType();
+		public abstract boolean hasOrphanDelete();
+		public abstract Type toType(String propertyName) throws QueryException;
+		public abstract String[] toColumns(String alias, String propertyName)
+			throws QueryException;
+		public abstract Type getType();
+		public abstract String fromJoinFragment(
+			String alias,
+			boolean innerJoin,
+			boolean includeSubclasses);
+		public abstract String[] getJoinKeyColumnNames();
+		public abstract String getName();
+		public abstract String joinSelectFragment(String alias, String suffix);
+		public abstract Loadable getElementPersister();
+		public abstract String whereJoinFragment(
+			String alias,
+			boolean innerJoin,
+			boolean includeSubclasses);
+		public abstract boolean isCollection();
+		public abstract boolean consumesAlias();
+		public abstract Serializable getCollectionSpace();
+		public abstract boolean isManyToMany();
 }
 
 
Index: net/sf/hibernate/collection/PersistentCollection.java
===================================================================
RCS file: /cvsroot/hibernate/Hibernate2/src/net/sf/hibernate/collection/PersistentCollection.java,v
retrieving revision 1.20.2.5
diff -u -r1.20.2.5 PersistentCollection.java
--- net/sf/hibernate/collection/PersistentCollection.java	27 Sep 2003 13:34:46 -0000	1.20.2.5
+++ net/sf/hibernate/collection/PersistentCollection.java	7 Oct 2003 19:04:20 -0000
@@ -56,6 +56,8 @@
 	private CollectionSnapshot collectionSnapshot;
 	private transient boolean directlyAccessible;
 	
+	private Class persister;
+	
 	//Careful: these methods do not initialize the collection.
 	public abstract boolean empty();
 	
@@ -622,7 +624,7 @@
 	protected final SessionImplementor getSession() {
 		return session;
 	}
-
+	
 }
 
 
Index: net/sf/hibernate/impl/SessionFactoryImpl.java
===================================================================
RCS file: /cvsroot/hibernate/Hibernate2/src/net/sf/hibernate/impl/SessionFactoryImpl.java,v
retrieving revision 1.26.2.17
diff -u -r1.26.2.17 SessionFactoryImpl.java
--- net/sf/hibernate/impl/SessionFactoryImpl.java	29 Sep 2003 12:06:29 -0000	1.26.2.17
+++ net/sf/hibernate/impl/SessionFactoryImpl.java	7 Oct 2003 19:04:26 -0000
@@ -140,7 +140,7 @@
 			Collection map = (Collection) collections.next();
 			collectionPersisters.put(
 				map.getRole(),
-				new CollectionPersister(map, cfg, this)
+				PersisterFactory.create(map, cfg, this)
 			);
 		}
 		collectionMetadata = Collections.unmodifiableMap(collectionPersisters);
Index: net/sf/hibernate/mapping/Collection.java
===================================================================
RCS file: /cvsroot/hibernate/Hibernate2/src/net/sf/hibernate/mapping/Collection.java,v
retrieving revision 1.16.2.3
diff -u -r1.16.2.3 Collection.java
--- net/sf/hibernate/mapping/Collection.java	7 Aug 2003 06:21:45 -0000	1.16.2.3
+++ net/sf/hibernate/mapping/Collection.java	7 Oct 2003 19:04:33 -0000
@@ -29,6 +29,7 @@
 	private boolean orphanDelete;
 	private int batchSize=1;
 	private int joinedFetch;
+	private Class persister;
 	
 	protected Collection(PersistentClass owner) {
 		this.owner = owner;
@@ -250,6 +251,13 @@
 		this.joinedFetch=joinedFetch;
 	}
 	
+	public Class getPersister() {
+		return persister;
+	}
+	
+	public void setPersister(Class persister) {
+		this.persister = persister;
+	}
 }
 
 
Index: net/sf/hibernate/persister/PersisterFactory.java
===================================================================
RCS file: /cvsroot/hibernate/Hibernate2/src/net/sf/hibernate/persister/PersisterFactory.java,v
retrieving revision 1.1
diff -u -r1.1 PersisterFactory.java
--- net/sf/hibernate/persister/PersisterFactory.java	9 Jul 2003 03:26:35 -0000	1.1
+++ net/sf/hibernate/persister/PersisterFactory.java	7 Oct 2003 19:04:33 -0000
@@ -1,66 +1,123 @@
-package net.sf.hibernate.persister;
-
-import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
-
-import net.sf.hibernate.HibernateException;
-import net.sf.hibernate.MappingException;
-import net.sf.hibernate.engine.SessionFactoryImplementor;
-import net.sf.hibernate.mapping.PersistentClass;
-
-/**
- * Factory for <tt>ClassPersister</tt> instances
- * @author Gavin King
- */
-public final class PersisterFactory {
-	
-	//TODO: make ClassPersisters *not* depend on SessionFactoryImplementor
-	//interface, if possible
-	
-	private PersisterFactory() {}
-	
-	private static final Class[] PERSISTER_CONSTRUCTOR_ARGS = new Class[] {
-		PersistentClass.class, SessionFactoryImplementor.class
-	};
-	
-	public static ClassPersister create(PersistentClass model, SessionFactoryImplementor factory) throws HibernateException {
-		Class persisterClass = model.getPersister();
-		if (persisterClass==null || persisterClass==EntityPersister.class) {
-			return new EntityPersister(model, factory);
-		}
-		else if (persisterClass==NormalizedEntityPersister.class) {
-			return new NormalizedEntityPersister(model, factory);
-		}
-		else {
-			return create(persisterClass, model, factory);
-		}
-	}
-
-	private static ClassPersister create(Class persisterClass, PersistentClass model, SessionFactoryImplementor factory) 
-	throws HibernateException {
-		Constructor pc;
-		try {
-			pc = persisterClass.getConstructor(PERSISTER_CONSTRUCTOR_ARGS);
-		}
-		catch (Exception e) {
-			throw new MappingException( "Could not get constructor for " + persisterClass.getName(), e );
-		}
-		
-		try {
-			return (ClassPersister) pc.newInstance( new Object[] { model, factory } );
-		}
-		catch (InvocationTargetException ite) {
-			Throwable e = ite.getTargetException();
-			if (e instanceof HibernateException) {
-				throw (HibernateException) e;
-			}
-			else {
-				throw new MappingException( "Could not instantiate persister " + persisterClass.getName(), e );
-			}
-		}
-		catch (Exception e) {
-			throw new MappingException( "Could not instantiate persister " + persisterClass.getName(), e );
-		}
-	}
-	
-}
+package net.sf.hibernate.persister;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+
+import net.sf.hibernate.HibernateException;
+import net.sf.hibernate.MappingException;
+import net.sf.hibernate.cache.CacheException;
+import net.sf.hibernate.cfg.Configuration;
+import net.sf.hibernate.collection.CollectionPersister;
+import net.sf.hibernate.collection.CollectionPersisterImpl;
+import net.sf.hibernate.engine.SessionFactoryImplementor;
+import net.sf.hibernate.impl.SessionFactoryImpl;
+import net.sf.hibernate.mapping.Collection;
+import net.sf.hibernate.mapping.PersistentClass;
+
+/**
+ * Factory for <tt>ClassPersister</tt> instances
+ * @author Gavin King
+ */
+public final class PersisterFactory {
+	
+	//TODO: make ClassPersisters *not* depend on SessionFactoryImplementor
+	//interface, if possible
+	
+	private PersisterFactory() {}
+	
+	private static final Class[] PERSISTER_CONSTRUCTOR_ARGS = new Class[] {
+		PersistentClass.class, SessionFactoryImplementor.class
+	};
+	
+	private static final Class[] COLLECTIONPERSISTER_CONSTRUCTOR_ARGS = new Class[] {
+		  Collection.class, Configuration.class, SessionFactoryImplementor.class
+		};
+	
+	public static ClassPersister create(PersistentClass model, SessionFactoryImplementor factory) throws HibernateException {
+		Class persisterClass = model.getPersister();
+		if (persisterClass==null || persisterClass==EntityPersister.class) {
+			return new EntityPersister(model, factory);
+		}
+		else if (persisterClass==NormalizedEntityPersister.class) {
+			return new NormalizedEntityPersister(model, factory);
+		}
+		else {
+			return create(persisterClass, model, factory);
+		}
+	}
+
+	private static ClassPersister create(Class persisterClass, PersistentClass model, SessionFactoryImplementor factory) 
+	throws HibernateException {
+		Constructor pc;
+		try {
+			pc = persisterClass.getConstructor(PERSISTER_CONSTRUCTOR_ARGS);
+		}
+		catch (Exception e) {
+			throw new MappingException( "Could not get constructor for " + persisterClass.getName(), e );
+		}
+		
+		try {
+			return (ClassPersister) pc.newInstance( new Object[] { model, factory } );
+		}
+		catch (InvocationTargetException ite) {
+			Throwable e = ite.getTargetException();
+			if (e instanceof HibernateException) {
+				throw (HibernateException) e;
+			}
+			else {
+				throw new MappingException( "Could not instantiate persister " + persisterClass.getName(), e );
+			}
+		}
+		catch (Exception e) {
+			throw new MappingException( "Could not instantiate persister " + persisterClass.getName(), e );
+		}
+	}
+
+	/**
+	 * @param map
+	 * @param impl
+	 * @return
+	 */
+	public static CollectionPersister create(Collection model, Configuration cfg, SessionFactoryImplementor factory) throws HibernateException {
+		Class persisterClass = model.getPersister();
+		if (persisterClass==null || persisterClass==CollectionPersisterImpl.class) {
+			return new CollectionPersisterImpl(model, cfg, factory);
+		}
+		else {
+			return create(persisterClass, model, factory);
+		}				
+	}
+
+	/**
+	 * @param persisterClass
+	 * @param model
+	 * @param factory
+	 * @return
+	 */
+	private static CollectionPersister create(Class persisterClass, Collection model, SessionFactoryImplementor factory) throws HibernateException {
+		Constructor pc;
+		try {
+			pc = persisterClass.getConstructor(COLLECTIONPERSISTER_CONSTRUCTOR_ARGS);
+		}
+		catch (Exception e) {
+			throw new MappingException( "Could not get constructor for " + persisterClass.getName(), e );
+		}
+		
+		try {
+			return (CollectionPersister) pc.newInstance( new Object[] { model, factory } );
+		}
+		catch (InvocationTargetException ite) {
+			Throwable e = ite.getTargetException();
+			if (e instanceof HibernateException) {
+				throw (HibernateException) e;
+			}
+			else {
+				throw new MappingException( "Could not instantiate collection persister " + persisterClass.getName(), e );
+			}
+		}
+		catch (Exception e) {
+			throw new MappingException( "Could not instantiate collection persister " + persisterClass.getName(), e );
+		}
+	}
+	
+}
Index: src/net/sf/hibernate/collection/AbstractCollectionPersister.java
===================================================================
RCS file: src/net/sf/hibernate/collection/AbstractCollectionPersister.java
diff -N src/net/sf/hibernate/collection/AbstractCollectionPersister.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/net/sf/hibernate/collection/AbstractCollectionPersister.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,1010 @@
+/*
+ * Created on 07-10-2003
+ *
+ * To change the template for this generated file go to
+ * Window - Preferences - Java - Code Generation - Code and Comments
+ */
+package net.sf.hibernate.collection;
+
+import java.io.Serializable;
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.util.HashSet;
+import java.util.Iterator;
+
+import net.sf.hibernate.AssertionFailure;
+import net.sf.hibernate.HibernateException;
+import net.sf.hibernate.JDBCException;
+import net.sf.hibernate.MappingException;
+import net.sf.hibernate.QueryException;
+import net.sf.hibernate.cache.CacheConcurrencyStrategy;
+import net.sf.hibernate.cache.CacheException;
+import net.sf.hibernate.cfg.Configuration;
+import net.sf.hibernate.dialect.Dialect;
+import net.sf.hibernate.engine.SessionFactoryImplementor;
+import net.sf.hibernate.engine.SessionImplementor;
+import net.sf.hibernate.id.IdentifierGenerator;
+import net.sf.hibernate.impl.MessageHelper;
+import net.sf.hibernate.loader.BatchingCollectionInitializer;
+import net.sf.hibernate.loader.CollectionInitializer;
+import net.sf.hibernate.loader.CollectionLoader;
+import net.sf.hibernate.loader.Loader;
+import net.sf.hibernate.loader.OneToManyLoader;
+import net.sf.hibernate.loader.OuterJoinLoader;
+import net.sf.hibernate.mapping.Collection;
+import net.sf.hibernate.mapping.Column;
+import net.sf.hibernate.mapping.IdentifierCollection;
+import net.sf.hibernate.mapping.IndexedCollection;
+import net.sf.hibernate.mapping.PersistentClass;
+import net.sf.hibernate.mapping.Table;
+import net.sf.hibernate.metadata.CollectionMetadata;
+import net.sf.hibernate.persister.ClassPersister;
+import net.sf.hibernate.persister.Loadable;
+import net.sf.hibernate.persister.PropertyMapping;
+import net.sf.hibernate.sql.Alias;
+import net.sf.hibernate.sql.Delete;
+import net.sf.hibernate.sql.Insert;
+import net.sf.hibernate.sql.SelectFragment;
+import net.sf.hibernate.sql.Template;
+import net.sf.hibernate.sql.Update;
+import net.sf.hibernate.type.AbstractComponentType;
+import net.sf.hibernate.type.AssociationType;
+import net.sf.hibernate.type.EntityType;
+import net.sf.hibernate.type.PersistentCollectionType;
+import net.sf.hibernate.type.Type;
+import net.sf.hibernate.util.ArrayHelper;
+import net.sf.hibernate.util.StringHelper;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+/**
+ * @author MAX
+ *
+ * To change the template for this generated type comment go to
+ * Window - Preferences - Java - Code Generation - Code and Comments
+ */
+public class AbstractCollectionPersister implements CollectionPersister, CollectionMetadata {
+
+//	private final String sqlSelectString;
+	  private final String sqlDeleteString;
+	  private final String sqlInsertRowString;
+	  private final String sqlUpdateRowString;
+	  private final String sqlDeleteRowString;
+	  private final String sqlOrderByString;
+	  private final String sqlWhereString;
+	  private final String sqlOrderByStringTemplate;
+	  private final String sqlWhereStringTemplate;
+	  private final boolean hasOrder;
+	  private final boolean hasWhere;
+	  private final boolean hasOrphanDelete;
+	  //private final boolean isSet;
+	  private final Type keyType;
+	  private final Type indexType;
+	  private final Type elementType;
+	  private final String[] keyColumnNames;
+	  private final String[] indexColumnNames;
+	  private final String[] elementColumnNames;
+	  //private final String[] unquotedIndexColumnNames;
+	  //private final String[] unquotedElementColumnNames;
+	  //private final String[] unquotedKeyColumnNames;
+	  private final String[] rowSelectColumnNames;
+	  private final String[] indexColumnAliases;
+	  private final String[] elementColumnAliases;
+	  private final String[] keyColumnAliases;
+	  private final Type rowSelectType;
+	  private final boolean primitiveArray;
+	  private final boolean array;
+	  private final boolean isOneToMany;
+	  private final boolean isManyToMany;
+	  private final String qualifiedTableName;
+	  private final boolean hasIndex;
+	  private final boolean isLazy;
+	  private final boolean isInverse;
+	  private final int batchSize;
+	  private final Class elementClass;
+	  private final CacheConcurrencyStrategy cache;
+	  private final PersistentCollectionType collectionType;
+	  private final int enableJoinedFetch;
+	  private final Class ownerClass;
+	  //private final boolean isSorted;
+	  private final IdentifierGenerator identifierGenerator;
+	  private final String unquotedIdentifierColumnName;
+	  private final Type identifierType;
+	  private final boolean hasIdentifier;
+	  private final String identifierColumnName;
+	  private final String identifierColumnAlias;
+	  private final Dialect dialect;
+	  private final PropertyMapping elementPropertyMapping;
+	  private final Loadable elementPersister;
+	
+	  private final CollectionInitializer loader;
+	
+	  private final String role;
+	  //private final SessionFactoryImplementor factory;
+	
+	  private static final Log log = LogFactory.getLog(CollectionPersister.class);
+	
+	  public AbstractCollectionPersister(Collection collection, Configuration datastore, SessionFactoryImplementor factory) 
+		  throws MappingException, CacheException {
+		  
+		  dialect = factory.getDialect();
+		  collectionType = collection.getType();
+		  role = collection.getRole();
+		  ownerClass = collection.getOwnerClass();
+		  Alias alias = new Alias("__");
+		
+		  sqlOrderByString = collection.getOrderBy();
+		  hasOrder = sqlOrderByString!=null;
+		  sqlOrderByStringTemplate = hasOrder ? Template.renderOrderByStringTemplate(sqlOrderByString, dialect) : null;
+		  sqlWhereString = collection.getWhere();
+		  hasWhere = sqlWhereString!=null;
+		  sqlWhereStringTemplate = hasWhere ? Template.renderWhereStringTemplate(sqlWhereString, dialect) : null;
+		
+		  hasOrphanDelete = collection.hasOrphanDelete();
+		
+		  batchSize = collection.getBatchSize();
+		
+		  cache=collection.getCache();
+		
+		  keyType = collection.getKey().getType();
+		  Iterator iter = collection.getKey().getColumnIterator();
+		  int span = collection.getKey().getColumnSpan();
+		  keyColumnNames = new String[span];
+		  String[] keyAliases = new String[span];
+		  int k=0;
+		  while ( iter.hasNext() ) {
+			  Column col = ( (Column) iter.next() );
+			  keyColumnNames[k] = col.getQuotedName(dialect);
+			  keyAliases[k] = col.getAlias();
+			  k++;
+		  }
+		  keyColumnAliases = alias.toAliasStrings(keyAliases);
+		  //unquotedKeyColumnNames = StringHelper.unQuote(keyColumnAliases);
+		  java.util.Set distinctColumns = new HashSet();
+		  checkColumnDuplication( distinctColumns, collection.getKey().getColumnIterator() );
+		
+		  //isSet = collection.isSet();
+		  //isSorted = collection.isSorted();
+		  isOneToMany = collection.isOneToMany();
+		  primitiveArray = collection.isPrimitiveArray();
+		  array = collection.isArray();
+		
+		  Table table;
+		  if (isOneToMany) {
+			  isManyToMany = false;
+			  EntityType type = collection.getOneToMany().getType();
+			  elementType = type;
+			  PersistentClass associatedClass = datastore.getClassMapping( type.getAssociatedClass() );
+			  span = associatedClass.getIdentifier().getColumnSpan();
+			  iter = associatedClass.getKey().getColumnIterator();
+			  table = associatedClass.getTable();
+			  enableJoinedFetch = OuterJoinLoader.EAGER;
+			  //don't do this check, since it is actually valid for a one-to-many <key> 
+			  //or <index> to consist of some columns of a composite-id
+			  //checkColumnDuplication( distinctColumns, associatedClass.getKey().getColumnIterator() );
+		  }
+		  else {
+			  table = collection.getTable();
+			  elementType = collection.getElement().getType();
+			  isManyToMany = elementType.isEntityType();
+			  span = collection.getElement().getColumnSpan();
+			  enableJoinedFetch = collection.getElement().getOuterJoinFetchSetting();			
+			  iter = collection.getElement().getColumnIterator();
+			  checkColumnDuplication( distinctColumns, collection.getElement().getColumnIterator() );
+		  }
+		
+		  if ( elementType.isEntityType() ) {
+			  //TODO: what if it is just an ordinary ClassPersister, not Loadable
+			  //      can the collection fwk even handle that?
+			  elementPersister = (Loadable) factory.getPersister( ( (EntityType) elementType ).getAssociatedClass() );
+		  }
+		  else {
+			  elementPersister = null;
+		  }
+
+		  qualifiedTableName = table.getQualifiedName( dialect, factory.getDefaultSchema() );
+		  String[] aliases = new String[span];
+		  elementColumnNames = new String[span];
+		  int j=0;
+		  while ( iter.hasNext() ) {
+			  Column col = (Column) iter.next();
+			  elementColumnNames[j] = col.getQuotedName(dialect);
+			  aliases[j] = col.getAlias();
+			  j++;
+		  }
+		
+		  elementColumnAliases = alias.toAliasStrings(aliases);
+		  //unquotedElementColumnNames = StringHelper.unQuote(elementColumnAliases);
+		
+		  Type selectColumns;
+		  String[] selectType;
+		  if ( hasIndex = collection.isIndexed() ) {
+			  IndexedCollection indexedCollection = (IndexedCollection) collection;
+			  indexType = indexedCollection.getIndex().getType();
+			  int indexSpan = indexedCollection.getIndex().getColumnSpan();
+			  iter = indexedCollection.getIndex().getColumnIterator();
+			  indexColumnNames = new String[indexSpan];
+			  String[] indexAliases = new String[indexSpan];
+			  int i=0;
+			  while ( iter.hasNext() ) {
+				  Column indexCol = (Column) iter.next();
+				  indexAliases[i] = indexCol.getAlias();
+				  indexColumnNames[i] = indexCol.getQuotedName(dialect);
+				  i++;
+			  }
+			  selectType = indexColumnNames;
+			  selectColumns = indexType;
+			  indexColumnAliases = alias.toAliasStrings(indexAliases);
+			  //unquotedIndexColumnNames = StringHelper.unQuote(indexColumnAliases);
+			  checkColumnDuplication( distinctColumns, indexedCollection.getIndex().getColumnIterator() );
+		  }
+		  else {
+			  indexType = null;
+			  indexColumnNames = null;
+			  indexColumnAliases = null;
+			  selectType = elementColumnNames;
+			  selectColumns = elementType;
+		  }
+		
+		  if ( hasIdentifier = collection.isIdentified() ) {
+			  if (isOneToMany) throw new MappingException("one-to-many collections with identifiers are not supported");
+			  IdentifierCollection idColl = (IdentifierCollection) collection;
+			  identifierType = idColl.getIdentifier().getType();
+			  iter = idColl.getIdentifier().getColumnIterator();
+			  Column col = (Column) iter.next();
+			  identifierColumnName = col.getQuotedName(dialect);
+			  selectType = new String[] { identifierColumnName };
+			  selectColumns = identifierType;
+			  identifierColumnAlias = alias.toAliasString( col.getAlias() );
+			  //unquotedIdentifierColumnName = StringHelper.unQuote(identifierColumnAlias);
+			  unquotedIdentifierColumnName = identifierColumnAlias;
+			  identifierGenerator = idColl.getIdentifier().createIdentifierGenerator( factory.getDialect() );
+			  checkColumnDuplication( distinctColumns, idColl.getIdentifier().getColumnIterator() );
+		  }
+		  else {
+			  identifierType = null;
+			  identifierColumnName = null;
+			  identifierColumnAlias = null;
+			  unquotedIdentifierColumnName = null;
+			  identifierGenerator = null;
+		  }
+		
+		  rowSelectColumnNames = selectType;
+		  rowSelectType = selectColumns;
+		
+		  //sqlSelectString = sqlSelectString();
+		  sqlDeleteString = generateDeleteString();
+		  //sqlSelectRowString = sqlSelectRowString();
+		  sqlInsertRowString = generateInsertRowString();
+		  sqlUpdateRowString = generateUpdateRowString();
+		  sqlDeleteRowString = generateDeleteRowString();
+		  isLazy = collection.isLazy();
+		
+		  isInverse = collection.isInverse();
+		
+		  if ( collection.isArray() ) {
+			  elementClass = ( (net.sf.hibernate.mapping.Array) collection ).getElementClass();
+		  }
+		  else {
+			  // for non-arrays, we don't need to know the element class
+			  elementClass = null; //elementType.returnedClass();
+		  }
+		
+		  loader = createCollectionInitializer(factory);
+		
+		  if ( elementType.isComponentType() ) {
+			  elementPropertyMapping = new CompositeElementPropertyMapping( 
+				  elementColumnNames, (AbstractComponentType) elementType, factory 
+			  );
+		  }
+		  else if ( !elementType.isEntityType() ) {
+			  elementPropertyMapping = new ElementPropertyMapping(elementColumnNames, elementType);
+		  }
+		  else {
+			  ClassPersister persister = factory.getPersister( ( (EntityType) elementType ).getAssociatedClass() );
+			  if ( persister instanceof PropertyMapping ) { //not all classpersisters implement PropertyMapping!
+				  elementPropertyMapping = (PropertyMapping) persister;
+			  }
+			  else {
+				  elementPropertyMapping = new ElementPropertyMapping(elementColumnNames, elementType);
+			  } 
+		  }
+		
+	  }
+	
+	  public CollectionInitializer getInitializer() {
+		  return loader;
+	  }
+	
+	  private CollectionInitializer createCollectionInitializer(SessionFactoryImplementor factory) throws MappingException {
+		  Loader nonbatchLoader = isOneToMany() ?
+			  (Loader) new OneToManyLoader(this, factory) :
+			  (Loader) new CollectionLoader(this, factory);
+		  if (batchSize>1) {
+			  Loader batchLoader = isOneToMany() ?
+				  (Loader) new OneToManyLoader(this, batchSize, factory) :
+				  (Loader) new CollectionLoader(this, batchSize, factory);
+			  int smallBatchSize = (int) Math.round( Math.sqrt(batchSize) );
+			  Loader smallBatchLoader = isOneToMany() ?
+				  (Loader) new OneToManyLoader(this, smallBatchSize, factory) :
+				  (Loader) new CollectionLoader(this, smallBatchSize, factory);
+			  // the strategy for choosing batch or single load:
+			  return new BatchingCollectionInitializer(this, batchSize, batchLoader, smallBatchSize, smallBatchLoader, nonbatchLoader);
+		  }
+		  else {
+			  // don't do batch loading
+			  return (CollectionInitializer) nonbatchLoader;
+		  }
+	  }
+	
+	  public void cache(Serializable id, PersistentCollection coll, SessionImplementor s) throws HibernateException {
+		  if (cache!=null) {
+			  if ( log.isDebugEnabled() ) log.debug("Caching collection: " + role + '#' + id);
+			  cache.put( id, coll.disassemble(this), s.getTimestamp() );
+		  }
+	  }
+	
+	  public CacheConcurrencyStrategy getCache() {
+		  return cache;
+	  }
+	
+	  public boolean hasCache() {
+		  return cache!=null;
+	  }
+	
+	  public PersistentCollection getCachedCollection(Serializable id, Object owner, SessionImplementor s) throws HibernateException {
+		  if (cache==null) {
+			  return null;
+		  }
+		  else {
+			  if ( log.isDebugEnabled() ) log.debug("Searching for collection in cache: " + role + '#' + id);
+			  Serializable cached = (Serializable) cache.get( id, s.getTimestamp() );
+			  if (cached==null) {
+				  return null;
+			  }
+			  else {
+				  return collectionType.assembleCachedCollection(s, this, cached, owner);
+			  }
+		  }
+	  }
+	
+	  public void softlock(Serializable id) throws CacheException {
+		  if (cache!=null) cache.lock(id);
+	  }
+	  public void releaseSoftlock(Serializable id) throws CacheException {
+		  if (cache!=null) cache.release(id);
+	  }
+	
+	  public PersistentCollectionType getCollectionType() {
+		  return collectionType;
+	  }
+	
+	  public String getSQLWhereString(String alias) {
+		  return StringHelper.replace(sqlWhereStringTemplate, Template.TEMPLATE, alias);
+	  }
+	
+	  public String getSQLOrderByString(String alias) {
+		  return StringHelper.replace(sqlOrderByStringTemplate, Template.TEMPLATE, alias);
+	  }
+	
+	  public int enableJoinedFetch() {
+		  return enableJoinedFetch;
+	  }
+	
+	  public boolean hasOrdering() {
+		  return hasOrder;
+	  }
+	
+	  public boolean hasWhere() {
+		  return hasWhere; 
+	  }
+	
+	  private String getSQLDeleteString() {
+		  return sqlDeleteString;
+	  }
+	
+	  private String getSQLInsertRowString() {
+		  return sqlInsertRowString;
+	  }
+	
+	  private String getSQLUpdateRowString() {
+		  return sqlUpdateRowString;
+	  }
+	
+	  private String getSQLDeleteRowString() {
+		  return sqlDeleteRowString;
+	  }
+	
+	  public Type getKeyType() {
+		  return keyType;
+	  }
+	
+	  public Type getIndexType() {
+		  return indexType;
+	  }
+	
+	  public Type getElementType() {
+		  return elementType;
+	  }
+	
+	  /**
+	   * Return the element class of an array, or null otherwise
+	   */
+	  public Class getElementClass() { //needed by arrays
+		  return elementClass;
+	  }
+	
+	  public Object readElement(ResultSet rs, Object owner, SessionImplementor session) throws HibernateException, SQLException {
+		  Object element = getElementType().nullSafeGet(rs, elementColumnAliases, session, owner);
+		  return element;
+	  }
+	  public Object readIndex(ResultSet rs, SessionImplementor session) throws HibernateException, SQLException {
+		  Object index = getIndexType().nullSafeGet(rs, indexColumnAliases, session, null);
+		  if (index==null) throw new HibernateException("null index column for collection: " + role);
+		  return index;
+	  }
+	
+	  public Object readIdentifier(ResultSet rs, SessionImplementor session) throws HibernateException, SQLException {
+		  Object id = getIdentifierType().nullSafeGet(rs, unquotedIdentifierColumnName, session, null);
+		  if (id==null) throw new HibernateException("null identifier column for collection: " + role);
+		  return id;
+	  }
+	
+	  public Object readKey(ResultSet rs, SessionImplementor session) throws HibernateException, SQLException {
+		  return getKeyType().nullSafeGet(rs, keyColumnAliases, session, null);
+	  }
+	
+	  public void writeElement(PreparedStatement st, Object elt, boolean writeOrder, SessionImplementor session)
+	  throws HibernateException, SQLException {
+		  getElementType().nullSafeSet(
+			  st, 
+			  elt, 
+			  1+(writeOrder?0:keyColumnNames.length+(hasIndex?indexColumnNames.length:0)+(hasIdentifier?1:0)), 
+			  session
+		  );
+	  }
+	
+	  public void writeIndex(PreparedStatement st, Object idx, boolean writeOrder, SessionImplementor session)
+	  throws HibernateException, SQLException {
+		  getIndexType().nullSafeSet(st, idx, 1+keyColumnNames.length + (writeOrder?elementColumnNames.length:0), session);
+	  }
+	
+	  public void writeIdentifier(PreparedStatement st, Object idx, boolean writeOrder, SessionImplementor session)
+	  throws HibernateException, SQLException {
+		  getIdentifierType().nullSafeSet(st, idx, 1+(writeOrder?elementColumnNames.length:keyColumnNames.length), session);
+	  }
+	
+	  private void writeRowSelect(PreparedStatement st, Object idx, SessionImplementor session)
+	  throws HibernateException, SQLException {
+		  rowSelectType.nullSafeSet(st, idx, 1+(hasIdentifier?0:keyColumnNames.length), session);
+	  }
+	
+	  public void writeKey(PreparedStatement st, Serializable id, boolean writeOrder, SessionImplementor session)
+	  throws HibernateException, SQLException {
+		  if (id==null) throw new NullPointerException("null key for collection: " + role);  //an assertion
+		  getKeyType().nullSafeSet(st, id, 1+(writeOrder?elementColumnNames.length:0), session);
+	  }
+	
+	  public boolean isPrimitiveArray() {
+		  return primitiveArray;
+	  }
+	
+	  public boolean isArray() {
+		  return array;
+	  }
+	
+	  /**
+	   * Generate a list of collection index and element columns
+	   */
+	  public String selectClauseFragment(String alias) {
+		  SelectFragment frag = new SelectFragment()
+			  .setSuffix(StringHelper.EMPTY_STRING)
+			  .addColumns(alias, elementColumnNames, elementColumnAliases)
+			  .addColumns(alias, keyColumnNames, keyColumnAliases);
+		  if (hasIndex) frag.addColumns(alias, indexColumnNames, indexColumnAliases);
+		  if (hasIdentifier) frag.addColumn(alias, identifierColumnName, identifierColumnAlias);
+		  return frag.toFragmentString()
+			  .substring(2); //strip leading ','
+	  }
+	
+	  /**
+	   * Generate a list of collection index, key and element columns
+	   */
+	  public String multiselectClauseFragment(String alias) {
+		  SelectFragment frag = new SelectFragment()
+			  .setSuffix(StringHelper.EMPTY_STRING)
+			  .addColumns(alias, elementColumnNames, elementColumnAliases)
+			  .addColumns(alias, keyColumnNames, keyColumnAliases);
+		  if (hasIndex) frag.addColumns(alias, indexColumnNames, indexColumnAliases);
+		  if (hasIdentifier) frag.addColumn(alias, identifierColumnName, identifierColumnAlias);
+		  return frag.toFragmentString()
+			  .substring(2); //strip leading ','
+	  }
+	
+	  /*private String sqlSelectString() {
+		  //we no longer have Jon Lipsky's patch to allow a Map from id's to objects
+		  SimpleSelect select = new SimpleSelect()
+			  .setTableName(qualifiedTableName)
+			  .addColumns(elementColumnNames);
+		  if (hasIndex) select.addColumns(indexColumnNames);
+		  select.addCondition( keyColumnNames, "=?" );
+		  if (hasWhere) select.addWhereToken( " and " + sqlWhereString );
+		  if (hasOrder) select.setOrderBy(sqlOrderByString);
+		  return select.toStatementString();
+	  }*/
+	
+	  private String generateDeleteString() {
+		  if (isOneToMany) {
+			  Update update = new Update()
+				  .setTableName(qualifiedTableName)
+				  .addColumns(keyColumnNames, "null")
+				  .setPrimaryKeyColumnNames(keyColumnNames);
+			  if (hasIndex) update.addColumns(indexColumnNames, "null");
+			  if (hasWhere) update.setWhere(sqlWhereString);
+			  return update.toStatementString();
+		  }
+		  else {
+			  Delete delete = new Delete()
+				  .setTableName(qualifiedTableName)
+				  .setPrimaryKeyColumnNames(keyColumnNames);
+			  if (hasWhere) delete.setWhere(sqlWhereString);
+			  return delete.toStatementString();
+		  }
+	  }
+	
+	  private String generateInsertRowString() {
+		  if (isOneToMany) {
+			  Update update = new Update()
+				  .setTableName(qualifiedTableName)
+				  .addColumns(keyColumnNames);
+			  if (hasIndex) update.addColumns(indexColumnNames); 
+			  //identifier collections not supported for 1-to-many 
+			  return update.setPrimaryKeyColumnNames(elementColumnNames)
+				  .toStatementString();
+		  }
+		  else {
+			  Insert insert = new Insert(null)
+				  .setTableName(qualifiedTableName)
+				  .addColumns(keyColumnNames);
+			  if (hasIndex) insert.addColumns(indexColumnNames);
+			  if (hasIdentifier) insert.addColumn(identifierColumnName);
+			  return insert.addColumns(elementColumnNames)
+				  .toStatementString();
+		  }
+	  }
+
+	  private String generateUpdateRowString() {
+		  if (isOneToMany) {
+			  return null;
+		  }
+		  else {
+			  Update update = new Update()
+				  .setTableName(qualifiedTableName)
+				  .addColumns(elementColumnNames);
+			  if (hasIdentifier) {
+				  update.setPrimaryKeyColumnNames(rowSelectColumnNames);
+			  }
+			  else {
+				  update.setPrimaryKeyColumnNames( ArrayHelper.join(keyColumnNames, rowSelectColumnNames) );
+			  }
+			  return update.toStatementString();
+		  }
+	  }
+	
+	  private String generateDeleteRowString() {
+		  final String[] pkColumns;
+		  if (hasIdentifier) {
+			  pkColumns = rowSelectColumnNames;
+		  }
+		  else {
+			  pkColumns = ArrayHelper.join(keyColumnNames, rowSelectColumnNames);
+		  }
+		  if (isOneToMany) {
+			  Update update = new Update()
+				  .setTableName(qualifiedTableName)
+				  .addColumns(keyColumnNames, "null");
+			  if (hasIndex) update.addColumns(indexColumnNames, "null");
+			  return update.setPrimaryKeyColumnNames(pkColumns)
+				  .toStatementString();
+		  }
+		  else {
+			  return new Delete()
+				  .setTableName(qualifiedTableName)
+				  .setPrimaryKeyColumnNames(pkColumns)
+				  .toStatementString();
+		  }
+	  }
+	
+	
+	  public String[] getIndexColumnNames() {
+		  return indexColumnNames;
+	  }
+	
+	  public String[] getElementColumnNames() {
+		  return elementColumnNames;
+	  }
+	
+	  public String[] getKeyColumnNames() {
+		  return keyColumnNames;
+	  }
+	
+	  public boolean isOneToMany() {
+		  return isOneToMany;
+	  }
+	
+	  public boolean hasIndex() {
+		  return hasIndex;
+	  }
+	
+	  public boolean isLazy() { return isLazy; }
+	
+	  public boolean isInverse() {
+		  return isInverse;
+	  }
+	
+	  public String getTableName() {
+		  return qualifiedTableName;
+	  }
+	
+	  public final void remove(Serializable id, SessionImplementor session) throws HibernateException {
+		
+		  if ( !isInverse ) {
+			
+			  if ( log.isDebugEnabled() ) log.debug( "Deleting collection: " + MessageHelper.infoString(this, id) );
+			
+			  // Remove all the old entries
+			
+			  try {
+				  PreparedStatement st = session.getBatcher().prepareBatchStatement( getSQLDeleteString() );
+				
+				  try {
+					  writeKey(st, id, false, session);
+					  session.getBatcher().addToBatch(-1);
+				  }
+				  catch (SQLException sqle) {
+					  session.getBatcher().abortBatch(sqle);
+					  throw sqle;
+				  }
+				
+				  if ( log.isDebugEnabled() ) log.debug("done deleting collection");
+			  }
+			  catch (SQLException sqle) {
+				  throw new JDBCException("could not delete collection: " + MessageHelper.infoString(this, id), sqle );
+			  }
+			
+		  }
+		
+	  }
+	
+	  public final void recreate(PersistentCollection collection, Serializable id, SessionImplementor session)
+	  throws HibernateException {
+		
+		  if (!isInverse) {
+			
+			  if ( log.isDebugEnabled() ) log.debug( "Inserting collection: " + MessageHelper.infoString(this, id) );
+			
+			  try {
+				  //create all the new entries
+				  Iterator entries = collection.entries();
+				  if ( entries.hasNext() ) {
+					  try {
+						  collection.preInsert(this);
+						  int i=0;
+						  while ( entries.hasNext() ) {
+							  Object entry = entries.next();
+							  if ( collection.entryExists(entry, i) ) {
+								  PreparedStatement st = session.getBatcher().prepareBatchStatement( getSQLInsertRowString() );
+								  writeKey(st, id, false, session);
+								  collection.writeTo(st, this, entry, i, false);
+								  session.getBatcher().addToBatch(1);
+								  collection.afterRowInsert(this, entry, i);
+							  }
+							  i++;
+						  }
+					  }
+					  catch (SQLException sqle) {
+						  session.getBatcher().abortBatch(sqle);
+						  throw sqle;
+					  }
+					
+					  if ( log.isDebugEnabled() ) log.debug("done inserting collection");
+				  }
+				  else {
+					  if ( log.isDebugEnabled() ) log.debug("collection was empty");
+				  }
+			  }
+			  catch (SQLException sqle) {
+				  throw new JDBCException("could not insert collection: " + MessageHelper.infoString(this, id), sqle );
+			  }
+		  }
+	  }
+	
+	  public final void deleteRows(PersistentCollection collection, Serializable id, SessionImplementor session)
+	  throws HibernateException {
+		
+		  if (!isInverse) {
+			
+			  if ( log.isDebugEnabled() ) log.debug( "Deleting rows of collection: " + MessageHelper.infoString(this, id) );
+			
+			  try {
+				  //delete all the deleted entries
+				  Iterator entries = collection.getDeletes(elementType);
+				  if ( entries.hasNext() ) {
+					
+					  PreparedStatement st = session.getBatcher().prepareBatchStatement( getSQLDeleteRowString() );
+					
+					  try {
+						  while ( entries.hasNext() ) {
+							  if (!hasIdentifier) writeKey(st, id, false, session );
+							  writeRowSelect( st, entries.next(), session );
+							  session.getBatcher().addToBatch(-1);
+						  }
+					  }
+					  catch (SQLException sqle) {
+						  session.getBatcher().abortBatch(sqle);
+						  throw sqle;
+					  }
+					
+					  if ( log.isDebugEnabled() ) log.debug("done deleting collection rows");
+				  }
+				  else {
+					  if ( log.isDebugEnabled() ) log.debug("no rows to delete");
+				  }
+			  }
+			  catch (SQLException sqle) {
+				  throw new JDBCException("could not delete collection rows: " + MessageHelper.infoString(this, id), sqle );
+			  }
+		  }
+	  }
+	
+	  private final void update(Serializable id, PersistentCollection collection, SessionImplementor session) 
+	  throws HibernateException {
+		
+		  try {
+			  PreparedStatement st = null;
+			  Iterator entries = collection.entries();
+			  int i=0;
+			  try {
+				  while ( entries.hasNext() ) {
+					  Object entry = entries.next();
+					  if ( collection.needsUpdating(entry, i, elementType) ) {
+						  if (st==null) st = session.getBatcher().prepareBatchStatement( getSQLUpdateRowString() );
+						  if (!hasIdentifier) writeKey(st, id, true, session);
+						  collection.writeTo( st, this, entry, i, true );
+						  session.getBatcher().addToBatch(1);
+					  }
+					  i++;
+				  }
+			  }
+			  catch (SQLException sqle) {
+				  session.getBatcher().abortBatch(sqle);
+				  throw sqle;
+			  }
+		  }
+		  catch (SQLException sqle) {
+			  throw new JDBCException("could not update collection rows: " + MessageHelper.infoString(this, id), sqle );
+		  }
+	  }
+	
+	  private final void updateOneToMany(Serializable id, PersistentCollection collection, SessionImplementor session) 
+	  throws HibernateException {
+
+		  try {		
+			  PreparedStatement rmvst = null;
+			  int i=0;
+			  Iterator entries = collection.entries();
+			  try {
+				  while ( entries.hasNext() ) {
+					  Object entry = entries.next();
+					  if ( collection.needsUpdating(entry, i, elementType) ) {  // will still be issued when it used to be null
+						  if (rmvst==null) rmvst = session.getBatcher().prepareBatchStatement( getSQLDeleteRowString() );
+						  writeKey(rmvst, id, false, session);
+						  writeIndex(rmvst, collection.getIndex(entry, i), false, session);
+						  session.getBatcher().addToBatch(-1);
+					  }
+					  i++;
+				  }
+			  }
+			  catch (SQLException sqle) {
+				  session.getBatcher().abortBatch(sqle);
+				  throw sqle;
+			  }
+			  // finish all the "removes" first to take care of possible unique constraints
+			  // and so that we can take advantage of batching
+			  PreparedStatement insst = null;
+			  i=0;
+			  entries = collection.entries();
+			  try {
+				  while ( entries.hasNext() ) {
+					  Object entry = entries.next();
+					  if ( collection.needsUpdating(entry, i, elementType) ) {
+						  if (insst==null) insst = session.getBatcher().prepareBatchStatement( getSQLInsertRowString() );
+						  writeKey(insst, id, false, session);
+						  collection.writeTo(insst, this, entry, i, false);
+						  session.getBatcher().addToBatch(1);
+					  }
+					  i++;
+				  }
+			  }
+			  catch (SQLException sqle) {
+				  session.getBatcher().abortBatch(sqle);
+				  throw sqle;
+			  }
+		  }
+		  catch (SQLException sqle) {
+			  throw new JDBCException("could not update collection rows: " + MessageHelper.infoString(this, id), sqle );
+		  }
+	  }
+	
+	  public final void updateRows(PersistentCollection collection, Serializable id, SessionImplementor session) throws HibernateException {
+		
+		  if (!isInverse) {
+			
+			  if ( log.isDebugEnabled() ) log.debug("Updating rows of collection: " + role + "#" + id);
+			
+			  //update all the modified entries
+			  if (isOneToMany) {
+				  updateOneToMany(id, collection, session);
+			  }
+			  else {
+				  update(id, collection, session);
+			  }
+			
+			  if ( log.isDebugEnabled() ) log.debug("done updating rows");
+		  }
+	  }
+	
+	  public final void insertRows(PersistentCollection collection, Serializable id, SessionImplementor session)
+	  throws HibernateException {
+		
+		  if (!isInverse) {
+			
+			  if ( log.isDebugEnabled() ) log.debug( "Inserting rows of collection: " + MessageHelper.infoString(this, id) );
+			
+			  try {
+				  //insert all the new entries
+				  Iterator entries = collection.entries();
+				  try {
+					  collection.preInsert(this);
+					  int i=0;
+					  while ( entries.hasNext() ) {
+						  Object entry = entries.next();
+						  if ( collection.needsInserting(entry, i, elementType) ) {
+							  PreparedStatement st = session.getBatcher().prepareBatchStatement( getSQLInsertRowString() );
+							  writeKey(st, id, false, session);
+							  collection.writeTo( st, this, entry, i, false );
+							  session.getBatcher().addToBatch(1);
+							  collection.afterRowInsert(this, entry, i);
+						  }
+						  i++;
+					  }
+				  }
+				  catch (SQLException sqle) {
+					  session.getBatcher().abortBatch(sqle);
+					  throw sqle;
+				  }
+			  }
+			  catch (SQLException sqle) {
+				  throw new JDBCException("could not insert collection rows: " + MessageHelper.infoString(this, id), sqle );
+			  }
+			
+			  if ( log.isDebugEnabled() ) log.debug("done inserting rows");
+		  }
+	  }
+	
+	
+	  public String getRole() {
+		  return role;
+	  }
+	
+	  public Class getOwnerClass() {
+		  return ownerClass;
+	  }
+	
+	  /*public boolean isSet() {
+		  return isSet;
+	  }
+	
+	  public boolean isSorted() {
+		  return isSorted;
+	  }*/
+	
+	  public IdentifierGenerator getIdentifierGenerator() {
+		  return identifierGenerator;
+	  }
+	
+	  public Type getIdentifierType() {
+		  return identifierType;
+	  }
+	
+	  public boolean hasOrphanDelete() {
+		  return hasOrphanDelete;
+	  }
+	
+	  private void checkColumnDuplication(java.util.Set distinctColumns, Iterator columns) throws MappingException {
+		  while ( columns.hasNext() ) {
+			  Column col = (Column) columns.next();
+			  if ( !distinctColumns.add( col.getName() ) ) throw new MappingException(
+				  "Repeated column in mapping for collection: " +
+				  role +
+				  " column: " + 
+				  col.getName()
+			  );
+		  }
+	  }
+
+	  public Type toType(String propertyName) throws QueryException {
+		  if ( "index".equals(propertyName) ) return indexType;
+		  return elementPropertyMapping.toType(propertyName);
+	  }
+
+	  public String[] toColumns(String alias, String propertyName)
+		  throws QueryException {
+		
+		  if ( "index".equals(propertyName) ) {
+			  if (isManyToMany) throw new QueryException("index() function not supported for many-to-many association");
+			  return StringHelper.prefix(indexColumnNames, alias + StringHelper.DOT);
+		  }
+		  return elementPropertyMapping.toColumns(alias, propertyName);
+	  }
+
+	  public Type getType() {
+		  return elementPropertyMapping.getType(); //==elementType ??
+	  }
+
+	  public String fromJoinFragment(String alias, boolean innerJoin, boolean includeSubclasses) {
+		  return StringHelper.EMPTY_STRING;
+	  }
+
+	  public String[] getJoinKeyColumnNames() {
+		  return getKeyColumnNames();
+	  }
+
+	  public String getName() {
+		  return getRole();
+	  }
+
+	  public String joinSelectFragment(String alias, String suffix) {
+		
+		  StringBuffer buf = new StringBuffer();
+		  buf.append( selectClauseFragment(alias) );
+		  if ( isOneToMany() ) {
+			  buf.append(StringHelper.COMMA_SPACE)
+				  .append( elementPersister.identifierSelectFragment(alias, suffix) )
+				  .append( elementPersister.propertySelectFragment(alias, suffix) );
+		  }
+		  return buf.toString();
+
+	  }
+	
+	  public Loadable getElementPersister() {
+		  if (elementPersister==null) throw new AssertionFailure("not an association");
+		  return elementPersister;
+	  }
+
+	  public String whereJoinFragment(String alias, boolean innerJoin, boolean includeSubclasses) {
+		  return StringHelper.EMPTY_STRING;
+	  }
+
+	  public boolean isCollection() {
+		  return true;
+	  }
+
+	  public boolean consumesAlias() {
+		  return isOneToMany;
+	  }
+	
+	  public Serializable getCollectionSpace() {
+		  return getTableName();
+	  }
+
+	  public boolean isManyToMany() {
+		  return !isOneToMany && elementType instanceof AssociationType;
+	  }
+
+	  public CollectionMetadata getCollectionMetadata() {
+	  	return this;
+	  }
+}
Index: src/net/sf/hibernate/collection/CollectionPersisterImpl.java
===================================================================
RCS file: src/net/sf/hibernate/collection/CollectionPersisterImpl.java
diff -N src/net/sf/hibernate/collection/CollectionPersisterImpl.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/net/sf/hibernate/collection/CollectionPersisterImpl.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,29 @@
+/*
+ * Created on 07-10-2003
+ *
+ * To change the template for this generated file go to
+ * Window - Preferences - Java - Code Generation - Code and Comments
+ */
+package net.sf.hibernate.collection;
+
+import net.sf.hibernate.MappingException;
+import net.sf.hibernate.cache.CacheException;
+import net.sf.hibernate.cfg.Configuration;
+import net.sf.hibernate.engine.SessionFactoryImplementor;
+import net.sf.hibernate.mapping.Collection;
+
+/**
+ */
+public class CollectionPersisterImpl extends AbstractCollectionPersister {
+
+	/**
+	 * @param collection
+	 * @param datastore
+	 * @param factory
+	 * @throws MappingException
+	 * @throws CacheException
+	 */
+	public CollectionPersisterImpl(Collection collection, Configuration datastore, SessionFactoryImplementor factory) throws MappingException, CacheException {
+		super(collection, datastore, factory);
+	}
+}
