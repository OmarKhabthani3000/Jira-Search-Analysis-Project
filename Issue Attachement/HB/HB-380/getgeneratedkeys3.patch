Index: net/sf/hibernate/cfg/Environment.java
===================================================================
RCS file: /cvsroot/hibernate/Hibernate2/src/net/sf/hibernate/cfg/Environment.java,v
retrieving revision 1.18.2.15
diff -u -r1.18.2.15 Environment.java
--- net/sf/hibernate/cfg/Environment.java	30 Oct 2003 11:30:50 -0000	1.18.2.15
+++ net/sf/hibernate/cfg/Environment.java	4 Nov 2003 05:55:44 -0000
@@ -106,6 +106,11 @@
  *   this property when using user supplied connections)</td>
  * </tr>
  * <tr>
+ *   <td><tt>hibernate.jdbc.get_generated_keys</tt></td>
+ *   <td>enable use of JDBC3 ResultSet.getGeneratedKeys() to retrieve 
+ *   natively generated keys after insert. Requires JDBC3+ driver and JRE1.4+</td>
+ * </tr>
+ * <tr>
  *   <td><tt>hibernate.hbm2ddl.auto</tt></td>
  *   <td>enable auto DDL export</td>
  * </tr>
@@ -236,6 +241,12 @@
 	/**
 	 * Gives the JDBC driver a hint as to the number of rows that should be fetched from the database
 	 * when more rows are needed. If <tt>0</tt>, JDBC driver default settings will be used.
+	 */
+	public static final String USE_GET_GENERATED_KEYS = "hibernate.jdbc.use_get_generated_keys";
+	/**
+	 * Tells the JDBC driver to attempt to retrieve row Id with the JDBC 3.0 ResultSet.getGeneratedKeys()
+	 * method. In general, performance will be better if this property is set to true and the underlying 
+	 * JDBC driver supports getGeneratedKeys().
 	 */
 	public static final String STATEMENT_FETCH_SIZE = "hibernate.jdbc.fetch_size";
 	/**
Index: net/sf/hibernate/cfg/Settings.java
===================================================================
RCS file: /cvsroot/hibernate/Hibernate2/src/net/sf/hibernate/cfg/Attic/Settings.java,v
retrieving revision 1.1.2.9
diff -u -r1.1.2.9 Settings.java
--- net/sf/hibernate/cfg/Settings.java	10 Sep 2003 12:56:56 -0000	1.1.2.9
+++ net/sf/hibernate/cfg/Settings.java	4 Nov 2003 05:55:45 -0000
@@ -1,182 +1,191 @@
-//$Id: Settings.java,v 1.1.2.9 2003/09/10 12:56:56 oneovthafew Exp $
-package net.sf.hibernate.cfg;
-
-import java.util.Map;
-
-import net.sf.hibernate.cache.CacheProvider;
-import net.sf.hibernate.connection.ConnectionProvider;
-import net.sf.hibernate.dialect.Dialect;
-import net.sf.hibernate.transaction.TransactionFactory;
-import net.sf.hibernate.transaction.TransactionManagerLookup;
-
-/**
- * Settings that affect the behaviour of Hibernate at runtime.
- * 
- * @author Gavin King
- */
-public final class Settings {
-	
-	private boolean showSql;
-	private boolean outerJoinFetchEnabled;
-	private Integer maximumFetchDepth;
-	private Map querySubstitutions;
-	private Dialect dialect;
-	private int jdbcBatchSize;
-	private boolean scrollableResultSetsEnabled;
-	private String defaultSchemaName;
-	private Integer statementFetchSize;
-	private ConnectionProvider connectionProvider;
-	private TransactionFactory transactionFactory;
-	private TransactionManagerLookup transactionManagerLookup;
-	private String sessionFactoryName;
-	private boolean autoCreateSchema;
-	private boolean autoDropSchema;
-	private boolean autoUpdateSchema;
-	private CacheProvider cacheProvider;
-	private boolean queryCacheEnabled;
-
-	public String getDefaultSchemaName() {
-		return defaultSchemaName;
-	}
-
-	public Dialect getDialect() {
-		return dialect;
-	}
-
-	public int getJdbcBatchSize() {
-		return jdbcBatchSize;
-	}
-
-	public Map getQuerySubstitutions() {
-		return querySubstitutions;
-	}
-
-	public boolean isShowSqlEnabled() {
-		return showSql;
-	}
-
-	public boolean isOuterJoinFetchEnabled() {
-		return outerJoinFetchEnabled;
-	}
-
-	public boolean isScrollableResultSetsEnabled() {
-		return scrollableResultSetsEnabled;
-	}
-
-	void setDefaultSchemaName(String string) {
-		defaultSchemaName = string;
-	}
-
-	void setDialect(Dialect dialect) {
-		this.dialect = dialect;
-	}
-
-	void setJdbcBatchSize(int i) {
-		jdbcBatchSize = i;
-	}
-
-	void setQuerySubstitutions(Map map) {
-		querySubstitutions = map;
-	}
-
-	void setShowSqlEnabled(boolean b) {
-		showSql = b;
-	}
-
-	void setOuterJoinFetchEnabled(boolean b) {
-		outerJoinFetchEnabled = b;
-	}
-
-	void setScrollableResultSetsEnabled(boolean b) {
-		scrollableResultSetsEnabled = b;
-	}
-
-	public Integer getStatementFetchSize() {
-		return statementFetchSize;
-	}
-
-	void setStatementFetchSize(Integer integer) {
-		statementFetchSize = integer;
-	}
-
-	public ConnectionProvider getConnectionProvider() {
-		return connectionProvider;
-	}
-
-	void setConnectionProvider(ConnectionProvider provider) {
-		connectionProvider = provider;
-	}
-
-	public TransactionFactory getTransactionFactory() {
-		return transactionFactory;
-	}
-
-	void setTransactionFactory(TransactionFactory factory) {
-		transactionFactory = factory;
-	}
-
-	public String getSessionFactoryName() {
-		return sessionFactoryName;
-	}
-
-	void setSessionFactoryName(String string) {
-		sessionFactoryName = string;
-	}
-
-	public boolean isAutoCreateSchema() {
-		return autoCreateSchema;
-	}
-
-	public boolean isAutoDropSchema() {
-		return autoDropSchema;
-	}
-
-	public boolean isAutoUpdateSchema() {
-		return autoUpdateSchema;
-	}
-
-	void setAutoCreateSchema(boolean b) {
-		autoCreateSchema = b;
-	}
-
-	void setAutoDropSchema(boolean b) {
-		autoDropSchema = b;
-	}
-
-	void setAutoUpdateSchema(boolean b) {
-		autoUpdateSchema = b;
-	}
-
-	public Integer getMaximumFetchDepth() {
-		return maximumFetchDepth;
-	}
-
-	void setMaximumFetchDepth(Integer i) {
-		maximumFetchDepth = i;
-	}
-
-	public CacheProvider getCacheProvider() {
-		return cacheProvider;
-	}
-
-	void setCacheProvider(CacheProvider cacheProvider) {
-		this.cacheProvider = cacheProvider;
-	}
-
-	public TransactionManagerLookup getTransactionManagerLookup() {
-		return transactionManagerLookup;
-	}
-
-	void setTransactionManagerLookup(TransactionManagerLookup lookup) {
-		transactionManagerLookup = lookup;
-	}
-
-	public boolean isQueryCacheEnabled() {
-		return queryCacheEnabled;
-	}
-
-	void setQueryCacheEnabled(boolean b) {
-		queryCacheEnabled = b;
-	}
-
-}
+//$Id: Settings.java,v 1.1.2.9 2003/09/10 12:56:56 oneovthafew Exp $
+package net.sf.hibernate.cfg;
+
+import java.util.Map;
+
+import net.sf.hibernate.cache.CacheProvider;
+import net.sf.hibernate.connection.ConnectionProvider;
+import net.sf.hibernate.dialect.Dialect;
+import net.sf.hibernate.transaction.TransactionFactory;
+import net.sf.hibernate.transaction.TransactionManagerLookup;
+
+/**
+ * Settings that affect the behaviour of Hibernate at runtime.
+ * 
+ * @author Gavin King
+ */
+public final class Settings {
+	
+	private boolean showSql;
+	private boolean outerJoinFetchEnabled;
+	private Integer maximumFetchDepth;
+	private Map querySubstitutions;
+	private Dialect dialect;
+	private int jdbcBatchSize;
+	private boolean scrollableResultSetsEnabled;
+	private boolean getGeneratedKeysEnabled;
+	private String defaultSchemaName;
+	private Integer statementFetchSize;
+	private ConnectionProvider connectionProvider;
+	private TransactionFactory transactionFactory;
+	private TransactionManagerLookup transactionManagerLookup;
+	private String sessionFactoryName;
+	private boolean autoCreateSchema;
+	private boolean autoDropSchema;
+	private boolean autoUpdateSchema;
+	private CacheProvider cacheProvider;
+	private boolean queryCacheEnabled;
+
+	public String getDefaultSchemaName() {
+		return defaultSchemaName;
+	}
+
+	public Dialect getDialect() {
+		return dialect;
+	}
+
+	public int getJdbcBatchSize() {
+		return jdbcBatchSize;
+	}
+
+	public Map getQuerySubstitutions() {
+		return querySubstitutions;
+	}
+
+	public boolean isShowSqlEnabled() {
+		return showSql;
+	}
+
+	public boolean isOuterJoinFetchEnabled() {
+		return outerJoinFetchEnabled;
+	}
+
+	public boolean isScrollableResultSetsEnabled() {
+		return scrollableResultSetsEnabled;
+	}
+
+	public boolean isGetGeneratedKeysEnabled() {
+		return getGeneratedKeysEnabled;
+	}
+
+	void setDefaultSchemaName(String string) {
+		defaultSchemaName = string;
+	}
+
+	void setDialect(Dialect dialect) {
+		this.dialect = dialect;
+	}
+
+	void setJdbcBatchSize(int i) {
+		jdbcBatchSize = i;
+	}
+
+	void setQuerySubstitutions(Map map) {
+		querySubstitutions = map;
+	}
+
+	void setShowSqlEnabled(boolean b) {
+		showSql = b;
+	}
+
+	void setOuterJoinFetchEnabled(boolean b) {
+		outerJoinFetchEnabled = b;
+	}
+
+	void setScrollableResultSetsEnabled(boolean b) {
+		scrollableResultSetsEnabled = b;
+	}
+
+	void setGetGeneratedKeysEnabled(boolean b) {
+		getGeneratedKeysEnabled = b;
+	}
+
+	public Integer getStatementFetchSize() {
+		return statementFetchSize;
+	}
+
+	void setStatementFetchSize(Integer integer) {
+		statementFetchSize = integer;
+	}
+
+	public ConnectionProvider getConnectionProvider() {
+		return connectionProvider;
+	}
+
+	void setConnectionProvider(ConnectionProvider provider) {
+		connectionProvider = provider;
+	}
+
+	public TransactionFactory getTransactionFactory() {
+		return transactionFactory;
+	}
+
+	void setTransactionFactory(TransactionFactory factory) {
+		transactionFactory = factory;
+	}
+
+	public String getSessionFactoryName() {
+		return sessionFactoryName;
+	}
+
+	void setSessionFactoryName(String string) {
+		sessionFactoryName = string;
+	}
+
+	public boolean isAutoCreateSchema() {
+		return autoCreateSchema;
+	}
+
+	public boolean isAutoDropSchema() {
+		return autoDropSchema;
+	}
+
+	public boolean isAutoUpdateSchema() {
+		return autoUpdateSchema;
+	}
+
+	void setAutoCreateSchema(boolean b) {
+		autoCreateSchema = b;
+	}
+
+	void setAutoDropSchema(boolean b) {
+		autoDropSchema = b;
+	}
+
+	void setAutoUpdateSchema(boolean b) {
+		autoUpdateSchema = b;
+	}
+
+	public Integer getMaximumFetchDepth() {
+		return maximumFetchDepth;
+	}
+
+	void setMaximumFetchDepth(Integer i) {
+		maximumFetchDepth = i;
+	}
+
+	public CacheProvider getCacheProvider() {
+		return cacheProvider;
+	}
+
+	void setCacheProvider(CacheProvider cacheProvider) {
+		this.cacheProvider = cacheProvider;
+	}
+
+	public TransactionManagerLookup getTransactionManagerLookup() {
+		return transactionManagerLookup;
+	}
+
+	void setTransactionManagerLookup(TransactionManagerLookup lookup) {
+		transactionManagerLookup = lookup;
+	}
+
+	public boolean isQueryCacheEnabled() {
+		return queryCacheEnabled;
+	}
+
+	void setQueryCacheEnabled(boolean b) {
+		queryCacheEnabled = b;
+	}
+
+}
Index: net/sf/hibernate/cfg/SettingsFactory.java
===================================================================
RCS file: /cvsroot/hibernate/Hibernate2/src/net/sf/hibernate/cfg/Attic/SettingsFactory.java,v
retrieving revision 1.1.2.12
diff -u -r1.1.2.12 SettingsFactory.java
--- net/sf/hibernate/cfg/SettingsFactory.java	10 Sep 2003 12:56:56 -0000	1.1.2.12
+++ net/sf/hibernate/cfg/SettingsFactory.java	4 Nov 2003 05:55:45 -0000
@@ -1,143 +1,164 @@
-//$Id: SettingsFactory.java,v 1.1.2.12 2003/09/10 12:56:56 oneovthafew Exp $
-package net.sf.hibernate.cfg;
-
-import java.sql.Connection;
-import java.sql.DatabaseMetaData;
-import java.sql.ResultSet;
-import java.sql.SQLException;
-import java.util.Map;
-import java.util.Properties;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-
-import net.sf.hibernate.HibernateException;
-import net.sf.hibernate.cache.CacheProvider;
-import net.sf.hibernate.connection.ConnectionProvider;
-import net.sf.hibernate.connection.ConnectionProviderFactory;
-import net.sf.hibernate.dialect.Dialect;
-import net.sf.hibernate.dialect.GenericDialect;
-import net.sf.hibernate.transaction.TransactionFactory;
-import net.sf.hibernate.transaction.TransactionFactoryFactory;
-import net.sf.hibernate.transaction.TransactionManagerLookup;
-import net.sf.hibernate.transaction.TransactionManagerLookupFactory;
-import net.sf.hibernate.util.PropertiesHelper;
-import net.sf.hibernate.util.ReflectHelper;
-
-/**
- * Reads configuration properties and configures a <tt>Settings</tt> instance.
- * 
- * @author Gavin King
- */
-public final class SettingsFactory {
-	
-	private static final Log log = LogFactory.getLog(SettingsFactory.class);
-	
-	public static Settings buildSettings(Properties properties) throws HibernateException {
-		
-		Settings settings = new Settings();
-		
-		Dialect dialect;
-		try {
-			dialect = Dialect.getDialect(properties);
-			Properties temp = new Properties();
-			//temp.putAll( Environment.getProperties() );
-			temp.putAll( dialect.getDefaultProperties() );
-			temp.putAll(properties);
-			properties = temp; // add the dialects default properties
-		}
-		catch (HibernateException he) {
-			log.warn( "No dialect set - using GenericDialect: " + he.getMessage() );
-			dialect = new GenericDialect();
-		}
-		
-		Integer statementFetchSize = PropertiesHelper.getInteger(Environment.STATEMENT_FETCH_SIZE, properties);
-		if (statementFetchSize!=null) log.info("JDBC result set fetch size: " + statementFetchSize);
-		
-		Integer maxFetchDepth = PropertiesHelper.getInteger(Environment.MAX_FETCH_DEPTH, properties);
-		if (maxFetchDepth!=null) log.info("Maximim outer join fetch depth: " + maxFetchDepth);
-		
-		//deprecated:
-		boolean useOuterJoin = PropertiesHelper.getBoolean(Environment.USE_OUTER_JOIN, properties);
-		log.info("Use outer join fetching: " + useOuterJoin);
-		
-		ConnectionProvider connections = ConnectionProviderFactory.newConnectionProvider(properties);
-		TransactionFactory transactionFactory = TransactionFactoryFactory.buildTransactionFactory(properties);
-		TransactionManagerLookup transactionManagerLookup = TransactionManagerLookupFactory.getTransactionManagerLookup(properties);
-		
-		boolean metaSupportsScrollable = false;
-		int batchSize = PropertiesHelper.getInt(Environment.STATEMENT_BATCH_SIZE, properties, 0);
-		try {
-			Connection conn = connections.getConnection();
-			try {
-				DatabaseMetaData meta = conn.getMetaData();
-				metaSupportsScrollable = meta.supportsResultSetType(ResultSet.TYPE_SCROLL_INSENSITIVE);
-				if ( ( batchSize > 0 ) && !meta.supportsBatchUpdates() ) batchSize = 0;
-			}
-			finally {
-				connections.closeConnection(conn);
-			}
-		}
-		catch (SQLException sqle) {
-			log.warn("Could not obtain connection metadata", sqle);
-		}
-		catch (UnsupportedOperationException uoe) {
-			// user supplied JDBC connections
-		}
-		
-		boolean useScrollableResultSets = PropertiesHelper.getBoolean(Environment.USE_SCROLLABLE_RESULTSET, properties, metaSupportsScrollable);
-		log.info("Use scrollable result sets: " + useScrollableResultSets);
-		if (batchSize>0) log.info("JDBC 2 max batch size: " + batchSize);
-		
-		String defaultSchema = properties.getProperty(Environment.DEFAULT_SCHEMA);
-		if (defaultSchema!=null) log.info("Default schema set to: " + defaultSchema);
-		
-		boolean showSql = PropertiesHelper.getBoolean(Environment.SHOW_SQL, properties);
-		if (showSql) log.info("echoing all SQL to stdout");
-		
-		Map querySubstitutions = PropertiesHelper.toMap(Environment.QUERY_SUBSTITUTIONS, " ,=;:\n\t\r\f", properties);
-		log.info("Query language substitutions: " + querySubstitutions);
-		
-		String autoSchemaExport = properties.getProperty(Environment.HBM2DDL_AUTO);
-		if ( "update".equals(autoSchemaExport) ) settings.setAutoUpdateSchema(true);
-		if ( "create".equals(autoSchemaExport) ) settings.setAutoCreateSchema(true);
-		if ( "create-drop".equals(autoSchemaExport) ) {
-			settings.setAutoCreateSchema(true);
-			settings.setAutoDropSchema(true);
-		}
-		
-		String cacheClassName = PropertiesHelper.getString(Environment.CACHE_PROVIDER, properties, "net.sf.hibernate.cache.JCSCacheProvider");
-		log.info("cache provider: " + cacheClassName);
-		try {
-			settings.setCacheProvider( (CacheProvider) ReflectHelper.classForName(cacheClassName).newInstance() );
-		}
-		catch (Exception cnfe) {
-			throw new HibernateException("could not instantiate CacheProvider: " + cacheClassName, cnfe);
-		}
-		
-		boolean useQueryCache = PropertiesHelper.getBoolean(Environment.USE_QUERY_CACHE, properties);
-		
-		String sessionFactoryName = properties.getProperty(Environment.SESSION_FACTORY_NAME);
-		
-		settings.setStatementFetchSize(statementFetchSize);
-		settings.setScrollableResultSetsEnabled(useScrollableResultSets);
-		settings.setJdbcBatchSize(batchSize);
-		settings.setDefaultSchemaName(defaultSchema);
-		settings.setShowSqlEnabled(showSql);
-		settings.setDialect(dialect);
-		settings.setConnectionProvider(connections);
-		settings.setQuerySubstitutions(querySubstitutions);
-		settings.setTransactionFactory(transactionFactory);
-		settings.setTransactionManagerLookup(transactionManagerLookup);
-		settings.setSessionFactoryName(sessionFactoryName);
-		settings.setOuterJoinFetchEnabled(useOuterJoin);
-		settings.setMaximumFetchDepth(maxFetchDepth);
-		settings.setQueryCacheEnabled(useQueryCache);
-		
-		return settings;
-
-	}
-	
-	private SettingsFactory() {}
-	
-}
+//$Id: SettingsFactory.java,v 1.1.2.12 2003/09/10 12:56:56 oneovthafew Exp $
+package net.sf.hibernate.cfg;
+
+import java.sql.Connection;
+import java.sql.DatabaseMetaData;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.util.Map;
+import java.util.Properties;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import net.sf.hibernate.HibernateException;
+import net.sf.hibernate.cache.CacheProvider;
+import net.sf.hibernate.connection.ConnectionProvider;
+import net.sf.hibernate.connection.ConnectionProviderFactory;
+import net.sf.hibernate.dialect.Dialect;
+import net.sf.hibernate.dialect.GenericDialect;
+import net.sf.hibernate.transaction.TransactionFactory;
+import net.sf.hibernate.transaction.TransactionFactoryFactory;
+import net.sf.hibernate.transaction.TransactionManagerLookup;
+import net.sf.hibernate.transaction.TransactionManagerLookupFactory;
+import net.sf.hibernate.util.PropertiesHelper;
+import net.sf.hibernate.util.ReflectHelper;
+
+/**
+ * Reads configuration properties and configures a <tt>Settings</tt> instance.
+ * 
+ * @author Gavin King
+ */
+public final class SettingsFactory {
+	
+	private static final Log log = LogFactory.getLog(SettingsFactory.class);
+	
+	public static Settings buildSettings(Properties properties) throws HibernateException {
+		
+		Settings settings = new Settings();
+		
+		Dialect dialect;
+		try {
+			dialect = Dialect.getDialect(properties);
+			Properties temp = new Properties();
+			//temp.putAll( Environment.getProperties() );
+			temp.putAll( dialect.getDefaultProperties() );
+			temp.putAll(properties);
+			properties = temp; // add the dialects default properties
+		}
+		catch (HibernateException he) {
+			log.warn( "No dialect set - using GenericDialect: " + he.getMessage() );
+			dialect = new GenericDialect();
+		}
+		
+		Integer statementFetchSize = PropertiesHelper.getInteger(Environment.STATEMENT_FETCH_SIZE, properties);
+		if (statementFetchSize!=null) log.info("JDBC result set fetch size: " + statementFetchSize);
+		
+		Integer maxFetchDepth = PropertiesHelper.getInteger(Environment.MAX_FETCH_DEPTH, properties);
+		if (maxFetchDepth!=null) log.info("Maximim outer join fetch depth: " + maxFetchDepth);
+		
+		//deprecated:
+		boolean useOuterJoin = PropertiesHelper.getBoolean(Environment.USE_OUTER_JOIN, properties);
+		log.info("Use outer join fetching: " + useOuterJoin);
+		
+		ConnectionProvider connections = ConnectionProviderFactory.newConnectionProvider(properties);
+		TransactionFactory transactionFactory = TransactionFactoryFactory.buildTransactionFactory(properties);
+		TransactionManagerLookup transactionManagerLookup = TransactionManagerLookupFactory.getTransactionManagerLookup(properties);
+		
+		boolean metaSupportsScrollable = false;
+		int batchSize = PropertiesHelper.getInt(Environment.STATEMENT_BATCH_SIZE, properties, 0);
+		try {
+			Connection conn = connections.getConnection();
+			try {
+				DatabaseMetaData meta = conn.getMetaData();
+				metaSupportsScrollable = meta.supportsResultSetType(ResultSet.TYPE_SCROLL_INSENSITIVE);
+				if ( ( batchSize > 0 ) && !meta.supportsBatchUpdates() ) batchSize = 0;
+			}
+			finally {
+				connections.closeConnection(conn);
+			}
+		}
+		catch (SQLException sqle) {
+			log.warn("Could not obtain connection metadata", sqle);
+		}
+		catch (UnsupportedOperationException uoe) {
+			// user supplied JDBC connections
+		}
+		
+		boolean useScrollableResultSets = PropertiesHelper.getBoolean(Environment.USE_SCROLLABLE_RESULTSET, properties, metaSupportsScrollable);
+		log.info("Use scrollable result sets: " + useScrollableResultSets);
+		if (batchSize>0) log.info("JDBC 2 max batch size: " + batchSize);
+
+		boolean metaSupportsGetGeneratedKeys = false;
+		try {
+			Connection conn = connections.getConnection();
+			try {
+				DatabaseMetaData meta = conn.getMetaData();
+				metaSupportsGetGeneratedKeys = meta.supportsGetGeneratedKeys();
+			}
+			finally {
+				connections.closeConnection(conn);
+			}
+		}
+		catch (SQLException sqle) {
+			log.warn("Could not obtain connection metadata", sqle);
+		}
+		catch (UnsupportedOperationException uoe) {
+			// user supplied JDBC connections
+		}
+		boolean useGetGeneratedKeys = PropertiesHelper.getBoolean(Environment.USE_GET_GENERATED_KEYS, properties, metaSupportsGetGeneratedKeys);
+		log.info("Use result set get generated keys: " + useGetGeneratedKeys);
+				
+		String defaultSchema = properties.getProperty(Environment.DEFAULT_SCHEMA);
+		if (defaultSchema!=null) log.info("Default schema set to: " + defaultSchema);
+		
+		boolean showSql = PropertiesHelper.getBoolean(Environment.SHOW_SQL, properties);
+		if (showSql) log.info("echoing all SQL to stdout");
+		
+		Map querySubstitutions = PropertiesHelper.toMap(Environment.QUERY_SUBSTITUTIONS, " ,=;:\n\t\r\f", properties);
+		log.info("Query language substitutions: " + querySubstitutions);
+		
+		String autoSchemaExport = properties.getProperty(Environment.HBM2DDL_AUTO);
+		if ( "update".equals(autoSchemaExport) ) settings.setAutoUpdateSchema(true);
+		if ( "create".equals(autoSchemaExport) ) settings.setAutoCreateSchema(true);
+		if ( "create-drop".equals(autoSchemaExport) ) {
+			settings.setAutoCreateSchema(true);
+			settings.setAutoDropSchema(true);
+		}
+		
+		String cacheClassName = PropertiesHelper.getString(Environment.CACHE_PROVIDER, properties, "net.sf.hibernate.cache.JCSCacheProvider");
+		log.info("cache provider: " + cacheClassName);
+		try {
+			settings.setCacheProvider( (CacheProvider) ReflectHelper.classForName(cacheClassName).newInstance() );
+		}
+		catch (Exception cnfe) {
+			throw new HibernateException("could not instantiate CacheProvider: " + cacheClassName, cnfe);
+		}
+		
+		boolean useQueryCache = PropertiesHelper.getBoolean(Environment.USE_QUERY_CACHE, properties);
+		
+		String sessionFactoryName = properties.getProperty(Environment.SESSION_FACTORY_NAME);
+		
+		settings.setStatementFetchSize(statementFetchSize);
+		settings.setScrollableResultSetsEnabled(useScrollableResultSets);
+		settings.setGetGeneratedKeysEnabled(useGetGeneratedKeys);
+		settings.setJdbcBatchSize(batchSize);
+		settings.setDefaultSchemaName(defaultSchema);
+		settings.setShowSqlEnabled(showSql);
+		settings.setDialect(dialect);
+		settings.setConnectionProvider(connections);
+		settings.setQuerySubstitutions(querySubstitutions);
+		settings.setTransactionFactory(transactionFactory);
+		settings.setTransactionManagerLookup(transactionManagerLookup);
+		settings.setSessionFactoryName(sessionFactoryName);
+		settings.setOuterJoinFetchEnabled(useOuterJoin);
+		settings.setMaximumFetchDepth(maxFetchDepth);
+		settings.setQueryCacheEnabled(useQueryCache);
+		
+		return settings;
+
+	}
+	
+	private SettingsFactory() {}
+	
+}
Index: net/sf/hibernate/engine/Batcher.java
===================================================================
RCS file: /cvsroot/hibernate/Hibernate2/src/net/sf/hibernate/engine/Batcher.java,v
retrieving revision 1.5.2.7
diff -u -r1.5.2.7 Batcher.java
--- net/sf/hibernate/engine/Batcher.java	31 Oct 2003 05:39:35 -0000	1.5.2.7
+++ net/sf/hibernate/engine/Batcher.java	4 Nov 2003 05:55:38 -0000
@@ -34,7 +34,7 @@
 	 * Get a non-batchable prepared statement to use for inserting / deleting / updating.
 	 * Must be explicitly released by <tt>closeStatement()</tt>
 	 */
-	public PreparedStatement prepareStatement(String sql) throws SQLException, HibernateException;
+	public PreparedStatement prepareStatement(String sql, boolean useGetGeneratedKeys) throws SQLException, HibernateException;
 	/**
 	 * Close a prepared statement opened using <tt>prepareStatement()</tt>
 	 */
Index: net/sf/hibernate/engine/SessionFactoryImplementor.java
===================================================================
RCS file: /cvsroot/hibernate/Hibernate2/src/net/sf/hibernate/engine/SessionFactoryImplementor.java,v
retrieving revision 1.11.2.11
diff -u -r1.11.2.11 SessionFactoryImplementor.java
--- net/sf/hibernate/engine/SessionFactoryImplementor.java	2 Nov 2003 08:56:48 -0000	1.11.2.11
+++ net/sf/hibernate/engine/SessionFactoryImplementor.java	4 Nov 2003 05:55:39 -0000
@@ -46,6 +46,10 @@
 	 */
 	public boolean isScrollableResultSetsEnabled();
 	/**
+	 * Is <tt>ResultSet</tt> get generated keys supported?
+	 */
+	public boolean isGetGeneratedKeysEnabled();
+	/**
 	 * Get the database schema specified in <tt>hibernate.default_schema</tt>
 	 */
 	public String getDefaultSchema();
Index: net/sf/hibernate/id/SequenceGenerator.java
===================================================================
RCS file: /cvsroot/hibernate/Hibernate2/src/net/sf/hibernate/id/SequenceGenerator.java,v
retrieving revision 1.8.2.4
diff -u -r1.8.2.4 SequenceGenerator.java
--- net/sf/hibernate/id/SequenceGenerator.java	30 Oct 2003 13:23:57 -0000	1.8.2.4
+++ net/sf/hibernate/id/SequenceGenerator.java	4 Nov 2003 05:55:46 -0000
@@ -64,7 +64,7 @@
 	
 	public Serializable generate(SessionImplementor session, Object obj) throws SQLException, HibernateException {
 		
-		PreparedStatement st = session.getBatcher().prepareStatement(sql);
+		PreparedStatement st = session.getBatcher().prepareStatement(sql, false);
 		try {
 			ResultSet rs = st.executeQuery();
 			final Serializable result;
Index: net/sf/hibernate/impl/BatcherImpl.java
===================================================================
RCS file: /cvsroot/hibernate/Hibernate2/src/net/sf/hibernate/impl/BatcherImpl.java,v
retrieving revision 1.9.2.12
diff -u -r1.9.2.12 BatcherImpl.java
--- net/sf/hibernate/impl/BatcherImpl.java	2 Nov 2003 02:32:37 -0000	1.9.2.12
+++ net/sf/hibernate/impl/BatcherImpl.java	4 Nov 2003 05:55:36 -0000
@@ -52,9 +52,12 @@
 	}
 	
 	public PreparedStatement prepareStatement(String sql) throws SQLException, HibernateException {
+		return prepareStatement(sql, false);
+	}
+	public PreparedStatement prepareStatement(String sql, boolean getGeneratedKeys) throws SQLException, HibernateException {
 		executeBatch();
 		logOpenPreparedStatement();
-		return getPreparedStatement( session.connection(), sql, false );
+		return getPreparedStatement( session.connection(), sql, false, getGeneratedKeys );
 	}
 	public PreparedStatement prepareQueryStatement(String sql, boolean scrollable) throws SQLException, HibernateException {
 		logOpenPreparedStatement();
@@ -217,11 +220,19 @@
 	}
 
 	private PreparedStatement getPreparedStatement(final Connection conn, final String sql, boolean scrollable) throws SQLException {
+		return getPreparedStatement(conn, sql, scrollable, false);
+	}
+	
+	private PreparedStatement getPreparedStatement(final Connection conn, final String sql, boolean scrollable, boolean useGetGeneratedKeys) throws SQLException {
 		
 		if ( scrollable && !factory.isScrollableResultSetsEnabled() ) {
 			throw new AssertionFailure("Hibernate tried to grab a scrollable result set");
 		}
 		
+		if ( useGetGeneratedKeys && !factory.isGetGeneratedKeysEnabled() ) {
+			throw new AssertionFailure("Hibernate tried to prepare a statement assuming unsupported getGeneratedKeys");
+		}
+		
 		// note: if we're not using JDBC2, don't return a scrollable PS
 		// clients *must* be prepared to handle this case!
 		
@@ -229,23 +240,49 @@
 			(scrollable ? "scrollable " : StringHelper.EMPTY_STRING ) + "prepared statement get: " + sql
 		);
 		if ( factory.isShowSqlEnabled() ) System.out.println("Hibernate: " + sql);
+
+		// Setup up call to PreparedStatement.getGeneratedKeys(String, int)
+		java.lang.reflect.Method prepareStatementMethod = null;
+		Object[] args = null ;
+		if ( !scrollable && useGetGeneratedKeys ) {		
+			try {
+	        	java.lang.reflect.Field return_generated_keys = java.sql.Statement.class.getDeclaredField("RETURN_GENERATED_KEYS");
+				int RETURN_GENERATED_KEYS = return_generated_keys.getInt(PreparedStatement.class);
+				
+				Class[] types = new Class[] {String.class, Integer.TYPE};
+				args = new Object[] {sql, new Integer(RETURN_GENERATED_KEYS)};
+			
+				prepareStatementMethod = conn.getClass().getMethod("prepareStatement", types);
+			} 
+			catch (Exception nsme) {
+				log.error("JDBC 3.0 driver required for prepareStatement(String, int) support", nsme);
+				throw new SQLException("Class " + conn.getClass().getName() 
+				+ " is not a JDBC 3.0 Driver that supports prepareStatement(String, int)");
+			}
+		}	
 		
 		try {
 			log.trace("preparing statement");
 			return scrollable ?
 				conn.prepareStatement(sql, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY) :
-				conn.prepareStatement(sql);
+				useGetGeneratedKeys ?
+					(PreparedStatement) prepareStatementMethod.invoke(conn, args) :
+					conn.prepareStatement(sql);
 		}
 		catch (SQLException sqle) {
 			JDBCExceptionReporter.logExceptions(sqle);
 			throw sqle;
 		}
+		catch (Exception e) {
+			log.error("Error invoking " + conn.getClass().getName() + ".prepareStatement(String, int).", e);
+			throw new SQLException("Error invoking " + conn.getClass().getName() + ".prepareStatement(String, int).");
+		}
 	}
 	
 	private void closePreparedStatement(PreparedStatement ps) throws SQLException {
 		try {
 			log.trace("closing statement");
-			if (ps!=null) ps.close(); //null check not absolutely necessary!
+			ps.close();
 		}
 		catch (SQLException sqle) {
 			JDBCExceptionReporter.logExceptions(sqle);
Index: net/sf/hibernate/impl/SessionFactoryImpl.java
===================================================================
RCS file: /cvsroot/hibernate/Hibernate2/src/net/sf/hibernate/impl/SessionFactoryImpl.java,v
retrieving revision 1.26.2.28
diff -u -r1.26.2.28 SessionFactoryImpl.java
--- net/sf/hibernate/impl/SessionFactoryImpl.java	2 Nov 2003 08:56:48 -0000	1.26.2.28
+++ net/sf/hibernate/impl/SessionFactoryImpl.java	4 Nov 2003 05:55:37 -0000
@@ -417,6 +417,10 @@
 		return settings.isScrollableResultSetsEnabled();
 	}
 	
+	public boolean isGetGeneratedKeysEnabled() {
+		return settings.isGetGeneratedKeysEnabled();
+	}
+
 	public boolean isOuterJoinedFetchEnabled() {
 		return settings.isOuterJoinFetchEnabled();
 	}
Index: net/sf/hibernate/persister/AbstractEntityPersister.java
===================================================================
RCS file: /cvsroot/hibernate/Hibernate2/src/net/sf/hibernate/persister/AbstractEntityPersister.java,v
retrieving revision 1.33.2.42
diff -u -r1.33.2.42 AbstractEntityPersister.java
--- net/sf/hibernate/persister/AbstractEntityPersister.java	3 Nov 2003 10:42:11 -0000	1.33.2.42
+++ net/sf/hibernate/persister/AbstractEntityPersister.java	4 Nov 2003 05:55:43 -0000
@@ -35,6 +35,8 @@
 import net.sf.hibernate.engine.Versioning;
 import net.sf.hibernate.id.IdentifierGenerator;
 import net.sf.hibernate.id.IdentityGenerator;
+import net.sf.hibernate.id.IdentifierGeneratorFactory;
+import net.sf.hibernate.id.IdentifierGenerationException;
 import net.sf.hibernate.impl.MessageHelper;
 import net.sf.hibernate.loader.BatchingEntityLoader;
 import net.sf.hibernate.loader.EntityLoader;
@@ -199,6 +201,16 @@
 			}  
 		}
 		catch (Throwable t) {
+			Class[] types = optimizer.getPropertyTypes();
+			String[] setters = optimizer.getSetters();
+			for (int i = 0; i < values.length; i++) {
+				if ((values[i] == null) && types[i].isPrimitive()) {
+					log.warn( "Setter " + setters[i] + " expects primitive " + types[i].getName() + " but value is null.");
+				}
+				if ((values[i] != null) && ! values[i].getClass().equals(types[i])) {
+					log.warn( "Value type is " + values[i].getClass().getName() + " but setter expects " + types[i].getName() + ".");
+				}
+			}			
 			throw new PropertyAccessException(t, "exception setting property value with CGLIB (set hibernate.cglib.use_reflection_optimizer=false for more info)", true, mappedClass, "?");
 		}
 		
@@ -1054,7 +1066,7 @@
 		
 		try {
 			
-			PreparedStatement st = session.getBatcher().prepareStatement( getVersionSelectString() );
+			PreparedStatement st = session.getBatcher().prepareStatement( getVersionSelectString(), false );
 			try {
 				getIdentifierType().nullSafeSet(st, id, 1, session);
 				
@@ -1119,6 +1131,35 @@
 		}
 		
 		return values;
+	}
+
+	/**
+	 * Method getNativeId returns the native identier from a result.
+	 * @param object
+	 * @param session
+	 * @param rs
+	 * @return Serializable
+	 * @throws SQLException
+	 * @throws HibernateException
+	 * @throws IdentifierGenerationException
+	 */
+	protected Serializable getNativeId(
+		Object object,
+		SessionImplementor session,
+		ResultSet rs)
+		throws SQLException, HibernateException, IdentifierGenerationException {
+		final Serializable id;
+		try {
+			if ( !rs.next() ) throw new HibernateException("The database returned no natively generated identity value");
+				id = IdentifierGeneratorFactory.get( 
+				rs, getIdentifierType(), session, object 
+			);
+		}
+		finally {
+			rs.close();
+		}
+		log.debug("Natively generated identity: " + id);
+		return id;
 	}
 	
 	protected abstract String getConcreteSelectString();
Index: net/sf/hibernate/persister/EntityPersister.java
===================================================================
RCS file: /cvsroot/hibernate/Hibernate2/src/net/sf/hibernate/persister/EntityPersister.java,v
retrieving revision 1.38.2.25
diff -u -r1.38.2.25 EntityPersister.java
--- net/sf/hibernate/persister/EntityPersister.java	2 Nov 2003 04:53:08 -0000	1.38.2.25
+++ net/sf/hibernate/persister/EntityPersister.java	4 Nov 2003 05:55:41 -0000
@@ -22,6 +22,7 @@
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Map;
+import java.lang.reflect.Method;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
@@ -31,7 +32,6 @@
 import net.sf.hibernate.LockMode;
 import net.sf.hibernate.MappingException;
 import net.sf.hibernate.StaleObjectStateException;
-import net.sf.hibernate.id.IdentifierGeneratorFactory;
 import net.sf.hibernate.impl.MessageHelper;
 import net.sf.hibernate.sql.Delete;
 import net.sf.hibernate.sql.InFragment;
@@ -447,7 +447,7 @@
 			
 			try {
 				
-				PreparedStatement st = session.getBatcher().prepareStatement( (String) lockers.get(lockMode) );
+				PreparedStatement st = session.getBatcher().prepareStatement( (String) lockers.get(lockMode), false );
 				try {
 					getIdentifierType().nullSafeSet(st, id, 1, session);
 					if ( isVersioned() ) {
@@ -544,15 +544,34 @@
 			log.trace("Inserting entity: " + getClassName() + " (native id)");
 			if ( isVersioned() ) log.trace( "Version: " + Versioning.getVersion(fields, this) );
 		}
+
+		boolean useGetGeneratedKeys = session.getFactory().isGetGeneratedKeysEnabled();
+		Serializable id = null;
 		
 		try {
 		
 			// Render the SQL query
-			PreparedStatement statement = session.getBatcher().prepareStatement(sql);
+			PreparedStatement statement = session.getBatcher().prepareStatement(sql, useGetGeneratedKeys);
 			
 			try {
 				dehydrate(null, fields, notNull, statement, session);
 				statement.executeUpdate();
+
+				if (useGetGeneratedKeys) {
+					try {
+						Method getGeneratedKeysMethod;
+						ResultSet rs = null;
+						getGeneratedKeysMethod = statement.getClass().getMethod("getGeneratedKeys",  new Class[0]);
+						rs = (ResultSet) getGeneratedKeysMethod.invoke(statement, new Object[0]);
+       					return getNativeId(object, session, rs);
+					} 
+					catch (Exception e) {
+						log.error(session.getBatcher().getClass().getName() 
+						+ " error invoking JDBC 3.0 PreparedStatement.getGeneratedKeys()", e);
+						throw new HibernateException("Class " + session.getBatcher().getClass().getName() 
+						+ " does not support JDBC 3.0 PreparedStatement.getGeneratedKeys()", e);
+					}
+				}	
 			}
 			catch (SQLException sqle) {
 				JDBCExceptionReporter.logExceptions(sqle);
@@ -563,24 +582,13 @@
 			}
 			
 			// fetch the generated id:
-			PreparedStatement idselect = session.getBatcher().prepareStatement( sqlIdentitySelect() );
+			PreparedStatement idselect = session.getBatcher().prepareStatement( sqlIdentitySelect(), false );
 			
 			try {
 				
 				ResultSet rs = idselect.executeQuery();
-				final Serializable id;
-				try {
-					if ( !rs.next() ) throw new HibernateException("The database returned no natively generated identity value");
-					id = IdentifierGeneratorFactory.get( 
-						rs, getIdentifierType(), session, object 
-					);
-				}
-				finally {
-					rs.close();
-				}
-				log.debug("Natively generated identity: " + id);
-				
-				return id;
+
+				return getNativeId(object, session, rs);
 			}
 			catch(SQLException sqle) {
 				JDBCExceptionReporter.logExceptions(sqle);
@@ -612,7 +620,7 @@
 			//Render the SQL query
 			final PreparedStatement statement;// = session.getPreparedStatement( sqlDelete() );
 			if ( isVersioned() ) {
-				statement = session.getBatcher().prepareStatement( getSQLDeleteString() );
+				statement = session.getBatcher().prepareStatement( getSQLDeleteString(), false );
 			}
 			else {
 				statement = session.getBatcher().prepareBatchStatement( getSQLDeleteString() );
@@ -688,7 +696,7 @@
 		
 			final PreparedStatement statement;
 			if ( isVersioned() ) {
-				statement = session.getBatcher().prepareStatement(sql);
+				statement = session.getBatcher().prepareStatement(sql, false);
 			}
 			else {
 				statement = session.getBatcher().prepareBatchStatement(sql);
Index: net/sf/hibernate/persister/NormalizedEntityPersister.java
===================================================================
RCS file: /cvsroot/hibernate/Hibernate2/src/net/sf/hibernate/persister/NormalizedEntityPersister.java,v
retrieving revision 1.32.2.27
diff -u -r1.32.2.27 NormalizedEntityPersister.java
--- net/sf/hibernate/persister/NormalizedEntityPersister.java	2 Nov 2003 04:53:08 -0000	1.32.2.27
+++ net/sf/hibernate/persister/NormalizedEntityPersister.java	4 Nov 2003 05:55:40 -0000
@@ -20,6 +20,7 @@
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Map;
+import java.lang.reflect.Method;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
@@ -32,7 +33,6 @@
 import net.sf.hibernate.MappingException;
 import net.sf.hibernate.QueryException;
 import net.sf.hibernate.StaleObjectStateException;
-import net.sf.hibernate.id.IdentifierGeneratorFactory;
 import net.sf.hibernate.impl.MessageHelper;
 import net.sf.hibernate.sql.CaseFragment;
 import net.sf.hibernate.sql.Delete;
@@ -438,7 +438,7 @@
 			
 			try {
 			
-				PreparedStatement st = session.getBatcher().prepareStatement( (String) lockers.get(lockMode) );
+				PreparedStatement st = session.getBatcher().prepareStatement( (String) lockers.get(lockMode), false );
 				try {
 					getIdentifierType().nullSafeSet(st, id, 1, session);
 					if ( isVersioned() ) getVersionType().nullSafeSet(st, version, getIdentifierColumnNames().length+1, session);
@@ -503,7 +503,7 @@
 			try {
 				
 				for ( int i=0; i<tableNames.length; i++ ) {
-					statements[i] = session.getBatcher().prepareStatement( sql[i] );
+					statements[i] = session.getBatcher().prepareStatement( sql[i], false );
 				}
 				
 				// Write the values of fields onto the prepared statement - we MUST use the state at the time the
@@ -539,13 +539,32 @@
 			log.trace("Inserting entity: " + getClassName() + " (native id)");
 			if ( isVersioned() ) log.trace( "Version: " + Versioning.getVersion(fields, this) );
 		}
+
+		boolean useGetGeneratedKeys = session.getFactory().isGetGeneratedKeysEnabled();
+		Serializable id = null;
 		
 		try {
 			
-			PreparedStatement statement = session.getBatcher().prepareStatement( sql[0] );
+			PreparedStatement statement = session.getBatcher().prepareStatement( sql[0], useGetGeneratedKeys );
 			try {
 				dehydrate(null, fields, notNull, 0, statement, session);
 				statement.executeUpdate();
+
+				if (useGetGeneratedKeys) {
+					try {
+						Method getGeneratedKeysMethod;
+						ResultSet rs = null;
+						getGeneratedKeysMethod = statement.getClass().getMethod("getGeneratedKeys",  new Class[0]);
+						rs = (ResultSet) getGeneratedKeysMethod.invoke(statement, new Object[0]);
+	                    id = getNativeId(object, session, rs);
+					} 
+					catch (Exception e) {
+						log.error(session.getBatcher().getClass().getName() 
+						+ " error invoking JDBC 3.0 PreparedStatement.getGeneratedKeys()", e);
+						throw new HibernateException("Class " + session.getBatcher().getClass().getName() 
+						+ " does not support JDBC 3.0 PreparedStatement.getGeneratedKeys()", e);
+					}
+				}	
 			}
 			catch (SQLException sqle) {
 				JDBCExceptionReporter.logExceptions(sqle);
@@ -556,34 +575,24 @@
 			}
 			
 			// fetch the generated id:
-			PreparedStatement idselect = session.getBatcher().prepareStatement( sqlIdentitySelect() );
-			final Serializable id;
-			try {
-				
-				ResultSet rs = idselect.executeQuery();
+			if (!useGetGeneratedKeys) {
+				PreparedStatement idselect = session.getBatcher().prepareStatement( sqlIdentitySelect(), false );
 				try {
-					if ( !rs.next() ) throw new HibernateException("The database returned no natively generated identity value");
-					id = IdentifierGeneratorFactory.get( 
-						rs, getIdentifierType(), session, object 
-					);
+					ResultSet rs = idselect.executeQuery();
+                    id = getNativeId(object, session, rs);
+				}
+				catch(SQLException sqle) {
+					JDBCExceptionReporter.logExceptions(sqle);
+					throw sqle;
 				}
 				finally {
-					rs.close();
+					session.getBatcher().closeStatement(idselect);
 				}
-				log.debug("Natively generated identity: " + id);
-				
-			}
-			catch(SQLException sqle) {
-				JDBCExceptionReporter.logExceptions(sqle);
-				throw sqle;
-			}
-			finally {
-				session.getBatcher().closeStatement(idselect);
 			}
 			
 			for ( int i=1; i<naturalOrderTableNames.length; i++ )  {
 				
-				statement = session.getBatcher().prepareStatement( sql[i] );
+				statement = session.getBatcher().prepareStatement( sql[i], false );
 				
 				try {
 					dehydrate(id, fields, notNull, i, statement, session);
@@ -623,7 +632,7 @@
 			try {
 				
 				for ( int i=0; i<naturalOrderTableNames.length; i++ ) {
-					statements[i] = session.getBatcher().prepareStatement( getSQLDeleteStrings()[i] );
+					statements[i] = session.getBatcher().prepareStatement( getSQLDeleteStrings()[i], false );
 				}
 				
 				if ( isVersioned() ) getVersionType().nullSafeSet( statements[0], version, getIdentifierColumnNames().length + 1, session );
@@ -699,7 +708,7 @@
 			try {
 				
 				for ( int i=0; i<tables; i++ ) {
-					if ( includeTable[i] ) statements[i] = session.getBatcher().prepareStatement( sql[i] );
+					if ( includeTable[i] ) statements[i] = session.getBatcher().prepareStatement( sql[i], false );
 				}
 				
 				int versionParam = dehydrate(id, fields, includeProperty, statements, session);
