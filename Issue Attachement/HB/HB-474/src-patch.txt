Index: net/sf/hibernate/Criteria.java
===================================================================
RCS file: /cvsroot/hibernate/Hibernate2/src/net/sf/hibernate/Criteria.java,v
retrieving revision 1.4.2.14
diff -u -r1.4.2.14 Criteria.java
--- net/sf/hibernate/Criteria.java	27 Oct 2003 11:46:57 -0000	1.4.2.14
+++ net/sf/hibernate/Criteria.java	16 Nov 2003 18:50:03 -0000
@@ -1,164 +1,172 @@
-//$Id: Criteria.java,v 1.4.2.14 2003/10/27 11:46:57 oneovthafew Exp $
-package net.sf.hibernate;
-
-import java.util.List;
-
-import net.sf.hibernate.expression.Criterion;
-import net.sf.hibernate.expression.Order;
-
-/**
- * <tt>Criteria</tt> is a simplified API for retrieving entities
- * by composing <tt>Criterion</tt> objects. This is a very
- * convenient approach for functionality like "search" screens
- * where there is a variable number of conditions to be placed
- * upon the result set.<br>
- * <br>
- * The <tt>Session</tt> is a factory for <tt>Criteria</tt>.
- * <tt>Criterion</tt> instances are usually obtained via
- * the factory methods on <tt>Expression</tt>. eg.
- * <pre>
- * List cats = session.createCriteria(Cat.class)
- *     .add( Expression.like("name", "Iz%") )
- *     .add( Expression.gt( "weight", new Float(minWeight) ) )
- *     .addOrder( Order.asc("age") )
- *     .list();
- * </pre>
- * You may navigate associations using <tt>addJoin</tt>.
- * <pre>
- * List cats = session.createCriteria(Cat.class)
- *     .createCriteria("kittens")
- *         .add( Expression.like("name", "Iz%") )
- *     .list();
- * </pre>
- * Hibernate's query language is much more general and should be used 
- * for non-simple cases.<br>
- * <br>
- * <i>This is an experimental API</i>
- * 
- * @see Session#createCriteria(java.lang.Class)
- * @see net.sf.hibernate.expression.Expression
- * @see net.sf.hibernate.expression.Criterion
- * @see net.sf.hibernate.expression.Order
- * @author Gavin King
- */
-public interface Criteria {
-	
-	/**
-	 * The alias that refers to the "root" entity of the criteria query.
-	 */
-	public static final String ROOT_ALIAS = "this";
-
-	/**
-	 * Set a limit upon the number of objects to be retrieved.
-	 * 
-	 * @param maxResults
-	 * @return Criteria
-	 */
-	public Criteria setMaxResults(int maxResults);
-	/**
-	 * Set the first result to be retrieved.
-	 * 
-	 * @param firstResult
-	 * @return Criteria
-	 */
-	public Criteria setFirstResult(int firstResult);
-	/**
-	 * Set a timeout for the underlying JDBC query.
-	 * 
-	 * @param timeout
-	 * @return Criteria
-	 */
-	public Criteria setTimeout(int timeout);
-	/**
-	 * Add an <tt>Criterion</tt> to constrain the result to be retrieved.
-	 * 
-	 * @param criterion
-	 * @return Criteria
-	 */
-	public Criteria add(Criterion criterion);
-	
-	/**
-	 * Add an <tt>Order</tt> to the result set.
-	 * 
-	 * @param order
-	 * @return Criteria
-	 */
-	public Criteria addOrder(Order order);
-	
-	/**
-	 * Get the results.
-	 * 
-	 * @return List
-	 * @throws HibernateException
-	 */
-	public List list() throws HibernateException;
-	
-	/**
-	 * Convenience method to return a single instance that matches
-	 * the query, or null if the query returns no results.
-	 * 
-	 * @return the single result or <tt>null</tt>
-	 * @throws HibernateException if there is more than one matching result
-	 */
-	public Object uniqueResult() throws HibernateException;
-	
-	/**
-	 * Specify an association fetching strategy for a
-	 * one-to-many, many-to-one or one-to-one association, or
-	 * for a collection of values.
-	 * 
-	 * @param associationPath a dot seperated property path
-	 * @param mode the fetch mode
-	 * @return the Criteria object for method chaining
-	 */
-	public Criteria setFetchMode(String associationPath, FetchMode mode) throws HibernateException;
-	/**
-	 * Join an association, assigning an alias to the joined entity
-	 */
-	public Criteria createAlias(String associationPath, String alias) throws HibernateException;
-	
-	/**
-	 * Create a new <tt>Criteria</tt>, "rooted" at the associated entity
-	 */
-	public Criteria createCriteria(String associationPath) throws HibernateException;
-	
-	/**
-	 * Create a new <tt>Criteria</tt>, "rooted" at the associated entity,
-	 * assigning the given alias
-	 */
-	public Criteria createCriteria(String associationPath, String alias) throws HibernateException;
-	
-	/**
-	 * Get the persistent class that this <tt>Criteria</tt> applies to
-	 */
-	public Class getCriteriaClass();
-	/**
-	 * Get the persistent class that the alias refers to
-	 */
-	public Class getCriteriaClass(String alias);
-	
-	/**
-	 * Return each row of results as a <tt>Map</tt> from alias
-	 * to an instance of the aliased entity
-	 * @see Criteria#returnRootEntities()
-	 */
-	public Criteria returnMaps();
-	/**
-	 * Return each row of results as a single instance of the
-	 * "root" entity (this is the default mode)
-	 * @see Criteria#returnMaps()
-	 */
-	public Criteria returnRootEntities();
-	
-	/**
-	 * Set the lock mode of the current entity
-	 * @param lockMode the lock mode
-	 */
-	public Criteria setLockMode(LockMode lockMode);
-	/**
-	 * Set the lock mode of the aliased entity
-	 * @param alias an alias
-	 * @param lockMode the lock mode
-	 */
-	public Criteria setLockMode(String alias, LockMode lockMode);
+//$Id: Criteria.java,v 1.4.2.14 2003/10/27 11:46:57 oneovthafew Exp $
+package net.sf.hibernate;
+
+import java.util.List;
+
+import net.sf.hibernate.expression.Criterion;
+import net.sf.hibernate.expression.Order;
+
+/**
+ * <tt>Criteria</tt> is a simplified API for retrieving entities
+ * by composing <tt>Criterion</tt> objects. This is a very
+ * convenient approach for functionality like "search" screens
+ * where there is a variable number of conditions to be placed
+ * upon the result set.<br>
+ * <br>
+ * The <tt>Session</tt> is a factory for <tt>Criteria</tt>.
+ * <tt>Criterion</tt> instances are usually obtained via
+ * the factory methods on <tt>Expression</tt>. eg.
+ * <pre>
+ * List cats = session.createCriteria(Cat.class)
+ *     .add( Expression.like("name", "Iz%") )
+ *     .add( Expression.gt( "weight", new Float(minWeight) ) )
+ *     .addOrder( Order.asc("age") )
+ *     .list();
+ * </pre>
+ * You may navigate associations using <tt>addJoin</tt>.
+ * <pre>
+ * List cats = session.createCriteria(Cat.class)
+ *     .createCriteria("kittens")
+ *         .add( Expression.like("name", "Iz%") )
+ *     .list();
+ * </pre>
+ * Hibernate's query language is much more general and should be used 
+ * for non-simple cases.<br>
+ * <br>
+ * <i>This is an experimental API</i>
+ * 
+ * @see Session#createCriteria(java.lang.Class)
+ * @see net.sf.hibernate.expression.Expression
+ * @see net.sf.hibernate.expression.Criterion
+ * @see net.sf.hibernate.expression.Order
+ * @author Gavin King
+ */
+public interface Criteria {
+	
+	/**
+	 * The alias that refers to the "root" entity of the criteria query.
+	 */
+	public static final String ROOT_ALIAS = "this";
+
+	/**
+	 * Set a limit upon the number of objects to be retrieved.
+	 * 
+	 * @param maxResults
+	 * @return Criteria
+	 */
+	public Criteria setMaxResults(int maxResults);
+	/**
+	 * Set the first result to be retrieved.
+	 * 
+	 * @param firstResult
+	 * @return Criteria
+	 */
+	public Criteria setFirstResult(int firstResult);
+	/**
+	 * Set a timeout for the underlying JDBC query.
+	 * 
+	 * @param timeout
+	 * @return Criteria
+	 */
+	public Criteria setTimeout(int timeout);
+	/**
+	 * Add an <tt>Criterion</tt> to constrain the result to be retrieved.
+	 * 
+	 * @param criterion
+	 * @return Criteria
+	 */
+	public Criteria add(Criterion criterion);
+	
+	/**
+	 * Add an <tt>Order</tt> to the result set.
+	 * 
+	 * @param order
+	 * @return Criteria
+	 */
+	public Criteria addOrder(Order order);
+	
+	/**
+	 * Returns a count of the objects returned by this query
+	 * without loading all objects
+	 * @return count
+	 * @throws HibernateException
+	 */
+	public long count() throws HibernateException;
+	
+	/**
+	 * Get the results.
+	 * 
+	 * @return List
+	 * @throws HibernateException
+	 */
+	public List list() throws HibernateException;
+	
+	/**
+	 * Convenience method to return a single instance that matches
+	 * the query, or null if the query returns no results.
+	 * 
+	 * @return the single result or <tt>null</tt>
+	 * @throws HibernateException if there is more than one matching result
+	 */
+	public Object uniqueResult() throws HibernateException;
+	
+	/**
+	 * Specify an association fetching strategy for a
+	 * one-to-many, many-to-one or one-to-one association, or
+	 * for a collection of values.
+	 * 
+	 * @param associationPath a dot seperated property path
+	 * @param mode the fetch mode
+	 * @return the Criteria object for method chaining
+	 */
+	public Criteria setFetchMode(String associationPath, FetchMode mode) throws HibernateException;
+	/**
+	 * Join an association, assigning an alias to the joined entity
+	 */
+	public Criteria createAlias(String associationPath, String alias) throws HibernateException;
+	
+	/**
+	 * Create a new <tt>Criteria</tt>, "rooted" at the associated entity
+	 */
+	public Criteria createCriteria(String associationPath) throws HibernateException;
+	
+	/**
+	 * Create a new <tt>Criteria</tt>, "rooted" at the associated entity,
+	 * assigning the given alias
+	 */
+	public Criteria createCriteria(String associationPath, String alias) throws HibernateException;
+	
+	/**
+	 * Get the persistent class that this <tt>Criteria</tt> applies to
+	 */
+	public Class getCriteriaClass();
+	/**
+	 * Get the persistent class that the alias refers to
+	 */
+	public Class getCriteriaClass(String alias);
+	
+	/**
+	 * Return each row of results as a <tt>Map</tt> from alias
+	 * to an instance of the aliased entity
+	 * @see Criteria#returnRootEntities()
+	 */
+	public Criteria returnMaps();
+	/**
+	 * Return each row of results as a single instance of the
+	 * "root" entity (this is the default mode)
+	 * @see Criteria#returnMaps()
+	 */
+	public Criteria returnRootEntities();
+	
+	/**
+	 * Set the lock mode of the current entity
+	 * @param lockMode the lock mode
+	 */
+	public Criteria setLockMode(LockMode lockMode);
+	/**
+	 * Set the lock mode of the aliased entity
+	 * @param alias an alias
+	 * @param lockMode the lock mode
+	 */
+	public Criteria setLockMode(String alias, LockMode lockMode);
 }
Index: net/sf/hibernate/impl/CriteriaImpl.java
===================================================================
RCS file: /cvsroot/hibernate/Hibernate2/src/net/sf/hibernate/impl/CriteriaImpl.java,v
retrieving revision 1.4.2.15
diff -u -r1.4.2.15 CriteriaImpl.java
--- net/sf/hibernate/impl/CriteriaImpl.java	7 Nov 2003 01:04:16 -0000	1.4.2.15
+++ net/sf/hibernate/impl/CriteriaImpl.java	16 Nov 2003 18:50:04 -0000
@@ -1,365 +1,373 @@
-//$Id: CriteriaImpl.java,v 1.4.2.15 2003/11/07 01:04:16 oneovthafew Exp $
-package net.sf.hibernate.impl;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-import net.sf.hibernate.Criteria;
-import net.sf.hibernate.FetchMode;
-import net.sf.hibernate.HibernateException;
-import net.sf.hibernate.LockMode;
-import net.sf.hibernate.QueryException;
-import net.sf.hibernate.engine.SessionFactoryImplementor;
-import net.sf.hibernate.expression.Criterion;
-import net.sf.hibernate.expression.Order;
-import net.sf.hibernate.persister.PropertyMapping;
-import net.sf.hibernate.type.AssociationType;
-import net.sf.hibernate.type.Type;
-import net.sf.hibernate.util.StringHelper;
-
-/**
- * Implementation of the <tt>Criteria</tt> interface
- * @author Gavin King
- */
-public class CriteriaImpl implements Criteria {
-	
-	private List criteria = new ArrayList();
-	private List orderings = new ArrayList();
-	private Map fetchModes = new HashMap();
-	private Map associationPathByAlias = new HashMap();
-	private Map aliasByAssociationPath = new HashMap();
-	private Map classByAlias = new HashMap();
-	private Map lockModes = new HashMap();
-	private Integer maxResults;
-	private Integer firstResult;
-	private Integer timeout;
-	private Class persistentClass;
-	private SessionImpl session;
-	private boolean returnMap;
-	
-	private int counter=0;
-	
-	private String generateAlias() {
-		return "x" + counter++ + StringHelper.UNDERSCORE;
-	}
-	public final class Subcriteria implements Criteria {
-		
-		private String rootAlias;
-		private String rootPath;
-		
-		private Subcriteria(String rootAlias, String rootPath) {
-			this.rootAlias = rootAlias;
-			this.rootPath = rootPath;
-		}
-		
-		public Criteria add(Criterion expression) {
-			CriteriaImpl.this.add(rootAlias, expression);
-			return this;
-		}
-
-		public Criteria createAlias(String associationPath, String alias)
-			throws HibernateException {
-			CriteriaImpl.this.createAlias(rootAlias, associationPath, alias);
-			return this;
-		}
-
-		public Criteria addOrder(Order order) {
-			throw new UnsupportedOperationException("subcriteria cannot be ordered");
-		}
-
-		public Criteria createCriteria(String associationPath)
-			throws HibernateException {
-			return CriteriaImpl.this.createCriteriaAt(rootAlias, associationPath);
-		}
-
-		public List list() throws HibernateException {
-			return CriteriaImpl.this.list();
-		}
-
-		public Object uniqueResult() throws HibernateException {
-			return CriteriaImpl.this.uniqueResult();
-		}
-
-		public Criteria setFetchMode(String associationPath, FetchMode mode)
-			throws HibernateException {
-			CriteriaImpl.this.setFetchMode( StringHelper.qualify(rootPath, associationPath), mode);
-			return this;
-		}
-
-		public Criteria setFirstResult(int firstResult) {
-			CriteriaImpl.this.setFirstResult(firstResult);
-			return this;
-		}
-
-		public Criteria setMaxResults(int maxResults) {
-			CriteriaImpl.this.setMaxResults(maxResults);
-			return this;
-		}
-
-		public Criteria setTimeout(int timeout) {
-			CriteriaImpl.this.setTimeout(timeout);
-			return this;
-		}
-
-		public Class getCriteriaClass() {
-			return CriteriaImpl.this.getCriteriaClass(rootAlias);
-		}
-
-		public Class getCriteriaClass(String alias) {
-			return CriteriaImpl.this.getCriteriaClass(alias);
-		}
-
-		public Criteria createCriteria(String associationPath, String alias)
-			throws HibernateException {
-			return CriteriaImpl.this.createCriteriaAt(rootAlias, associationPath, alias);
-		}
-
-		public Criteria returnMaps() {
-			CriteriaImpl.this.returnMaps();
-			return this;
-		}
-
-		public Criteria returnRootEntities() {
-			CriteriaImpl.this.returnRootEntities();
-			return this;
-		}
-
-		public Criteria setLockMode(LockMode lockMode) {
-			CriteriaImpl.this.setLockMode(rootAlias, lockMode);
-			return this;
-		}
-
-		public Criteria setLockMode(String alias, LockMode lockMode) {
-			CriteriaImpl.this.setLockMode(alias, lockMode);
-			return this;
-		}
-
-	}
-
-	public Criteria setMaxResults(int maxResults) {
-		this.maxResults = new Integer(maxResults);
-		return this;
-	}
-	public Criteria setFirstResult(int firstResult) {
-		this.firstResult = new Integer(firstResult);
-		return this;
-	}
-	public Criteria setTimeout(int timeout) {
-		this.timeout = new Integer(timeout);
-		return this;
-	}
-	
-	public Criteria add(Criterion expression) {
-		add(Criteria.ROOT_ALIAS, expression);
-		return this;
-	}
-	
-	public Integer getMaxResults() {
-		return maxResults;
-	}
-	public Integer getFirstResult() {
-		return firstResult;
-	}
-	public Integer getTimeout() {
-		return timeout;
-	}
-	
-	public CriteriaImpl(Class persistentClass, SessionImpl session) {
-		this.persistentClass = persistentClass;
-		this.session = session;
-		this.classByAlias.put(Criteria.ROOT_ALIAS, persistentClass);
-	}
-	
-	public List list() throws HibernateException {
-		return session.find(this);
-	}
-	
-	public Iterator iterateExpressionEntries() {
-		return criteria.iterator();
-	}
-	
-	public Iterator iterateOrderings() {
-		return orderings.iterator();
-	}
-	
-	public Class getPersistentClass(String alias) {
-		return (Class) classByAlias.get(alias);
-	}
-	
-	public Map getAliasClasses() {
-		return classByAlias;
-	}
-	
-	public String toString() {
-		return criteria.toString();
-	}
-
-	public Criteria addOrder(Order ordering) {
-		orderings.add(ordering);
-		return this;
-	}
-	
-	public FetchMode getFetchMode(String path) {
-		return (FetchMode) fetchModes.get(path);
-	}
-	
-	public Criteria setFetchMode(String associationPath, FetchMode mode) {
-		fetchModes.put(associationPath, mode);
-		return this;
-	}
-
-	public Criteria createAlias(String associationPath, String alias) throws HibernateException {
-		createAlias(ROOT_ALIAS, associationPath, alias);
-		return this;
-	}
-	
-	private void createAlias(String rootAlias, String associationPath, String alias) throws HibernateException {
-		
-		String testAlias = StringHelper.root(associationPath);
-		if ( classByAlias.containsKey(testAlias) ) {
-			rootAlias = testAlias;
-			associationPath = associationPath.substring( rootAlias.length() + 1 );
-		}
-		
-		String rootPath = (String) associationPathByAlias.get(rootAlias);
-		String wholeAssociationPath;
-		if (rootPath==null) {
-			if ( !ROOT_ALIAS.equals(rootAlias) ) throw new HibernateException("unknown alias: " + rootAlias);
-			wholeAssociationPath = associationPath;
-		}
-		else {
-			wholeAssociationPath = StringHelper.qualify(rootPath, associationPath);
-		}
-		
-		associationPathByAlias.put(alias, wholeAssociationPath);
-		aliasByAssociationPath.put(wholeAssociationPath, alias);
-		classByAlias.put( alias, getClassForPath(rootAlias, associationPath) );
-	}
-	
-	public boolean isJoin(String path) {
-		return aliasByAssociationPath.containsKey(path);
-	}
-	
-	public String getAlias(String associationPath) {
-		return (String) aliasByAssociationPath.get(associationPath);
-	}
-
-	public Criteria add(String alias, Criterion expression) {
-		criteria.add( new CriterionEntry(expression, alias) );
-		return this;
-	}
-	
-	/*private Type getType(PropertyMapping pm, String associationPath, SessionFactoryImplementor factory) 
-	throws HibernateException {
-		//whoa! reuseable code buried all the way down here!
-		String[] pathComponents = StringHelper.split(".", associationPath);
-		StringBuffer subpath = new StringBuffer( associationPath.length() );
-		Type type = null;
-		for ( int i=0; i<pathComponents.length; i++ ) {
-			subpath.append( pathComponents[i] );
-			type = pm.toType( subpath.toString() );
-			if ( i<pathComponents.length-1 && type.isAssociationType() ) {
-				return getType( 
-					( (AssociationType) type ).getJoinable(factory), 
-					associationPath.substring( subpath.length()+1 ), 
-					factory 
-				);
-			}
-			subpath.append(".");
-		}
-		return type;
-	}*/
-	
-	public Class getClassForPath(String rootAlias, String associationPath) throws HibernateException {
-		SessionFactoryImplementor factory = session.getFactory();
-		Class clazz = (Class) classByAlias.get(rootAlias);
-		//Type type = getType( (Joinable) factory.getPersister(clazz), associationPath, factory );
-		Type type = ( (PropertyMapping) factory.getPersister(clazz) ).toType(associationPath);
-		if ( !type.isAssociationType() ) throw new QueryException("not an association path: " + associationPath);
-		return ( (AssociationType) type ).getAssociatedClass(factory);
-	}
-	
-	public static final class CriterionEntry {
-		private final Criterion criterion;
-		private final String alias;
-		private CriterionEntry(Criterion criterion, String alias) {
-			this.alias = alias;
-			this.criterion = criterion;
-		}
-
-		public Criterion getCriterion() {
-			return criterion;
-		}
-
-		public String getAlias() {
-			return alias;
-		}
-	}
-	
-	public Criteria createCriteria(String associationPath) throws HibernateException {
-		return createCriteriaAt( ROOT_ALIAS, associationPath );
-	}
-	
-	private Criteria createCriteriaAt(String rootAlias, String associationPath)  throws HibernateException {
-		return createCriteriaAt( rootAlias, associationPath, generateAlias() );
-	}
-
-	private Criteria createCriteriaAt(String rootAlias, String associationPath, String alias)  throws HibernateException {
-		String testAlias = StringHelper.root(associationPath);
-		if ( classByAlias.containsKey(testAlias) ) {
-			rootAlias = testAlias;
-			associationPath = associationPath.substring( rootAlias.length() + 1 );
-		}
-
-		createAlias(rootAlias, associationPath, alias);
-		return new Subcriteria(alias, associationPath);
-	}
-
-	public Object uniqueResult() throws HibernateException {
-		return AbstractQueryImpl.uniqueElement( list() );
-	}
-
-	public Class getCriteriaClass() {
-		return persistentClass;
-	}
-
-	public Class getCriteriaClass(String alias) {
-		return (Class) classByAlias.get(alias);
-	}
-
-	public Criteria createCriteria(String associationPath, String alias)
-		throws HibernateException {
-		return createCriteriaAt(ROOT_ALIAS, associationPath, alias);
-	}
-	
-	public boolean isReturnMapEnabled() {
-		return returnMap;
-	}
-
-	public Criteria returnMaps() {
-		returnMap = true;
-		return this;
-	}
-
-	public Criteria returnRootEntities() {
-		returnMap = false;
-		return this;
-	}
-
-	public Criteria setLockMode(LockMode lockMode) {
-		return setLockMode(Criteria.ROOT_ALIAS, lockMode);
-	}
-
-	public Criteria setLockMode(String alias, LockMode lockMode) {
-		lockModes.put(alias, lockMode);
-		return this;
-	}
-	
-	public Map getLockModes() {
-		return lockModes;
-	}
-
-}
+//$Id: CriteriaImpl.java,v 1.4.2.15 2003/11/07 01:04:16 oneovthafew Exp $
+package net.sf.hibernate.impl;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+import net.sf.hibernate.Criteria;
+import net.sf.hibernate.FetchMode;
+import net.sf.hibernate.HibernateException;
+import net.sf.hibernate.LockMode;
+import net.sf.hibernate.QueryException;
+import net.sf.hibernate.engine.SessionFactoryImplementor;
+import net.sf.hibernate.expression.Criterion;
+import net.sf.hibernate.expression.Order;
+import net.sf.hibernate.persister.PropertyMapping;
+import net.sf.hibernate.type.AssociationType;
+import net.sf.hibernate.type.Type;
+import net.sf.hibernate.util.StringHelper;
+
+/**
+ * Implementation of the <tt>Criteria</tt> interface
+ * @author Gavin King
+ */
+public class CriteriaImpl implements Criteria {
+	
+	private List criteria = new ArrayList();
+	private List orderings = new ArrayList();
+	private Map fetchModes = new HashMap();
+	private Map associationPathByAlias = new HashMap();
+	private Map aliasByAssociationPath = new HashMap();
+	private Map classByAlias = new HashMap();
+	private Map lockModes = new HashMap();
+	private Integer maxResults;
+	private Integer firstResult;
+	private Integer timeout;
+	private Class persistentClass;
+	private SessionImpl session;
+	private boolean returnMap;
+	
+	private int counter=0;
+	
+	private String generateAlias() {
+		return "x" + counter++ + StringHelper.UNDERSCORE;
+	}
+	public final class Subcriteria implements Criteria {
+		
+		private String rootAlias;
+		private String rootPath;
+		
+		private Subcriteria(String rootAlias, String rootPath) {
+			this.rootAlias = rootAlias;
+			this.rootPath = rootPath;
+		}
+		
+		public Criteria add(Criterion expression) {
+			CriteriaImpl.this.add(rootAlias, expression);
+			return this;
+		}
+
+		public Criteria createAlias(String associationPath, String alias)
+			throws HibernateException {
+			CriteriaImpl.this.createAlias(rootAlias, associationPath, alias);
+			return this;
+		}
+
+		public Criteria addOrder(Order order) {
+			throw new UnsupportedOperationException("subcriteria cannot be ordered");
+		}
+
+		public Criteria createCriteria(String associationPath)
+			throws HibernateException {
+			return CriteriaImpl.this.createCriteriaAt(rootAlias, associationPath);
+		}
+
+		public long count() throws HibernateException {
+			return CriteriaImpl.this.count();
+		}
+		
+		public List list() throws HibernateException {
+			return CriteriaImpl.this.list();
+		}
+
+		public Object uniqueResult() throws HibernateException {
+			return CriteriaImpl.this.uniqueResult();
+		}
+
+		public Criteria setFetchMode(String associationPath, FetchMode mode)
+			throws HibernateException {
+			CriteriaImpl.this.setFetchMode( StringHelper.qualify(rootPath, associationPath), mode);
+			return this;
+		}
+
+		public Criteria setFirstResult(int firstResult) {
+			CriteriaImpl.this.setFirstResult(firstResult);
+			return this;
+		}
+
+		public Criteria setMaxResults(int maxResults) {
+			CriteriaImpl.this.setMaxResults(maxResults);
+			return this;
+		}
+
+		public Criteria setTimeout(int timeout) {
+			CriteriaImpl.this.setTimeout(timeout);
+			return this;
+		}
+
+		public Class getCriteriaClass() {
+			return CriteriaImpl.this.getCriteriaClass(rootAlias);
+		}
+
+		public Class getCriteriaClass(String alias) {
+			return CriteriaImpl.this.getCriteriaClass(alias);
+		}
+
+		public Criteria createCriteria(String associationPath, String alias)
+			throws HibernateException {
+			return CriteriaImpl.this.createCriteriaAt(rootAlias, associationPath, alias);
+		}
+
+		public Criteria returnMaps() {
+			CriteriaImpl.this.returnMaps();
+			return this;
+		}
+
+		public Criteria returnRootEntities() {
+			CriteriaImpl.this.returnRootEntities();
+			return this;
+		}
+
+		public Criteria setLockMode(LockMode lockMode) {
+			CriteriaImpl.this.setLockMode(rootAlias, lockMode);
+			return this;
+		}
+
+		public Criteria setLockMode(String alias, LockMode lockMode) {
+			CriteriaImpl.this.setLockMode(alias, lockMode);
+			return this;
+		}
+
+	}
+
+	public Criteria setMaxResults(int maxResults) {
+		this.maxResults = new Integer(maxResults);
+		return this;
+	}
+	public Criteria setFirstResult(int firstResult) {
+		this.firstResult = new Integer(firstResult);
+		return this;
+	}
+	public Criteria setTimeout(int timeout) {
+		this.timeout = new Integer(timeout);
+		return this;
+	}
+	
+	public Criteria add(Criterion expression) {
+		add(Criteria.ROOT_ALIAS, expression);
+		return this;
+	}
+	
+	public Integer getMaxResults() {
+		return maxResults;
+	}
+	public Integer getFirstResult() {
+		return firstResult;
+	}
+	public Integer getTimeout() {
+		return timeout;
+	}
+	
+	public CriteriaImpl(Class persistentClass, SessionImpl session) {
+		this.persistentClass = persistentClass;
+		this.session = session;
+		this.classByAlias.put(Criteria.ROOT_ALIAS, persistentClass);
+	}
+
+	public long count() throws HibernateException {
+		return session.count(this);
+	}
+		
+	public List list() throws HibernateException {
+		return session.find(this);
+	}
+	
+	public Iterator iterateExpressionEntries() {
+		return criteria.iterator();
+	}
+	
+	public Iterator iterateOrderings() {
+		return orderings.iterator();
+	}
+	
+	public Class getPersistentClass(String alias) {
+		return (Class) classByAlias.get(alias);
+	}
+	
+	public Map getAliasClasses() {
+		return classByAlias;
+	}
+	
+	public String toString() {
+		return criteria.toString();
+	}
+
+	public Criteria addOrder(Order ordering) {
+		orderings.add(ordering);
+		return this;
+	}
+	
+	public FetchMode getFetchMode(String path) {
+		return (FetchMode) fetchModes.get(path);
+	}
+	
+	public Criteria setFetchMode(String associationPath, FetchMode mode) {
+		fetchModes.put(associationPath, mode);
+		return this;
+	}
+
+	public Criteria createAlias(String associationPath, String alias) throws HibernateException {
+		createAlias(ROOT_ALIAS, associationPath, alias);
+		return this;
+	}
+	
+	private void createAlias(String rootAlias, String associationPath, String alias) throws HibernateException {
+		
+		String testAlias = StringHelper.root(associationPath);
+		if ( classByAlias.containsKey(testAlias) ) {
+			rootAlias = testAlias;
+			associationPath = associationPath.substring( rootAlias.length() + 1 );
+		}
+		
+		String rootPath = (String) associationPathByAlias.get(rootAlias);
+		String wholeAssociationPath;
+		if (rootPath==null) {
+			if ( !ROOT_ALIAS.equals(rootAlias) ) throw new HibernateException("unknown alias: " + rootAlias);
+			wholeAssociationPath = associationPath;
+		}
+		else {
+			wholeAssociationPath = StringHelper.qualify(rootPath, associationPath);
+		}
+		
+		associationPathByAlias.put(alias, wholeAssociationPath);
+		aliasByAssociationPath.put(wholeAssociationPath, alias);
+		classByAlias.put( alias, getClassForPath(rootAlias, associationPath) );
+	}
+	
+	public boolean isJoin(String path) {
+		return aliasByAssociationPath.containsKey(path);
+	}
+	
+	public String getAlias(String associationPath) {
+		return (String) aliasByAssociationPath.get(associationPath);
+	}
+
+	public Criteria add(String alias, Criterion expression) {
+		criteria.add( new CriterionEntry(expression, alias) );
+		return this;
+	}
+	
+	/*private Type getType(PropertyMapping pm, String associationPath, SessionFactoryImplementor factory) 
+	throws HibernateException {
+		//whoa! reuseable code buried all the way down here!
+		String[] pathComponents = StringHelper.split(".", associationPath);
+		StringBuffer subpath = new StringBuffer( associationPath.length() );
+		Type type = null;
+		for ( int i=0; i<pathComponents.length; i++ ) {
+			subpath.append( pathComponents[i] );
+			type = pm.toType( subpath.toString() );
+			if ( i<pathComponents.length-1 && type.isAssociationType() ) {
+				return getType( 
+					( (AssociationType) type ).getJoinable(factory), 
+					associationPath.substring( subpath.length()+1 ), 
+					factory 
+				);
+			}
+			subpath.append(".");
+		}
+		return type;
+	}*/
+	
+	public Class getClassForPath(String rootAlias, String associationPath) throws HibernateException {
+		SessionFactoryImplementor factory = session.getFactory();
+		Class clazz = (Class) classByAlias.get(rootAlias);
+		//Type type = getType( (Joinable) factory.getPersister(clazz), associationPath, factory );
+		Type type = ( (PropertyMapping) factory.getPersister(clazz) ).toType(associationPath);
+		if ( !type.isAssociationType() ) throw new QueryException("not an association path: " + associationPath);
+		return ( (AssociationType) type ).getAssociatedClass(factory);
+	}
+	
+	public static final class CriterionEntry {
+		private final Criterion criterion;
+		private final String alias;
+		private CriterionEntry(Criterion criterion, String alias) {
+			this.alias = alias;
+			this.criterion = criterion;
+		}
+
+		public Criterion getCriterion() {
+			return criterion;
+		}
+
+		public String getAlias() {
+			return alias;
+		}
+	}
+	
+	public Criteria createCriteria(String associationPath) throws HibernateException {
+		return createCriteriaAt( ROOT_ALIAS, associationPath );
+	}
+	
+	private Criteria createCriteriaAt(String rootAlias, String associationPath)  throws HibernateException {
+		return createCriteriaAt( rootAlias, associationPath, generateAlias() );
+	}
+
+	private Criteria createCriteriaAt(String rootAlias, String associationPath, String alias)  throws HibernateException {
+		String testAlias = StringHelper.root(associationPath);
+		if ( classByAlias.containsKey(testAlias) ) {
+			rootAlias = testAlias;
+			associationPath = associationPath.substring( rootAlias.length() + 1 );
+		}
+
+		createAlias(rootAlias, associationPath, alias);
+		return new Subcriteria(alias, associationPath);
+	}
+
+	public Object uniqueResult() throws HibernateException {
+		return AbstractQueryImpl.uniqueElement( list() );
+	}
+
+	public Class getCriteriaClass() {
+		return persistentClass;
+	}
+
+	public Class getCriteriaClass(String alias) {
+		return (Class) classByAlias.get(alias);
+	}
+
+	public Criteria createCriteria(String associationPath, String alias)
+		throws HibernateException {
+		return createCriteriaAt(ROOT_ALIAS, associationPath, alias);
+	}
+	
+	public boolean isReturnMapEnabled() {
+		return returnMap;
+	}
+
+	public Criteria returnMaps() {
+		returnMap = true;
+		return this;
+	}
+
+	public Criteria returnRootEntities() {
+		returnMap = false;
+		return this;
+	}
+
+	public Criteria setLockMode(LockMode lockMode) {
+		return setLockMode(Criteria.ROOT_ALIAS, lockMode);
+	}
+
+	public Criteria setLockMode(String alias, LockMode lockMode) {
+		lockModes.put(alias, lockMode);
+		return this;
+	}
+	
+	public Map getLockModes() {
+		return lockModes;
+	}
+
+}
Index: net/sf/hibernate/impl/SessionImpl.java
===================================================================
RCS file: /cvsroot/hibernate/Hibernate2/src/net/sf/hibernate/impl/SessionImpl.java,v
retrieving revision 1.59.2.84
diff -u -r1.59.2.84 SessionImpl.java
--- net/sf/hibernate/impl/SessionImpl.java	16 Nov 2003 04:58:03 -0000	1.59.2.84
+++ net/sf/hibernate/impl/SessionImpl.java	16 Nov 2003 18:50:07 -0000
@@ -3591,7 +3591,23 @@
 		return new CriteriaImpl(persistentClass, this);
 	}
 
-
+	/**
+	 * returns a count of this criteria's query
+	 * @param criteriaImpl
+	 * @return
+	 */
+	public long count(CriteriaImpl criteria) throws HibernateException
+	{
+		Loadable persister = (Loadable) getPersister( criteria.getCriteriaClass() );
+		CriteriaLoader loader = new CriteriaLoader(persister, factory, criteria);	
+		try {
+			return loader.count(this);
+		}
+		catch (SQLException sqle) {
+			throw new JDBCException(sqle);
+		}			
+	}
+	
 	public List find(CriteriaImpl criteria)
 		throws HibernateException {
 
Index: net/sf/hibernate/loader/AbstractEntityLoader.java
===================================================================
RCS file: /cvsroot/hibernate/Hibernate2/src/net/sf/hibernate/loader/AbstractEntityLoader.java,v
retrieving revision 1.6.2.16
diff -u -r1.6.2.16 AbstractEntityLoader.java
--- net/sf/hibernate/loader/AbstractEntityLoader.java	15 Nov 2003 09:49:06 -0000	1.6.2.16
+++ net/sf/hibernate/loader/AbstractEntityLoader.java	16 Nov 2003 18:50:07 -0000
@@ -32,6 +32,8 @@
 	private int collectionOwner;
 	private String alias;
 	
+	protected Select select;
+	
 	public AbstractEntityLoader(Loadable persister, SessionFactoryImplementor factory) {
 		super( factory.getDialect() );
 		this.persister = persister;
@@ -103,7 +105,7 @@
 		
 		JoinFragment ojf = mergeOuterJoins(associations);
 
-		sql = new Select()
+		select = new Select()
 			.setSelectClause(
 				persister.joinSelectFragment( alias, suffixes[joins] ) +
 				selectString(associations, factory)
@@ -117,8 +119,9 @@
 				ojf.toFromFragmentString(),
 				ojf.toWhereFragmentString() + getWhereFragment()
 			)
-			.setOrderByClause(orderBy)
-			.toStatementString();
+			.setOrderByClause(orderBy);
+		
+		sql = select.toStatementString();
 		
 	}
 	
Index: net/sf/hibernate/loader/CriteriaLoader.java
===================================================================
RCS file: /cvsroot/hibernate/Hibernate2/src/net/sf/hibernate/loader/CriteriaLoader.java,v
retrieving revision 1.8.2.19
diff -u -r1.8.2.19 CriteriaLoader.java
--- net/sf/hibernate/loader/CriteriaLoader.java	9 Nov 2003 04:20:41 -0000	1.8.2.19
+++ net/sf/hibernate/loader/CriteriaLoader.java	16 Nov 2003 18:50:07 -0000
@@ -1,209 +1,269 @@
-//$Id: CriteriaLoader.java,v 1.8.2.19 2003/11/09 04:20:41 oneovthafew Exp $
-package net.sf.hibernate.loader;
-
-import java.io.Serializable;
-import java.sql.ResultSet;
-import java.sql.SQLException;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import net.sf.hibernate.Criteria;
-import net.sf.hibernate.FetchMode;
-import net.sf.hibernate.HibernateException;
-import net.sf.hibernate.LockMode;
-import net.sf.hibernate.MappingException;
-import net.sf.hibernate.QueryException;
-import net.sf.hibernate.dialect.Dialect;
-import net.sf.hibernate.engine.QueryParameters;
-import net.sf.hibernate.engine.RowSelection;
-import net.sf.hibernate.engine.SessionFactoryImplementor;
-import net.sf.hibernate.engine.SessionImplementor;
-import net.sf.hibernate.engine.TypedValue;
-import net.sf.hibernate.expression.Order;
-import net.sf.hibernate.impl.CriteriaImpl;
-import net.sf.hibernate.persister.Loadable;
-import net.sf.hibernate.persister.Queryable;
-import net.sf.hibernate.sql.ForUpdateFragment;
-import net.sf.hibernate.sql.JoinFragment;
-import net.sf.hibernate.type.AssociationType;
-import net.sf.hibernate.type.Type;
-import net.sf.hibernate.util.ArrayHelper;
-
-//TODO: this class depends directly upon CriteriaImpl, in the impl package ... add a CriteriaImplementor interface
-/**
- * A <tt>Loader</tt> for <tt>Criteria</tt> queries. Note that criteria queries are
- * more like multi-object <tt>load()</tt>s than like HQL queries.
- * 
- * @author Gavin King
- */
-public class CriteriaLoader extends AbstractEntityLoader {
-	
-	private CriteriaImpl criteria;
-	private Set querySpaces = new HashSet();
-	private final List aliases = new ArrayList();
-	
-	public CriteriaLoader(Loadable persister, SessionFactoryImplementor factory, CriteriaImpl criteria) throws HibernateException {
-		super(persister, factory);
-		this.criteria = criteria;
-		
-		addAllToPropertySpaces( persister.getPropertySpaces() );
-
-		StringBuffer condition = new StringBuffer(30);
-		Iterator iter = criteria.iterateExpressionEntries();
-		if ( !iter.hasNext() ) condition.append("1=1"); //TODO: fix this ugliness
-		while ( iter.hasNext() ) {
-			CriteriaImpl.CriterionEntry ee = (CriteriaImpl.CriterionEntry) iter.next();
-			String sqlString = ee.getCriterion().toSqlString(
-				factory, 
-				criteria.getPersistentClass( ee.getAlias() ), 
-				ee.getAlias(),
-				criteria.getAliasClasses()
-			);
-			condition.append(sqlString);
-			if ( iter.hasNext() ) condition.append(" and ");
-		}
-		
-		StringBuffer orderBy = new StringBuffer(30);
-		iter = criteria.iterateOrderings();
-		while ( iter.hasNext() ) {
-			Order ord = (Order) iter.next();
-			orderBy.append( ord.toSqlString( factory, criteria.getCriteriaClass(), getAlias() ) );
-			if ( iter.hasNext() ) orderBy.append(", ");
-		}
-		
-		renderStatement( condition.toString(), orderBy.toString(), factory );
-		
-		postInstantiate();
-
-	}
-	
-	public List list(SessionImplementor session) throws HibernateException, SQLException {
-		List values = new ArrayList();
-		List types = new ArrayList();
-		Iterator iter = criteria.iterateExpressionEntries();
-		while ( iter.hasNext() ) {
-			CriteriaImpl.CriterionEntry ce = (CriteriaImpl.CriterionEntry) iter.next();
-			TypedValue[] tv = ce.getCriterion().getTypedValues( 
-				session.getFactory(), 
-				criteria.getCriteriaClass( ce.getAlias() ),
-				criteria.getAliasClasses()
-			);
-			for ( int i=0; i<tv.length; i++ ) {
-				values.add( tv[i].getValue() );
-				types.add( tv[i].getType() );
-			}
-		}
-		Object[] valueArray = values.toArray();
-		Type[] typeArray = (Type[]) types.toArray(ArrayHelper.EMPTY_TYPE_ARRAY);
-		
-		RowSelection selection = new RowSelection();
-		selection.setFirstRow( criteria.getFirstResult() );
-		selection.setMaxRows( criteria.getMaxResults() );
-		selection.setTimeout( criteria.getTimeout() );
-		
-		return list(session, new QueryParameters(typeArray, valueArray, null, criteria.getLockModes(), selection) );
-	}
-
-	protected Object getResultColumnOrRow(Object[] row, ResultSet rs, SessionImplementor session)
-		throws SQLException, HibernateException {
-		
-		if ( criteria.isReturnMapEnabled() ) {
-			Map result = new HashMap();
-			for ( int i=0; i<row.length-1; i++ ) {
-				String alias = (String) aliases.get(i);
-				if ( !alias.endsWith("_") ) { //TODO: Incredibly dodgy!! what if the user defines an alias ending in "_"
-					result.put( alias, row[i] );
-				}
-			}
-			result.put( Criteria.ROOT_ALIAS, row[row.length-1] );
-			return result;
-		}
-		else {
-			return row[ row.length-1 ];
-		}
-	}
-
-	protected int getJoinType(
-		AssociationType type,
-		int config,
-		String path,
-		String table,
-		String[] foreignKeyColumns,
-		SessionFactoryImplementor factory) 
-		throws MappingException {
-		
-		if ( criteria.isJoin(path) ) {
-			return JoinFragment.INNER_JOIN;
-		}
-		else {
-			FetchMode fm = criteria.getFetchMode(path);
-			if ( fm==null || fm==FetchMode.DEFAULT ) {
-				return super.getJoinType(type, config, path, table, foreignKeyColumns, factory);
-			}
-			else {
-				return (fm==FetchMode.EAGER) ? JoinFragment.LEFT_OUTER_JOIN : -1;
-			}
-		}
-	}
-
-	/**
-	 * Use the discriminator, to narrow the select to instances
-	 * of the queried subclass.
-	 */
-	protected String getWhereFragment() throws MappingException {
-		return ( (Queryable) getPersister() ).queryWhereFragment( getAlias(), true, true );
-	}
-
-	protected String generateTableAlias(String tableName, int n, String path, boolean isLinkTable) {
-		if (!isLinkTable) {
-			String userDefinedAlias = criteria.getAlias(path);
-			if (userDefinedAlias!=null) {
-				aliases.add(userDefinedAlias); //very dodgy: depends upon the superclass not reordering things!
-				return userDefinedAlias;
-			}
-		}
-		String generatedAlias = super.generateTableAlias(tableName, n, path, isLinkTable);
-		aliases.add(generatedAlias);
-		return generatedAlias;
-	}
-
-	protected String generateRootAlias(String tableName) {
-		return Criteria.ROOT_ALIAS;
-	}
-	
-	public Set getQuerySpaces() {
-		return querySpaces;
-	}
-
-	protected void addToPropertySpaces(Serializable space) {
-		querySpaces.add(space);
-	}
-
-	protected String applyLocks(String sqlSelectString, Map lockModes, Dialect dialect) throws QueryException {
-		if ( lockModes==null || lockModes.size()==0 ) {
-			return sqlSelectString;
-		}
-		else {
-			return sqlSelectString + new ForUpdateFragment(lockModes).toFragmentString(dialect);
-
-		}
-	}
-
-	protected LockMode[] getLockModes(Map lockModes) {
-		int size = aliases.size();
-		LockMode[] lockModesArray = new LockMode[size+1];
-		LockMode lm = (LockMode) lockModes.get(Criteria.ROOT_ALIAS);
-		lockModesArray[size] = lm==null ? LockMode.NONE : lm;
-		for ( int i=0; i<size; i++ ) {
-			lm = (LockMode) lockModes.get( aliases.get(i) );
-			lockModesArray[i] = lm==null ? LockMode.NONE : lm;
-		}
-		return lockModesArray;
-	}
-
-}
+//$Id: CriteriaLoader.java,v 1.8.2.19 2003/11/09 04:20:41 oneovthafew Exp $
+package net.sf.hibernate.loader;
+
+import java.io.Serializable;
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import net.sf.hibernate.Criteria;
+import net.sf.hibernate.FetchMode;
+import net.sf.hibernate.HibernateException;
+import net.sf.hibernate.LockMode;
+import net.sf.hibernate.MappingException;
+import net.sf.hibernate.QueryException;
+import net.sf.hibernate.dialect.Dialect;
+import net.sf.hibernate.engine.QueryParameters;
+import net.sf.hibernate.engine.RowSelection;
+import net.sf.hibernate.engine.SessionFactoryImplementor;
+import net.sf.hibernate.engine.SessionImplementor;
+import net.sf.hibernate.engine.TypedValue;
+import net.sf.hibernate.expression.Order;
+import net.sf.hibernate.impl.CriteriaImpl;
+import net.sf.hibernate.impl.SessionImpl;
+import net.sf.hibernate.persister.Loadable;
+import net.sf.hibernate.persister.Queryable;
+import net.sf.hibernate.sql.ForUpdateFragment;
+import net.sf.hibernate.sql.JoinFragment;
+import net.sf.hibernate.type.AssociationType;
+import net.sf.hibernate.type.Type;
+import net.sf.hibernate.util.ArrayHelper;
+
+//TODO: this class depends directly upon CriteriaImpl, in the impl package ... add a CriteriaImplementor interface
+/**
+ * A <tt>Loader</tt> for <tt>Criteria</tt> queries. Note that criteria queries are
+ * more like multi-object <tt>load()</tt>s than like HQL queries.
+ * 
+ * @author Gavin King
+ */
+public class CriteriaLoader extends AbstractEntityLoader {
+	
+	/**
+	 * Return a count for this critia by altering the select
+	 * statement to be a select count(*) with no order bys
+	 * @param impl the Session
+	 * @return
+	 */
+	public long count(SessionImpl impl)
+		throws HibernateException, SQLException
+	{
+		List values = new ArrayList();
+		List types = new ArrayList();
+		fillValuesAndTypes(impl, values, types);
+		Object[] valueArray = values.toArray();
+		Type[] typeArray = (Type[]) types.toArray(ArrayHelper.EMPTY_TYPE_ARRAY);
+		
+		select.setSelectClause(" count(*) ");
+		select.setOrderByClause("");
+		
+		PreparedStatement ps = null;
+		try
+		{
+			ps = prepareQueryStatement(
+				select.toStatementString(), 
+				new QueryParameters(typeArray, valueArray, null, null, buildRowSelection()),
+				false,
+				impl);
+			ResultSet rs = impl.getBatcher().getResultSet(ps);
+			if (rs.next())
+			{
+				return rs.getLong(1);
+			}
+			else
+			{
+				return 0;
+			}
+		}
+		finally
+		{
+			impl.getBatcher().closeStatement(ps);	
+		}
+	}
+	
+	private CriteriaImpl criteria;
+	private Set querySpaces = new HashSet();
+	private final List aliases = new ArrayList();
+	
+	public CriteriaLoader(Loadable persister, SessionFactoryImplementor factory, CriteriaImpl criteria) throws HibernateException {
+		super(persister, factory);
+		this.criteria = criteria;
+		
+		addAllToPropertySpaces( persister.getPropertySpaces() );
+
+		StringBuffer condition = new StringBuffer(30);
+		Iterator iter = criteria.iterateExpressionEntries();
+		if ( !iter.hasNext() ) condition.append("1=1"); //TODO: fix this ugliness
+		while ( iter.hasNext() ) {
+			CriteriaImpl.CriterionEntry ee = (CriteriaImpl.CriterionEntry) iter.next();
+			String sqlString = ee.getCriterion().toSqlString(
+				factory, 
+				criteria.getPersistentClass( ee.getAlias() ), 
+				ee.getAlias(),
+				criteria.getAliasClasses()
+			);
+			condition.append(sqlString);
+			if ( iter.hasNext() ) condition.append(" and ");
+		}
+		
+		StringBuffer orderBy = new StringBuffer(30);
+		iter = criteria.iterateOrderings();
+		while ( iter.hasNext() ) {
+			Order ord = (Order) iter.next();
+			orderBy.append( ord.toSqlString( factory, criteria.getCriteriaClass(), getAlias() ) );
+			if ( iter.hasNext() ) orderBy.append(", ");
+		}
+		
+		renderStatement( condition.toString(), orderBy.toString(), factory );
+		
+		postInstantiate();
+
+	}
+	
+
+	public List list(SessionImplementor session) throws HibernateException, SQLException {
+		List values = new ArrayList();
+		List types = new ArrayList();
+		fillValuesAndTypes(session, values, types);
+		Object[] valueArray = values.toArray();
+		Type[] typeArray = (Type[]) types.toArray(ArrayHelper.EMPTY_TYPE_ARRAY);
+		
+		RowSelection selection = buildRowSelection();
+		
+		return list(session, new QueryParameters(typeArray, valueArray, null, criteria.getLockModes(), selection) );
+	}
+
+	private RowSelection buildRowSelection()
+	{
+		RowSelection selection = new RowSelection();
+		selection.setFirstRow( criteria.getFirstResult() );
+		selection.setMaxRows( criteria.getMaxResults() );
+		selection.setTimeout( criteria.getTimeout() );
+		return selection;
+	}
+
+	private void fillValuesAndTypes(
+		SessionImplementor session,
+		List values,
+		List types)
+		throws HibernateException
+	{
+		Iterator iter = criteria.iterateExpressionEntries();
+		while ( iter.hasNext() ) {
+			CriteriaImpl.CriterionEntry ce = (CriteriaImpl.CriterionEntry) iter.next();
+			TypedValue[] tv = ce.getCriterion().getTypedValues( 
+				session.getFactory(), 
+				(Class) criteria.getCriteriaClass( ce.getAlias() ),
+				criteria.getAliasClasses()
+			);
+			for ( int i=0; i<tv.length; i++ ) {
+				values.add( tv[i].getValue() );
+				types.add( tv[i].getType() );
+			}
+		}
+	}
+	
+	protected Object getResultColumnOrRow(Object[] row, ResultSet rs, SessionImplementor session)
+		throws SQLException, HibernateException {
+		
+		if ( criteria.isReturnMapEnabled() ) {
+			Map result = new HashMap();
+			for ( int i=0; i<row.length-1; i++ ) {
+				String alias = (String) aliases.get(i);
+				if ( !alias.endsWith("_") ) { //TODO: Incredibly dodgy!! what if the user defines an alias ending in "_"
+					result.put( alias, row[i] );
+				}
+			}
+			result.put( Criteria.ROOT_ALIAS, row[row.length-1] );
+			return result;
+		}
+		else {
+			return row[ row.length-1 ];
+		}
+	}
+
+	protected int getJoinType(
+		AssociationType type,
+		int config,
+		String path,
+		String table,
+		String[] foreignKeyColumns,
+		SessionFactoryImplementor factory) 
+		throws MappingException {
+		
+		if ( criteria.isJoin(path) ) {
+			return JoinFragment.INNER_JOIN;
+		}
+		else {
+			FetchMode fm = criteria.getFetchMode(path);
+			if ( fm==null || fm==FetchMode.DEFAULT ) {
+				return super.getJoinType(type, config, path, table, foreignKeyColumns, factory);
+			}
+			else {
+				return (fm==FetchMode.EAGER) ? JoinFragment.LEFT_OUTER_JOIN : -1;
+			}
+		}
+	}
+
+	/**
+	 * Use the discriminator, to narrow the select to instances
+	 * of the queried subclass.
+	 */
+	protected String getWhereFragment() throws MappingException {
+		return ( (Queryable) getPersister() ).queryWhereFragment( getAlias(), true, true );
+	}
+
+	protected String generateTableAlias(String tableName, int n, String path, boolean isLinkTable) {
+		if (!isLinkTable) {
+			String userDefinedAlias = criteria.getAlias(path);
+			if (userDefinedAlias!=null) {
+				aliases.add(userDefinedAlias); //very dodgy: depends upon the superclass not reordering things!
+				return userDefinedAlias;
+			}
+		}
+		String generatedAlias = super.generateTableAlias(tableName, n, path, isLinkTable);
+		aliases.add(generatedAlias);
+		return generatedAlias;
+	}
+
+	protected String generateRootAlias(String tableName) {
+		return Criteria.ROOT_ALIAS;
+	}
+	
+	public Set getQuerySpaces() {
+		return querySpaces;
+	}
+
+	protected void addToPropertySpaces(Serializable space) {
+		querySpaces.add(space);
+	}
+
+	protected String applyLocks(String sqlSelectString, Map lockModes, Dialect dialect) throws QueryException {
+		if ( lockModes==null || lockModes.size()==0 ) {
+			return sqlSelectString;
+		}
+		else {
+			return sqlSelectString + new ForUpdateFragment(lockModes).toFragmentString(dialect);
+
+		}
+	}
+
+	protected LockMode[] getLockModes(Map lockModes) {
+		int size = aliases.size();
+		LockMode[] lockModesArray = new LockMode[size+1];
+		LockMode lm = (LockMode) lockModes.get(Criteria.ROOT_ALIAS);
+		lockModesArray[size] = lm==null ? LockMode.NONE : lm;
+		for ( int i=0; i<size; i++ ) {
+			lm = (LockMode) lockModes.get( aliases.get(i) );
+			lockModesArray[i] = lm==null ? LockMode.NONE : lm;
+		}
+		return lockModesArray;
+	}
+
+}
