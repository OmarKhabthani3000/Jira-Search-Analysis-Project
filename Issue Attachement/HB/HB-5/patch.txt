Index: hibernate-2.0/src/net/sf/hibernate/collection/CollectionPersister.java
diff -c hibernate-2.0/src/net/sf/hibernate/collection/CollectionPersister.java:1.1.1.2 hibernate-2.0/src/net/sf/hibernate/collection/CollectionPersister.java:1.3
*** hibernate-2.0/src/net/sf/hibernate/collection/CollectionPersister.java:1.1.1.2	Tue Apr 22 14:28:24 2003
--- hibernate-2.0/src/net/sf/hibernate/collection/CollectionPersister.java	Tue Apr 22 16:33:27 2003
***************
*** 1,4 ****
! //$Id: CollectionPersister.java,v 1.1.1.2 2003/04/22 19:28:24 paulsenj Exp $
  package net.sf.hibernate.collection;
  
  import java.io.Serializable;
--- 1,4 ----
! //$Id: CollectionPersister.java,v 1.3 2003/04/22 21:33:27 paulsenj Exp $
  package net.sf.hibernate.collection;
  
  import java.io.Serializable;
***************
*** 37,42 ****
--- 37,43 ----
  import net.sf.hibernate.util.ArrayHelper;
  import net.sf.hibernate.util.JDBCExceptionReporter;
  import net.sf.hibernate.util.StringHelper;
+ import net.sf.hibernate.util.TypeHelper;
  
  import org.apache.commons.logging.Log;
  import org.apache.commons.logging.LogFactory;
***************
*** 49,55 ****
   */
  
  public final class CollectionPersister implements CollectionMetadata {
- 	
  	//private final String sqlSelectString;
  	private final String sqlDeleteString;
  	private final String sqlInsertRowString;
--- 50,55 ----
***************
*** 64,74 ****
--- 64,78 ----
  	private final Type indexType;
  	private final Type elementType;
  	private final String[] keyColumnNames;
+   private final Type[] keyColumnTypes;
  	private final String[] indexColumnNames;
+   private final Type[] indexColumnTypes;
  	private final String[] elementColumnNames;
+   private final Type[] elementColumnTypes;
  	private final String[] unquotedIndexColumnNames;
  	private final String[] unquotedElementColumnNames;
  	private final String[] rowSelectColumnNames;
+   private final Type[] rowSelectColumnTypes;
  	private final String[] indexColumnAliases;
  	private final String[] elementColumnAliases;
  	private final Type rowSelectType;
***************
*** 85,129 ****
  	private final int enableJoinedFetch;
  	private final Class ownerClass;
  	//private final boolean isSorted;
- 	
  	private final CollectionInitializer loader;
! 	
  	private final String role;
  	//private final SessionFactoryImplementor factory;
! 	
  	private static final Log log = LogFactory.getLog(CollectionPersister.class);
! 	
! 	public CollectionPersister(Collection collection, Configuration datastore, SessionFactoryImplementor factory) 
  		throws MappingException, CacheException {
! 		
  		collectionType = collection.getType();
  		role = collection.getRole();
  		ownerClass = collection.getOwnerClass();
! 		
  		sqlOrderByString = collection.getOrderBy();
  		hasOrder = sqlOrderByString!=null;
  		sqlWhereString = collection.getWhere();
  		hasWhere = sqlWhereString!=null;
! 		
  		cache=collection.getCache();
! 		
  		keyType = collection.getKey().getType();
  		Iterator iter = collection.getKey().getColumnIterator();
  		int span = collection.getKey().getColumnSpan();
  		keyColumnNames = new String[span];
  		int k=0;
  		while ( iter.hasNext() ) {
  			Column col = ( (Column) iter.next() );
  			keyColumnNames[k] = col.getName();
  			k++;
  		}
- 		
  		//isSet = collection.isSet();
  		//isSorted = collection.isSorted();
  		isOneToMany = collection.isOneToMany();
  		primitiveArray = collection.isPrimitiveArray();
  		array = collection.isArray();
! 		
  		Table table;
  		if (isOneToMany) {
  			EntityType type = collection.getOneToMany().getType();
--- 89,134 ----
  	private final int enableJoinedFetch;
  	private final Class ownerClass;
  	//private final boolean isSorted;
  	private final CollectionInitializer loader;
! 
  	private final String role;
  	//private final SessionFactoryImplementor factory;
! 
  	private static final Log log = LogFactory.getLog(CollectionPersister.class);
! 
! 	public CollectionPersister(Collection collection, Configuration datastore, SessionFactoryImplementor factory)
  		throws MappingException, CacheException {
! 
  		collectionType = collection.getType();
  		role = collection.getRole();
  		ownerClass = collection.getOwnerClass();
! 
  		sqlOrderByString = collection.getOrderBy();
  		hasOrder = sqlOrderByString!=null;
  		sqlWhereString = collection.getWhere();
  		hasWhere = sqlWhereString!=null;
! 
  		cache=collection.getCache();
! 
  		keyType = collection.getKey().getType();
  		Iterator iter = collection.getKey().getColumnIterator();
  		int span = collection.getKey().getColumnSpan();
  		keyColumnNames = new String[span];
+     // construct array of key column types
+     keyColumnTypes = new Type[span];
  		int k=0;
  		while ( iter.hasNext() ) {
  			Column col = ( (Column) iter.next() );
  			keyColumnNames[k] = col.getName();
+       keyColumnTypes[k] = col.getType();
  			k++;
  		}
  		//isSet = collection.isSet();
  		//isSorted = collection.isSorted();
  		isOneToMany = collection.isOneToMany();
  		primitiveArray = collection.isPrimitiveArray();
  		array = collection.isArray();
! 
  		Table table;
  		if (isOneToMany) {
  			EntityType type = collection.getOneToMany().getType();
***************
*** 138,175 ****
  			table = collection.getTable();
  			elementType = collection.getElement().getType();
  			span = collection.getElement().getColumnSpan();
! 			enableJoinedFetch = collection.getElement().getOuterJoinFetchSetting();			
  			iter = collection.getElement().getColumnIterator();
  		}
  
  		qualifiedTableName = table.getQualifiedName( factory.getDefaultSchema() );
  		String[] aliases = new String[span];
  		elementColumnNames = new String[span];
  		int j=0;
  		while ( iter.hasNext() ) {
  			Column col = (Column) iter.next();
  			elementColumnNames[j] = col.getName();
  			aliases[j] = col.getAlias();
  			j++;
  		}
! 		
  		Alias alias = new Alias("__");
  		elementColumnAliases = alias.toAliasStrings(aliases);
  		unquotedElementColumnNames = StringHelper.unQuote(elementColumnAliases);
! 		
! 		
  		if ( hasIndex = collection.isIndexed() ) {
  			IndexedCollection indexedMap = (IndexedCollection) collection;
  			indexType = indexedMap.getIndex().getType();
  			int indexSpan = indexedMap.getIndex().getColumnSpan();
  			iter = indexedMap.getIndex().getColumnIterator();
  			indexColumnNames = new String[indexSpan];
  			int i=0;
  			while ( iter.hasNext() ) {
  				Column indexCol = (Column) iter.next();
! 				indexColumnNames[i++] = indexCol.getName();
  			}
  			rowSelectColumnNames = indexColumnNames;
  			rowSelectType = indexType;
  			indexColumnAliases = alias.toAliasStrings(indexColumnNames);
  			unquotedIndexColumnNames = StringHelper.unQuote(indexColumnAliases);
--- 143,187 ----
  			table = collection.getTable();
  			elementType = collection.getElement().getType();
  			span = collection.getElement().getColumnSpan();
! 			enableJoinedFetch = collection.getElement().getOuterJoinFetchSetting();
  			iter = collection.getElement().getColumnIterator();
  		}
  
  		qualifiedTableName = table.getQualifiedName( factory.getDefaultSchema() );
  		String[] aliases = new String[span];
  		elementColumnNames = new String[span];
+     // construct array of element column types
+     elementColumnTypes = new Type[span];
  		int j=0;
  		while ( iter.hasNext() ) {
  			Column col = (Column) iter.next();
  			elementColumnNames[j] = col.getName();
+       elementColumnTypes[j] = col.getType();
  			aliases[j] = col.getAlias();
  			j++;
  		}
! 
  		Alias alias = new Alias("__");
  		elementColumnAliases = alias.toAliasStrings(aliases);
  		unquotedElementColumnNames = StringHelper.unQuote(elementColumnAliases);
! 
! 
  		if ( hasIndex = collection.isIndexed() ) {
  			IndexedCollection indexedMap = (IndexedCollection) collection;
  			indexType = indexedMap.getIndex().getType();
  			int indexSpan = indexedMap.getIndex().getColumnSpan();
  			iter = indexedMap.getIndex().getColumnIterator();
  			indexColumnNames = new String[indexSpan];
+       // construct array of index column types
+       indexColumnTypes = new Type[indexSpan];
  			int i=0;
  			while ( iter.hasNext() ) {
  				Column indexCol = (Column) iter.next();
! 				indexColumnNames[i] = indexCol.getName();
!         indexColumnTypes[i++] = indexCol.getType();
  			}
  			rowSelectColumnNames = indexColumnNames;
+       rowSelectColumnTypes = indexColumnTypes;
  			rowSelectType = indexType;
  			indexColumnAliases = alias.toAliasStrings(indexColumnNames);
  			unquotedIndexColumnNames = StringHelper.unQuote(indexColumnAliases);
***************
*** 177,188 ****
  		else {
  			indexType = null;
  			indexColumnNames = null;
  			indexColumnAliases = null;
  			unquotedIndexColumnNames = null;
  			rowSelectColumnNames = elementColumnNames;
  			rowSelectType = elementType;
  		}
! 		
  		//sqlSelectString = sqlSelectString();
  		sqlDeleteString = generateDeleteString();
  		//sqlSelectRowString = sqlSelectRowString();
--- 189,202 ----
  		else {
  			indexType = null;
  			indexColumnNames = null;
+       indexColumnTypes = null;
  			indexColumnAliases = null;
  			unquotedIndexColumnNames = null;
  			rowSelectColumnNames = elementColumnNames;
+       rowSelectColumnTypes = elementColumnTypes;
  			rowSelectType = elementType;
  		}
! 
  		//sqlSelectString = sqlSelectString();
  		sqlDeleteString = generateDeleteString();
  		//sqlSelectRowString = sqlSelectRowString();
***************
*** 190,198 ****
  		sqlUpdateRowString = generateUpdateRowString();
  		sqlDeleteRowString = generateDeleteRowString();
  		isLazy = collection.isLazy();
! 		
  		isInverse = collection.isInverse();
! 		
  		if ( collection.isArray() ) {
  			elementClass = ( (net.sf.hibernate.mapping.Array) collection ).getElementClass();
  		}
--- 204,212 ----
  		sqlUpdateRowString = generateUpdateRowString();
  		sqlDeleteRowString = generateDeleteRowString();
  		isLazy = collection.isLazy();
! 
  		isInverse = collection.isInverse();
! 
  		if ( collection.isArray() ) {
  			elementClass = ( (net.sf.hibernate.mapping.Array) collection ).getElementClass();
  		}
***************
*** 200,227 ****
  			// for non-arrays, we don't need to know the element class
  			elementClass = null; //elementType.returnedClass();
  		}
! 		
  		loader = createCollectionQuery(factory);
! 		
  	}
! 	
  	public CollectionInitializer getInitializer() {
  		return loader;
  	}
! 	
  	private CollectionInitializer createCollectionQuery(SessionFactoryImplementor factory) throws MappingException {
  		return isOneToMany() ?
  		(CollectionInitializer) new OneToManyLoader(this, factory) :
  		(CollectionInitializer) new CollectionLoader(this, factory);
  	}
! 	
  	public void cache(Serializable id, PersistentCollection coll, SessionImplementor s) throws HibernateException {
  		if (cache!=null) {
  			if ( log.isDebugEnabled() ) log.debug("Caching collection: " + role + '#' + id);
  			cache.put( id, coll.disassemble(this), s.getTimestamp() );
  		}
  	}
! 	
  	public PersistentCollection getCachedCollection(Serializable id, Object owner, SessionImplementor s) throws HibernateException {
  		if (cache==null) {
  			return null;
--- 214,241 ----
  			// for non-arrays, we don't need to know the element class
  			elementClass = null; //elementType.returnedClass();
  		}
! 
  		loader = createCollectionQuery(factory);
! 
  	}
! 
  	public CollectionInitializer getInitializer() {
  		return loader;
  	}
! 
  	private CollectionInitializer createCollectionQuery(SessionFactoryImplementor factory) throws MappingException {
  		return isOneToMany() ?
  		(CollectionInitializer) new OneToManyLoader(this, factory) :
  		(CollectionInitializer) new CollectionLoader(this, factory);
  	}
! 
  	public void cache(Serializable id, PersistentCollection coll, SessionImplementor s) throws HibernateException {
  		if (cache!=null) {
  			if ( log.isDebugEnabled() ) log.debug("Caching collection: " + role + '#' + id);
  			cache.put( id, coll.disassemble(this), s.getTimestamp() );
  		}
  	}
! 
  	public PersistentCollection getCachedCollection(Serializable id, Object owner, SessionImplementor s) throws HibernateException {
  		if (cache==null) {
  			return null;
***************
*** 237,250 ****
  			}
  		}
  	}
! 	
  	public void softlock(Serializable id) throws CacheException {
  		if (cache!=null) cache.lock(id);
  	}
  	public void releaseSoftlock(Serializable id) throws CacheException {
  		if (cache!=null) cache.release(id);
  	}
! 	
  	private static final java.util.Set keywords = new HashSet();
  	static {
  		keywords.add("and");
--- 251,264 ----
  			}
  		}
  	}
! 
  	public void softlock(Serializable id) throws CacheException {
  		if (cache!=null) cache.lock(id);
  	}
  	public void releaseSoftlock(Serializable id) throws CacheException {
  		if (cache!=null) cache.release(id);
  	}
! 
  	private static final java.util.Set keywords = new HashSet();
  	static {
  		keywords.add("and");
***************
*** 254,260 ****
  		keywords.add("is");
  		keywords.add("null");
  	}
! 	
  	public String getSQLWhereString(String alias) {
  		// takes the where condition provided in the mapping
  		// attribute and interpolates the alias
--- 268,274 ----
  		keywords.add("is");
  		keywords.add("null");
  	}
! 
  	public String getSQLWhereString(String alias) {
  		// takes the where condition provided in the mapping
  		// attribute and interpolates the alias
***************
*** 272,278 ****
  		}
  		return result.toString();
  	}
! 	
  	public String getSQLOrderByString(String alias) {
  		// takes order by clause provided in the mapping
  		// attribute and interpolates the alias
--- 286,292 ----
  		}
  		return result.toString();
  	}
! 
  	public String getSQLOrderByString(String alias) {
  		// takes order by clause provided in the mapping
  		// attribute and interpolates the alias
***************
*** 287,337 ****
  		}
  		return result.toString();
  	}
! 	
  	public int enableJoinedFetch() {
  		return enableJoinedFetch;
  	}
! 	
  	public boolean hasOrdering() {
  		return hasOrder;
  	}
! 	
  	public boolean hasWhere() {
! 		return hasWhere; 
  	}
! 	
  	private String getSQLDeleteString() {
  		return sqlDeleteString;
  	}
! 	
  	private String getSQLInsertRowString() {
  		return sqlInsertRowString;
  	}
! 	
  	private String getSQLUpdateRowString() {
  		return sqlUpdateRowString;
  	}
! 	
  	private String getSQLDeleteRowString() {
  		return sqlDeleteRowString;
  	}
! 	
  	public Type getKeyType() {
  		return keyType;
  	}
! 	
  	public Type getIndexType() {
  		return indexType;
  	}
! 	
  	public Type getElementType() {
  		return elementType;
  	}
! 	
  	public Class getElementClass() { //needed by arrays
  		return elementClass;
  	}
! 	
  	public Object readElement(ResultSet rs, Object owner, SessionImplementor session) throws HibernateException, SQLException {
  		Object element = getElementType().nullSafeGet(rs, unquotedElementColumnNames, session, owner);
  		return element;
--- 301,351 ----
  		}
  		return result.toString();
  	}
! 
  	public int enableJoinedFetch() {
  		return enableJoinedFetch;
  	}
! 
  	public boolean hasOrdering() {
  		return hasOrder;
  	}
! 
  	public boolean hasWhere() {
! 		return hasWhere;
  	}
! 
  	private String getSQLDeleteString() {
  		return sqlDeleteString;
  	}
! 
  	private String getSQLInsertRowString() {
  		return sqlInsertRowString;
  	}
! 
  	private String getSQLUpdateRowString() {
  		return sqlUpdateRowString;
  	}
! 
  	private String getSQLDeleteRowString() {
  		return sqlDeleteRowString;
  	}
! 
  	public Type getKeyType() {
  		return keyType;
  	}
! 
  	public Type getIndexType() {
  		return indexType;
  	}
! 
  	public Type getElementType() {
  		return elementType;
  	}
! 
  	public Class getElementClass() { //needed by arrays
  		return elementClass;
  	}
! 
  	public Object readElement(ResultSet rs, Object owner, SessionImplementor session) throws HibernateException, SQLException {
  		Object element = getElementType().nullSafeGet(rs, unquotedElementColumnNames, session, owner);
  		return element;
***************
*** 341,376 ****
  		if (index==null) throw new HibernateException("null index column for collection: " + role);
  		return index;
  	}
! 	
  	public void writeElement(PreparedStatement st, Object elt, boolean writeOrder, SessionImplementor session)
  	throws HibernateException, SQLException {
  		getElementType().nullSafeSet(st, elt, 1+(writeOrder?0:keyColumnNames.length+(hasIndex?indexColumnNames.length:0)), session);
  	}
! 	
  	public void writeIndex(PreparedStatement st, Object idx, boolean writeOrder, SessionImplementor session)
  	throws HibernateException, SQLException {
  		getIndexType().nullSafeSet(st, idx, 1+keyColumnNames.length + (writeOrder?elementColumnNames.length:0), session);
  	}
! 	
  	private void writeRowSelect(PreparedStatement st, Object idx, SessionImplementor session)
  	throws HibernateException, SQLException {
  		rowSelectType.nullSafeSet(st, idx, 1+keyColumnNames.length, session);
  	}
! 	
  	public void writeKey(PreparedStatement st, Serializable id, boolean writeOrder, SessionImplementor session)
  	throws HibernateException, SQLException {
  		if (id==null) throw new NullPointerException("null key for collection: " + role);  //an assertion
  		getKeyType().nullSafeSet(st, id, 1+(writeOrder?elementColumnNames.length:0), session);
  	}
! 	
  	public boolean isPrimitiveArray() {
  		return primitiveArray;
  	}
! 	
  	public boolean isArray() {
  		return array;
  	}
! 	
  	/**
  	 * Generate a list of collection index and element columns
  	 */
--- 355,390 ----
  		if (index==null) throw new HibernateException("null index column for collection: " + role);
  		return index;
  	}
! 
  	public void writeElement(PreparedStatement st, Object elt, boolean writeOrder, SessionImplementor session)
  	throws HibernateException, SQLException {
  		getElementType().nullSafeSet(st, elt, 1+(writeOrder?0:keyColumnNames.length+(hasIndex?indexColumnNames.length:0)), session);
  	}
! 
  	public void writeIndex(PreparedStatement st, Object idx, boolean writeOrder, SessionImplementor session)
  	throws HibernateException, SQLException {
  		getIndexType().nullSafeSet(st, idx, 1+keyColumnNames.length + (writeOrder?elementColumnNames.length:0), session);
  	}
! 
  	private void writeRowSelect(PreparedStatement st, Object idx, SessionImplementor session)
  	throws HibernateException, SQLException {
  		rowSelectType.nullSafeSet(st, idx, 1+keyColumnNames.length, session);
  	}
! 
  	public void writeKey(PreparedStatement st, Serializable id, boolean writeOrder, SessionImplementor session)
  	throws HibernateException, SQLException {
  		if (id==null) throw new NullPointerException("null key for collection: " + role);  //an assertion
  		getKeyType().nullSafeSet(st, id, 1+(writeOrder?elementColumnNames.length:0), session);
  	}
! 
  	public boolean isPrimitiveArray() {
  		return primitiveArray;
  	}
! 
  	public boolean isArray() {
  		return array;
  	}
! 
  	/**
  	 * Generate a list of collection index and element columns
  	 */
***************
*** 382,400 ****
  		return frag.toFragmentString()
  			.substring(2); //strip leading ','
  	}
! 	
  	/*private String sqlSelectString() {
  		//we no longer have Jon Lipsky's patch to allow a Map from id's to objects
  		SimpleSelect select = new SimpleSelect()
  			.setTableName(qualifiedTableName)
  			.addColumns(elementColumnNames);
  		if (hasIndex) select.addColumns(indexColumnNames);
! 		select.addCondition( keyColumnNames, "=?" );
! 		if (hasWhere) select.addWhereToken( " and " + sqlWhereString );
  		if (hasOrder) select.setOrderBy(sqlOrderByString);
  		return select.toStatementString();
  	}*/
! 	
  	private String generateDeleteString() {
  		if (isOneToMany) {
  			Update update = new Update()
--- 396,414 ----
  		return frag.toFragmentString()
  			.substring(2); //strip leading ','
  	}
! 
  	/*private String sqlSelectString() {
  		//we no longer have Jon Lipsky's patch to allow a Map from id's to objects
  		SimpleSelect select = new SimpleSelect()
  			.setTableName(qualifiedTableName)
  			.addColumns(elementColumnNames);
  		if (hasIndex) select.addColumns(indexColumnNames);
!     // use type placeholders when constructing sql
! 		select.addCondition( keyColumnNames, "=", TypeHelper.getPlaceHolders(keyColumnTypes) );
  		if (hasOrder) select.setOrderBy(sqlOrderByString);
  		return select.toStatementString();
  	}*/
! 
  	private String generateDeleteString() {
  		if (isOneToMany) {
  			Update update = new Update()
***************
*** 402,434 ****
  				.addColumns(keyColumnNames, "null")
  				.setPrimaryKeyColumnNames(keyColumnNames);
  			if (hasIndex) update.addColumns(indexColumnNames, "null");
  			if (hasWhere) update.setWhere(sqlWhereString);
  			return update.toStatementString();
  		}
  		else {
  			Delete delete = new Delete()
  				.setTableName(qualifiedTableName)
! 				.setPrimaryKeyColumnNames(keyColumnNames);
  			if (hasWhere) delete.setWhere(sqlWhereString);
  			return delete.toStatementString();
  		}
  	}
! 	
  	private String generateInsertRowString() {
  		if (isOneToMany) {
  			Update update = new Update()
  				.setTableName(qualifiedTableName)
! 				.addColumns(keyColumnNames);
! 			if (hasIndex) update.addColumns(indexColumnNames);
  			return update.setPrimaryKeyColumnNames(elementColumnNames)
  				.toStatementString();
  		}
  		else {
  			Insert insert = new Insert(null)
  				.setTableName(qualifiedTableName)
! 				.addColumns(keyColumnNames);
! 			if (hasIndex) insert.addColumns(indexColumnNames);
! 			return insert.addColumns(elementColumnNames)
  				.toStatementString();
  		}
  	}
--- 416,455 ----
  				.addColumns(keyColumnNames, "null")
  				.setPrimaryKeyColumnNames(keyColumnNames);
  			if (hasIndex) update.addColumns(indexColumnNames, "null");
+       // use type placeholders when constructing sql
+ 			update.setPrimaryKeyColumnPlaceHolders( TypeHelper.getPlaceHolders(keyColumnTypes))
+ 				.toStatementString();
  			if (hasWhere) update.setWhere(sqlWhereString);
  			return update.toStatementString();
  		}
  		else {
+       // use type placeholders when constructing sql
  			Delete delete = new Delete()
  				.setTableName(qualifiedTableName)
! 				.setPrimaryKeyColumnNames(keyColumnNames)
!         .setPrimaryKeyColumnPlaceHolders( TypeHelper.getPlaceHolders(keyColumnTypes));
  			if (hasWhere) delete.setWhere(sqlWhereString);
  			return delete.toStatementString();
  		}
  	}
! 
  	private String generateInsertRowString() {
  		if (isOneToMany) {
  			Update update = new Update()
  				.setTableName(qualifiedTableName)
!         // use type placeholders when constructing sql
! 				.addColumns(keyColumnNames, TypeHelper.getPlaceHolders(keyColumnTypes));
! 			if (hasIndex) update.addColumns(indexColumnNames, TypeHelper.getPlaceHolders(indexColumnTypes));
  			return update.setPrimaryKeyColumnNames(elementColumnNames)
+         .setPrimaryKeyColumnPlaceHolders( TypeHelper.getPlaceHolders(elementColumnTypes))
  				.toStatementString();
  		}
  		else {
  			Insert insert = new Insert(null)
  				.setTableName(qualifiedTableName)
! 				.addColumns(keyColumnNames, TypeHelper.getPlaceHolders(keyColumnTypes));
! 			if (hasIndex) insert.addColumns(indexColumnNames, TypeHelper.getPlaceHolders(indexColumnTypes));
! 			return insert.addColumns(elementColumnNames, TypeHelper.getPlaceHolders(elementColumnTypes))
  				.toStatementString();
  		}
  	}
***************
*** 438,510 ****
  			return null;
  		}
  		else {
  			return new Update()
  				.setTableName(qualifiedTableName)
! 				.addColumns(elementColumnNames)
  				.setPrimaryKeyColumnNames( ArrayHelper.join(keyColumnNames, rowSelectColumnNames) )
  				.toStatementString();
  		}
  	}
! 	
  	private String generateDeleteRowString() {
  		String[] pkColumns = ArrayHelper.join(keyColumnNames, rowSelectColumnNames);
  		if (isOneToMany) {
  			Update update = new Update()
  				.setTableName(qualifiedTableName)
  				.addColumns(keyColumnNames, "null");
  			if (hasIndex) update.addColumns(indexColumnNames, "null");
  			return update.setPrimaryKeyColumnNames(pkColumns)
  				.toStatementString();
  		}
  		else {
  			return new Delete()
  				.setTableName(qualifiedTableName)
  				.setPrimaryKeyColumnNames(pkColumns)
  				.toStatementString();
  		}
  	}
! 	
! 	
  	public String[] getIndexColumnNames() {
  		return indexColumnNames;
  	}
! 	
  	public String[] getElementColumnNames() {
  		return elementColumnNames;
  	}
! 	
  	public String[] getKeyColumnNames() {
  		return keyColumnNames;
  	}
! 	
  	public boolean isOneToMany() {
  		return isOneToMany;
  	}
! 	
  	public boolean hasIndex() {
  		return hasIndex;
  	}
! 	
  	public boolean isLazy() { return isLazy; }
! 	
  	public boolean isInverse() {
  		return isInverse;
  	}
! 	
  	public String getQualifiedTableName() {
  		return qualifiedTableName;
  	}
! 	
  	public final void remove(Serializable id, SessionImplementor session) throws SQLException, HibernateException {
! 		
  		if ( !isInverse ) {
! 			
  			if ( log.isDebugEnabled() ) log.debug("Deleting collection: " + role + "#" + id);
! 			
  			// Remove all the old entries
! 			
  			PreparedStatement st = session.getBatcher().prepareBatchStatement( getSQLDeleteString() );
! 			
  			try {
  				writeKey(st, id, false, session);
  				session.getBatcher().addToBatch(-1);
--- 459,541 ----
  			return null;
  		}
  		else {
+       // use type placeholders when constructing sql
  			return new Update()
  				.setTableName(qualifiedTableName)
! 				.addColumns(elementColumnNames, TypeHelper.getPlaceHolders(elementColumnTypes))
  				.setPrimaryKeyColumnNames( ArrayHelper.join(keyColumnNames, rowSelectColumnNames) )
+         .setPrimaryKeyColumnPlaceHolders( TypeHelper.getPlaceHolders(TypeHelper.join(keyColumnTypes, rowSelectColumnTypes)))
  				.toStatementString();
  		}
  	}
! 
  	private String generateDeleteRowString() {
+     // use type placeholders when constructing sql
  		String[] pkColumns = ArrayHelper.join(keyColumnNames, rowSelectColumnNames);
+     Type[] pkColumnTypes = TypeHelper.join(keyColumnTypes, rowSelectColumnTypes);
  		if (isOneToMany) {
  			Update update = new Update()
  				.setTableName(qualifiedTableName)
  				.addColumns(keyColumnNames, "null");
  			if (hasIndex) update.addColumns(indexColumnNames, "null");
  			return update.setPrimaryKeyColumnNames(pkColumns)
+         .setPrimaryKeyColumnPlaceHolders( TypeHelper.getPlaceHolders(pkColumnTypes) )
  				.toStatementString();
  		}
  		else {
  			return new Delete()
  				.setTableName(qualifiedTableName)
  				.setPrimaryKeyColumnNames(pkColumns)
+         .setPrimaryKeyColumnPlaceHolders( TypeHelper.getPlaceHolders(pkColumnTypes) )
  				.toStatementString();
  		}
  	}
! 
! 
  	public String[] getIndexColumnNames() {
  		return indexColumnNames;
  	}
! 
  	public String[] getElementColumnNames() {
  		return elementColumnNames;
  	}
! 
  	public String[] getKeyColumnNames() {
  		return keyColumnNames;
  	}
! 
! 	public Type[] getKeyColumnTypes() {
! 		return keyColumnTypes;
! 	}
! 
  	public boolean isOneToMany() {
  		return isOneToMany;
  	}
! 
  	public boolean hasIndex() {
  		return hasIndex;
  	}
! 
  	public boolean isLazy() { return isLazy; }
! 
  	public boolean isInverse() {
  		return isInverse;
  	}
! 
  	public String getQualifiedTableName() {
  		return qualifiedTableName;
  	}
! 
  	public final void remove(Serializable id, SessionImplementor session) throws SQLException, HibernateException {
! 
  		if ( !isInverse ) {
! 
  			if ( log.isDebugEnabled() ) log.debug("Deleting collection: " + role + "#" + id);
! 
  			// Remove all the old entries
! 
  			PreparedStatement st = session.getBatcher().prepareBatchStatement( getSQLDeleteString() );
! 
  			try {
  				writeKey(st, id, false, session);
  				session.getBatcher().addToBatch(-1);
***************
*** 513,538 ****
  				JDBCExceptionReporter.logExceptions(sqle);
  				throw sqle;
  			}
! 			
  			if ( log.isDebugEnabled() ) log.debug("done deleting collection");
! 			
  		}
! 		
  	}
! 	
  	public final void recreate(PersistentCollection collection, Serializable id, SessionImplementor session)
  	throws SQLException, HibernateException {
! 		
  		if (!isInverse) {
! 			
  			if ( log.isDebugEnabled() ) log.debug("Inserting collection: " + role + "#" + id);
! 			
  			//create all the new entries
  			Iterator entries = collection.entries();
  			if ( entries.hasNext() ) {
! 				
  				PreparedStatement st = session.getBatcher().prepareBatchStatement( getSQLInsertRowString() );
! 				
  				int i=0;
  				try {
  					while ( entries.hasNext() ) {
--- 544,569 ----
  				JDBCExceptionReporter.logExceptions(sqle);
  				throw sqle;
  			}
! 
  			if ( log.isDebugEnabled() ) log.debug("done deleting collection");
! 
  		}
! 
  	}
! 
  	public final void recreate(PersistentCollection collection, Serializable id, SessionImplementor session)
  	throws SQLException, HibernateException {
! 
  		if (!isInverse) {
! 
  			if ( log.isDebugEnabled() ) log.debug("Inserting collection: " + role + "#" + id);
! 
  			//create all the new entries
  			Iterator entries = collection.entries();
  			if ( entries.hasNext() ) {
! 
  				PreparedStatement st = session.getBatcher().prepareBatchStatement( getSQLInsertRowString() );
! 
  				int i=0;
  				try {
  					while ( entries.hasNext() ) {
***************
*** 549,555 ****
  					JDBCExceptionReporter.logExceptions(sqle);
  					throw sqle;
  				}
! 				
  				if ( log.isDebugEnabled() ) log.debug("done inserting collection");
  			}
  			else {
--- 580,586 ----
  					JDBCExceptionReporter.logExceptions(sqle);
  					throw sqle;
  				}
! 
  				if ( log.isDebugEnabled() ) log.debug("done inserting collection");
  			}
  			else {
***************
*** 557,576 ****
  			}
  		}
  	}
! 	
  	public final void deleteRows(PersistentCollection collection, Serializable id, SessionImplementor session)
  	throws SQLException, HibernateException {
! 		
  		if (!isInverse) {
! 			
  			if ( log.isDebugEnabled() ) log.debug("Deleting rows of collection: " + role + "#" + id);
! 			
  			//delete all the deleted entries
  			Iterator entries = collection.getDeletes(elementType);
  			if ( entries.hasNext() ) {
! 				
  				PreparedStatement st = session.getBatcher().prepareBatchStatement( getSQLDeleteRowString() );
! 				
  				try {
  					while ( entries.hasNext() ) {
  						writeKey(st, id, false, session );
--- 588,607 ----
  			}
  		}
  	}
! 
  	public final void deleteRows(PersistentCollection collection, Serializable id, SessionImplementor session)
  	throws SQLException, HibernateException {
! 
  		if (!isInverse) {
! 
  			if ( log.isDebugEnabled() ) log.debug("Deleting rows of collection: " + role + "#" + id);
! 
  			//delete all the deleted entries
  			Iterator entries = collection.getDeletes(elementType);
  			if ( entries.hasNext() ) {
! 
  				PreparedStatement st = session.getBatcher().prepareBatchStatement( getSQLDeleteRowString() );
! 
  				try {
  					while ( entries.hasNext() ) {
  						writeKey(st, id, false, session );
***************
*** 582,588 ****
  					JDBCExceptionReporter.logExceptions(sqle);
  					throw sqle;
  				}
! 				
  				if ( log.isDebugEnabled() ) log.debug("done deleting collection rows");
  			}
  			else {
--- 613,619 ----
  					JDBCExceptionReporter.logExceptions(sqle);
  					throw sqle;
  				}
! 
  				if ( log.isDebugEnabled() ) log.debug("done deleting collection rows");
  			}
  			else {
***************
*** 590,598 ****
  			}
  		}
  	}
! 	
  	private final void update(Serializable id, PersistentCollection collection, SessionImplementor session) throws SQLException, HibernateException {
! 		
  		PreparedStatement st = null;
  		Iterator entries = collection.entries();
  		int i=0;
--- 621,629 ----
  			}
  		}
  	}
! 
  	private final void update(Serializable id, PersistentCollection collection, SessionImplementor session) throws SQLException, HibernateException {
! 
  		PreparedStatement st = null;
  		Iterator entries = collection.entries();
  		int i=0;
***************
*** 613,621 ****
  			throw sqle;
  		}
  	}
! 	
  	private final void updateOneToMany(Serializable id, PersistentCollection collection, SessionImplementor session) throws SQLException, HibernateException {
! 		
  		PreparedStatement rmvst = null;
  		int i=0;
  		Iterator entries = collection.entries();
--- 644,652 ----
  			throw sqle;
  		}
  	}
! 
  	private final void updateOneToMany(Serializable id, PersistentCollection collection, SessionImplementor session) throws SQLException, HibernateException {
! 
  		PreparedStatement rmvst = null;
  		int i=0;
  		Iterator entries = collection.entries();
***************
*** 657,669 ****
  			throw sqle;
  		}
  	}
! 	
  	public final void updateRows(PersistentCollection collection, Serializable id, SessionImplementor session) throws SQLException, HibernateException {
! 		
  		if (!isInverse) {
! 			
  			if ( log.isDebugEnabled() ) log.debug("Updating rows of collection: " + role + "#" + id);
! 			
  			//update all the modified entries
  			if (isOneToMany) {
  				updateOneToMany(id, collection, session);
--- 688,700 ----
  			throw sqle;
  		}
  	}
! 
  	public final void updateRows(PersistentCollection collection, Serializable id, SessionImplementor session) throws SQLException, HibernateException {
! 
  		if (!isInverse) {
! 
  			if ( log.isDebugEnabled() ) log.debug("Updating rows of collection: " + role + "#" + id);
! 
  			//update all the modified entries
  			if (isOneToMany) {
  				updateOneToMany(id, collection, session);
***************
*** 671,688 ****
  			else {
  				update(id, collection, session);
  			}
! 			
  			if ( log.isDebugEnabled() ) log.debug("done updating rows");
  		}
  	}
! 	
  	public final void insertRows(PersistentCollection collection, Serializable id, SessionImplementor session)
  	throws SQLException, HibernateException {
! 		
  		if (!isInverse) {
! 			
  			if ( log.isDebugEnabled() ) log.debug("Inserting rows of collection: " + role + "#" + id);
! 			
  			//insert all the new entries
  			Iterator entries = collection.entries();
  			PreparedStatement st = null;
--- 702,719 ----
  			else {
  				update(id, collection, session);
  			}
! 
  			if ( log.isDebugEnabled() ) log.debug("done updating rows");
  		}
  	}
! 
  	public final void insertRows(PersistentCollection collection, Serializable id, SessionImplementor session)
  	throws SQLException, HibernateException {
! 
  		if (!isInverse) {
! 
  			if ( log.isDebugEnabled() ) log.debug("Inserting rows of collection: " + role + "#" + id);
! 
  			//insert all the new entries
  			Iterator entries = collection.entries();
  			PreparedStatement st = null;
***************
*** 703,730 ****
  				JDBCExceptionReporter.logExceptions(sqle);
  				throw sqle;
  			}
! 			
  			if ( log.isDebugEnabled() ) log.debug("done inserting rows");
  		}
  	}
! 	
! 	
  	public String getRole() {
  		return role;
  	}
! 	
  	public Class getOwnerClass() {
  		return ownerClass;
  	}
! 	
  	/*public boolean isSet() {
  		return isSet;
  	}
! 	
  	public boolean isSorted() {
  		return isSorted;
  	}*/
! 	
  }
  
  
--- 734,761 ----
  				JDBCExceptionReporter.logExceptions(sqle);
  				throw sqle;
  			}
! 
  			if ( log.isDebugEnabled() ) log.debug("done inserting rows");
  		}
  	}
! 
! 
  	public String getRole() {
  		return role;
  	}
! 
  	public Class getOwnerClass() {
  		return ownerClass;
  	}
! 
  	/*public boolean isSet() {
  		return isSet;
  	}
! 
  	public boolean isSorted() {
  		return isSorted;
  	}*/
! 
  }
  
  
Index: hibernate-2.0/src/net/sf/hibernate/loader/CollectionLoader.java
diff -c hibernate-2.0/src/net/sf/hibernate/loader/CollectionLoader.java:1.1.1.2 hibernate-2.0/src/net/sf/hibernate/loader/CollectionLoader.java:1.3
*** hibernate-2.0/src/net/sf/hibernate/loader/CollectionLoader.java:1.1.1.2	Tue Apr 22 14:28:25 2003
--- hibernate-2.0/src/net/sf/hibernate/loader/CollectionLoader.java	Tue Apr 22 16:33:27 2003
***************
*** 1,4 ****
! //$Id: CollectionLoader.java,v 1.1.1.2 2003/04/22 19:28:25 paulsenj Exp $
  package net.sf.hibernate.loader;
  
  import java.io.Serializable;
--- 1,4 ----
! //$Id: CollectionLoader.java,v 1.3 2003/04/22 21:33:27 paulsenj Exp $
  package net.sf.hibernate.loader;
  
  import java.io.Serializable;
***************
*** 17,58 ****
  import net.sf.hibernate.sql.Select;
  import net.sf.hibernate.type.Type;
  import net.sf.hibernate.util.StringHelper;
  
  /**
   * Loads a collection of values or a many-to-many association
   */
  public class CollectionLoader extends OuterJoinLoader implements CollectionInitializer {
! 	
  	private final CollectionPersister collectionPersister;
  	private final Type idType;
! 	
  	public CollectionLoader(CollectionPersister persister, SessionFactoryImplementor session) throws MappingException {
! 		
  		super( session.getDialect() );
! 		
  		idType = persister.getKeyType();
! 		
  		String alias = alias( persister.getQualifiedTableName(), 0 );
! 		
  		String whereString="";
  		if ( persister.hasWhere() ) whereString = " and " + persister.getSQLWhereString(alias);
! 		
  		List associations = walkTree(persister, alias, session);
! 		
  		int joins=associations.size();
  		suffixes = new String[joins];
  		for ( int i=0; i<joins; i++ ) suffixes[i] = Integer.toString(i) + StringHelper.UNDERSCORE;
! 		
  		JoinFragment ojf = outerJoins(associations);
  		Select select = new Select()
! 			.setSelectClause( 
! 				persister.selectClauseFragment(alias) + 
  				( joins==0 ? StringHelper.EMPTY_STRING : ", " + selectString(associations) )
  			)
  			.setFromClause( persister.getQualifiedTableName(), alias )
  			.setWhereClause(
  				new ConditionFragment().setTableAlias(alias)
! 					.setCondition( persister.getKeyColumnNames(), "?" )
  					.toFragmentString() +
  				whereString
  			)
--- 17,60 ----
  import net.sf.hibernate.sql.Select;
  import net.sf.hibernate.type.Type;
  import net.sf.hibernate.util.StringHelper;
+ import net.sf.hibernate.util.TypeHelper;
  
  /**
   * Loads a collection of values or a many-to-many association
   */
  public class CollectionLoader extends OuterJoinLoader implements CollectionInitializer {
! 
  	private final CollectionPersister collectionPersister;
  	private final Type idType;
! 
  	public CollectionLoader(CollectionPersister persister, SessionFactoryImplementor session) throws MappingException {
! 
  		super( session.getDialect() );
! 
  		idType = persister.getKeyType();
! 
  		String alias = alias( persister.getQualifiedTableName(), 0 );
! 
  		String whereString="";
  		if ( persister.hasWhere() ) whereString = " and " + persister.getSQLWhereString(alias);
! 
  		List associations = walkTree(persister, alias, session);
! 
  		int joins=associations.size();
  		suffixes = new String[joins];
  		for ( int i=0; i<joins; i++ ) suffixes[i] = Integer.toString(i) + StringHelper.UNDERSCORE;
! 
  		JoinFragment ojf = outerJoins(associations);
  		Select select = new Select()
! 			.setSelectClause(
! 				persister.selectClauseFragment(alias) +
  				( joins==0 ? StringHelper.EMPTY_STRING : ", " + selectString(associations) )
  			)
  			.setFromClause( persister.getQualifiedTableName(), alias )
  			.setWhereClause(
  				new ConditionFragment().setTableAlias(alias)
!           // use type placeholders when constructing sql
! 					.setCondition( persister.getKeyColumnNames(), TypeHelper.getPlaceHolders(persister.getKeyColumnTypes()) )
  					.toFragmentString() +
  				whereString
  			)
***************
*** 62,81 ****
  			);
  		if ( persister.hasOrdering() ) select.setOrderByClause( persister.getSQLOrderByString(alias) );
  		sql = select.toStatementString();
! 		
  		classPersisters = new Loadable[joins];
  		for ( int i=0; i<joins; i++ ) classPersisters[i] = (Loadable) ( (OuterJoinableAssociation) associations.get(i) ).subpersister;
  		this.collectionPersister = persister;
  	}
! 	
  	protected CollectionPersister getCollectionPersister() {
  		return collectionPersister;
  	}
! 	
  	public void initialize(Serializable id, PersistentCollection collection, Object owner, SessionImplementor session) throws SQLException, HibernateException {
  		loadCollection(session, id, idType, owner, collection);
  	}
! 	
  }
  
  
--- 64,83 ----
  			);
  		if ( persister.hasOrdering() ) select.setOrderByClause( persister.getSQLOrderByString(alias) );
  		sql = select.toStatementString();
! 
  		classPersisters = new Loadable[joins];
  		for ( int i=0; i<joins; i++ ) classPersisters[i] = (Loadable) ( (OuterJoinableAssociation) associations.get(i) ).subpersister;
  		this.collectionPersister = persister;
  	}
! 
  	protected CollectionPersister getCollectionPersister() {
  		return collectionPersister;
  	}
! 
  	public void initialize(Serializable id, PersistentCollection collection, Object owner, SessionImplementor session) throws SQLException, HibernateException {
  		loadCollection(session, id, idType, owner, collection);
  	}
! 
  }
  
  
Index: hibernate-2.0/src/net/sf/hibernate/loader/EntityLoader.java
diff -c hibernate-2.0/src/net/sf/hibernate/loader/EntityLoader.java:1.1.1.1 hibernate-2.0/src/net/sf/hibernate/loader/EntityLoader.java:1.2
*** hibernate-2.0/src/net/sf/hibernate/loader/EntityLoader.java:1.1.1.1	Tue Apr 22 11:17:22 2003
--- hibernate-2.0/src/net/sf/hibernate/loader/EntityLoader.java	Tue Apr 22 13:32:16 2003
***************
*** 1,4 ****
! //$Id: EntityLoader.java,v 1.1.1.1 2003/04/22 16:17:22 paulsenj Exp $
  package net.sf.hibernate.loader;
  
  import java.io.Serializable;
--- 1,4 ----
! //$Id: EntityLoader.java,v 1.2 2003/04/22 18:32:16 paulsenj Exp $
  package net.sf.hibernate.loader;
  
  import java.io.Serializable;
***************
*** 7,12 ****
--- 7,13 ----
  
  import net.sf.hibernate.HibernateException;
  import net.sf.hibernate.MappingException;
+ import net.sf.hibernate.util.TypeHelper;
  import net.sf.hibernate.engine.SessionFactoryImplementor;
  import net.sf.hibernate.engine.SessionImplementor;
  import net.sf.hibernate.persister.Loadable;
***************
*** 17,38 ****
   * Load an entity using outerjoin fetching to fetch associated entities.
   */
  public class EntityLoader extends AbstractEntityLoader implements UniqueEntityLoader {
! 	
  	private final Type[] idType;
! 	
  	public EntityLoader(Loadable persister, SessionFactoryImplementor factory) throws MappingException {
  		super(persister, factory);
! 		
  		idType = new Type[] { persister.getIdentifierType() };
! 		
  		String condition = new ConditionFragment()
  			.setTableAlias(alias)
! 			.setCondition( persister.getIdentifierColumnNames(), "?" )
  			.toFragmentString();
! 		
  		renderStatement(condition, factory);
  	}
! 	
  	public Object load(SessionImplementor session, Serializable id, Object object) throws HibernateException, SQLException {
  		List list = loadEntity(session, new Object[] { id }, idType, object, id, false);
  		if ( list.size()==1 ) {
--- 18,41 ----
   * Load an entity using outerjoin fetching to fetch associated entities.
   */
  public class EntityLoader extends AbstractEntityLoader implements UniqueEntityLoader {
! 
  	private final Type[] idType;
! 
  	public EntityLoader(Loadable persister, SessionFactoryImplementor factory) throws MappingException {
  		super(persister, factory);
! 
  		idType = new Type[] { persister.getIdentifierType() };
! 
! 
!     // use type placeholders when constructing sql
  		String condition = new ConditionFragment()
  			.setTableAlias(alias)
! 			.setCondition( persister.getIdentifierColumnNames(), TypeHelper.getPlaceHolders(persister.getIdentifierColumnTypes()) )
  			.toFragmentString();
! 
  		renderStatement(condition, factory);
  	}
! 
  	public Object load(SessionImplementor session, Serializable id, Object object) throws HibernateException, SQLException {
  		List list = loadEntity(session, new Object[] { id }, idType, object, id, false);
  		if ( list.size()==1 ) {
***************
*** 43,58 ****
  			return null;
  		}
  		else {
! 			throw new HibernateException( 
! 				"More than one row with the given identifier was found: " + 
! 				id + 
! 				", for class: " + 
! 				persister.getClassName() 
  			);
  		}
  	}
! 	
! 	
  }
  
  
--- 46,61 ----
  			return null;
  		}
  		else {
! 			throw new HibernateException(
! 				"More than one row with the given identifier was found: " +
! 				id +
! 				", for class: " +
! 				persister.getClassName()
  			);
  		}
  	}
! 
! 
  }
  
  
Index: hibernate-2.0/src/net/sf/hibernate/loader/OneToManyLoader.java
diff -c hibernate-2.0/src/net/sf/hibernate/loader/OneToManyLoader.java:1.1.1.2 hibernate-2.0/src/net/sf/hibernate/loader/OneToManyLoader.java:1.3
*** hibernate-2.0/src/net/sf/hibernate/loader/OneToManyLoader.java:1.1.1.2	Tue Apr 22 14:28:25 2003
--- hibernate-2.0/src/net/sf/hibernate/loader/OneToManyLoader.java	Tue Apr 22 16:33:27 2003
***************
*** 1,4 ****
! //$Id: OneToManyLoader.java,v 1.1.1.2 2003/04/22 19:28:25 paulsenj Exp $
  package net.sf.hibernate.loader;
  
  import java.io.Serializable;
--- 1,4 ----
! //$Id: OneToManyLoader.java,v 1.3 2003/04/22 21:33:27 paulsenj Exp $
  package net.sf.hibernate.loader;
  
  import java.io.Serializable;
***************
*** 18,71 ****
  import net.sf.hibernate.type.EntityType;
  import net.sf.hibernate.type.Type;
  import net.sf.hibernate.util.StringHelper;
  
  /**
   * Loads one-to-many associations
   */
  public class OneToManyLoader extends OuterJoinLoader implements CollectionInitializer {
! 	
  	private final CollectionPersister collectionPersister;
  	private final Type idType;
! 	
  	public OneToManyLoader(CollectionPersister collPersister, SessionFactoryImplementor session) throws MappingException {
! 		
  		super( session.getDialect() );
! 		
  		collectionPersister = collPersister;
! 		
  		idType = collPersister.getKeyType();
! 		
  		Loadable persister = (Loadable) session.getPersister(
  			( (EntityType) collPersister.getElementType() ).getPersistentClass()
  		);
! 		
  		String alias = alias( collectionPersister.getQualifiedTableName(), 0 );
  		String collAlias = persister.getConcreteClassAlias(alias);
! 		
  		String whereString="";
  		if ( collPersister.hasWhere() ) whereString = " and " + collPersister.getSQLWhereString(collAlias);
! 		
  		List associations = walkTree(persister, alias, session);
! 		
  		int joins=associations.size();
  		suffixes = new String[joins+1];
  		for ( int i=0; i<=joins; i++ ) suffixes[i] = (joins==0) ? StringHelper.EMPTY_STRING : Integer.toString(i) + StringHelper.UNDERSCORE;
! 		
  		JoinFragment ojf = outerJoins(associations);
  		Select select = new Select()
! 			.setSelectClause( 
! 				collPersister.selectClauseFragment(collAlias) + 
! 				( joins==0 ? StringHelper.EMPTY_STRING : ", " + selectString(associations) ) + 
  				", " +
  				selectString( persister, alias, suffixes[joins] )
  			)
! 			.setFromClause( 
  				persister.fromTableFragment(alias) +
  				persister.fromJoinFragment(alias, true, true)
  			)
! 			.setWhereClause( 
  				new ConditionFragment().setTableAlias(collAlias)
! 					.setCondition( collPersister.getKeyColumnNames(), "?" )
  					.toFragmentString()
  				+ whereString
  			)
--- 18,73 ----
  import net.sf.hibernate.type.EntityType;
  import net.sf.hibernate.type.Type;
  import net.sf.hibernate.util.StringHelper;
+ import net.sf.hibernate.util.TypeHelper;
  
  /**
   * Loads one-to-many associations
   */
  public class OneToManyLoader extends OuterJoinLoader implements CollectionInitializer {
! 
  	private final CollectionPersister collectionPersister;
  	private final Type idType;
! 
  	public OneToManyLoader(CollectionPersister collPersister, SessionFactoryImplementor session) throws MappingException {
! 
  		super( session.getDialect() );
! 
  		collectionPersister = collPersister;
! 
  		idType = collPersister.getKeyType();
! 
  		Loadable persister = (Loadable) session.getPersister(
  			( (EntityType) collPersister.getElementType() ).getPersistentClass()
  		);
! 
  		String alias = alias( collectionPersister.getQualifiedTableName(), 0 );
  		String collAlias = persister.getConcreteClassAlias(alias);
! 
  		String whereString="";
  		if ( collPersister.hasWhere() ) whereString = " and " + collPersister.getSQLWhereString(collAlias);
! 
  		List associations = walkTree(persister, alias, session);
! 
  		int joins=associations.size();
  		suffixes = new String[joins+1];
  		for ( int i=0; i<=joins; i++ ) suffixes[i] = (joins==0) ? StringHelper.EMPTY_STRING : Integer.toString(i) + StringHelper.UNDERSCORE;
! 
  		JoinFragment ojf = outerJoins(associations);
  		Select select = new Select()
! 			.setSelectClause(
! 				collPersister.selectClauseFragment(collAlias) +
! 				( joins==0 ? StringHelper.EMPTY_STRING : ", " + selectString(associations) ) +
  				", " +
  				selectString( persister, alias, suffixes[joins] )
  			)
! 			.setFromClause(
  				persister.fromTableFragment(alias) +
  				persister.fromJoinFragment(alias, true, true)
  			)
! 			.setWhereClause(
  				new ConditionFragment().setTableAlias(collAlias)
!           // use type placeholders when constructing sql
! 					.setCondition( collPersister.getKeyColumnNames(), TypeHelper.getPlaceHolders(collPersister.getKeyColumnTypes()) )
  					.toFragmentString()
  				+ whereString
  			)
***************
*** 76,95 ****
  			);
  		if ( collPersister.hasOrdering() ) select.setOrderByClause( collPersister.getSQLOrderByString(collAlias) );
  		sql = select.toStatementString();
! 		
  		classPersisters = new Loadable[joins+1];
  		for ( int i=0; i<joins; i++ ) classPersisters[i] = ( (OuterJoinableAssociation) associations.get(i) ).subpersister;
  		classPersisters[joins] = persister;
  	}
! 	
  	protected CollectionPersister getCollectionPersister() {
  		return collectionPersister;
  	}
! 	
  	public void initialize(Serializable id, PersistentCollection collection, Object owner, SessionImplementor session) throws SQLException, HibernateException {
  		loadCollection(session, id, idType, owner, collection);
  	}
! 	
  }
  
  
--- 78,97 ----
  			);
  		if ( collPersister.hasOrdering() ) select.setOrderByClause( collPersister.getSQLOrderByString(collAlias) );
  		sql = select.toStatementString();
! 
  		classPersisters = new Loadable[joins+1];
  		for ( int i=0; i<joins; i++ ) classPersisters[i] = ( (OuterJoinableAssociation) associations.get(i) ).subpersister;
  		classPersisters[joins] = persister;
  	}
! 
  	protected CollectionPersister getCollectionPersister() {
  		return collectionPersister;
  	}
! 
  	public void initialize(Serializable id, PersistentCollection collection, Object owner, SessionImplementor session) throws SQLException, HibernateException {
  		loadCollection(session, id, idType, owner, collection);
  	}
! 
  }
  
  
Index: hibernate-2.0/src/net/sf/hibernate/persister/AbstractEntityPersister.java
diff -c hibernate-2.0/src/net/sf/hibernate/persister/AbstractEntityPersister.java:1.1.1.2 hibernate-2.0/src/net/sf/hibernate/persister/AbstractEntityPersister.java:1.3
*** hibernate-2.0/src/net/sf/hibernate/persister/AbstractEntityPersister.java:1.1.1.2	Tue Apr 22 14:28:25 2003
--- hibernate-2.0/src/net/sf/hibernate/persister/AbstractEntityPersister.java	Tue Apr 22 16:33:27 2003
***************
*** 1,4 ****
! //$Id: AbstractEntityPersister.java,v 1.1.1.2 2003/04/22 19:28:25 paulsenj Exp $
  package net.sf.hibernate.persister;
  
  import java.io.Serializable;
--- 1,4 ----
! //$Id: AbstractEntityPersister.java,v 1.3 2003/04/22 21:33:27 paulsenj Exp $
  package net.sf.hibernate.persister;
  
  import java.io.Serializable;
***************
*** 52,68 ****
   * May be considered an immutable view of the mapping object.<br>
   */
  abstract class AbstractEntityPersister implements Queryable, ClassMetadata {
! 	
  	private static final Log log = LogFactory.getLog(AbstractEntityPersister.class);
! 	
  	protected static final Class[] NO_CLASSES = new Class[0];
! 	
  	private final Class mappedClass;
! 	
  	protected transient final Dialect dialect;
! 	
  	private transient final Constructor constructor;
! 	
  	private transient final IdentifierGenerator idgen;
  	private transient final boolean polymorphic;
  	private transient final boolean explicitPolymorphism;
--- 52,68 ----
   * May be considered an immutable view of the mapping object.<br>
   */
  abstract class AbstractEntityPersister implements Queryable, ClassMetadata {
! 
  	private static final Log log = LogFactory.getLog(AbstractEntityPersister.class);
! 
  	protected static final Class[] NO_CLASSES = new Class[0];
! 
  	private final Class mappedClass;
! 
  	protected transient final Dialect dialect;
! 
  	private transient final Constructor constructor;
! 
  	private transient final IdentifierGenerator idgen;
  	private transient final boolean polymorphic;
  	private transient final boolean explicitPolymorphism;
***************
*** 78,135 ****
  	private transient final boolean useIdentityColumn;
  	private transient final Class superclass;
  	private transient final boolean dynamicUpdate;
! 	
  	private transient final String identitySelectString;
! 	
  	private transient final Class[] proxyInterfaces;
  	private transient final Class concreteProxyClass;
  	private transient final boolean hasProxy;
  	private transient final boolean hasEmbeddedIdentifier;
! 	
  	private transient final String[] identifierColumnNames;
  	private transient final Cascades.IdentifierValue unsavedIdentifierValue;
! 	
  	protected transient final HashMap columnNamesByPropertyPath = new HashMap();
  	protected transient final HashMap typesByPropertyPath = new HashMap();
! 	
  	private transient final String identifierPropertyName;
  	private transient final Type identifierType;
  	private transient final ReflectHelper.Setter identifierSetter;
  	private transient final ReflectHelper.Getter identifierGetter;
  	private transient final Method proxyGetIdentifierMethod;
! 	
  	private transient final String[] propertyNames;
  	private transient final Type[] propertyTypes;
  	private transient final boolean[] propertyUpdateability;
  	private transient final boolean[] propertyInsertability;
! 	
  	private transient final String versionPropertyName;
  	private transient final String versionColumnName;
  	private transient final VersionType versionType;
  	private transient final ReflectHelper.Getter versionGetter;
  	private transient final int versionProperty;
! 	
  	private transient final ReflectHelper.Getter[] getters;
  	private transient final ReflectHelper.Setter[] setters;
  	private transient final HashMap gettersByPropertyName = new HashMap();
  	private transient final HashMap settersByPropertyName = new HashMap();
  	protected transient final int hydrateSpan;
! 	
  	private transient final String className;
! 	
  	private transient final Cascades.CascadeStyle[] cascadeStyles;
  	private transient final CacheConcurrencyStrategy cache;
!         
  	private transient final MetaClass optimizer;
! 	
  	public final Class getMappedClass() {
  		return mappedClass;
  	}
! 	
  	public final String getClassName() {
  		return className;
  	}
! 	
  	public String identifierSelectFragment(String name, String suffix) {
  		return new SelectFragment()
  			.setSuffix(suffix)
--- 78,136 ----
  	private transient final boolean useIdentityColumn;
  	private transient final Class superclass;
  	private transient final boolean dynamicUpdate;
! 
  	private transient final String identitySelectString;
! 
  	private transient final Class[] proxyInterfaces;
  	private transient final Class concreteProxyClass;
  	private transient final boolean hasProxy;
  	private transient final boolean hasEmbeddedIdentifier;
! 
  	private transient final String[] identifierColumnNames;
+   private transient final Type[] identifierColumnTypes;
  	private transient final Cascades.IdentifierValue unsavedIdentifierValue;
! 
  	protected transient final HashMap columnNamesByPropertyPath = new HashMap();
  	protected transient final HashMap typesByPropertyPath = new HashMap();
! 
  	private transient final String identifierPropertyName;
  	private transient final Type identifierType;
  	private transient final ReflectHelper.Setter identifierSetter;
  	private transient final ReflectHelper.Getter identifierGetter;
  	private transient final Method proxyGetIdentifierMethod;
! 
  	private transient final String[] propertyNames;
  	private transient final Type[] propertyTypes;
  	private transient final boolean[] propertyUpdateability;
  	private transient final boolean[] propertyInsertability;
! 
  	private transient final String versionPropertyName;
  	private transient final String versionColumnName;
  	private transient final VersionType versionType;
  	private transient final ReflectHelper.Getter versionGetter;
  	private transient final int versionProperty;
! 
  	private transient final ReflectHelper.Getter[] getters;
  	private transient final ReflectHelper.Setter[] setters;
  	private transient final HashMap gettersByPropertyName = new HashMap();
  	private transient final HashMap settersByPropertyName = new HashMap();
  	protected transient final int hydrateSpan;
! 
  	private transient final String className;
! 
  	private transient final Cascades.CascadeStyle[] cascadeStyles;
  	private transient final CacheConcurrencyStrategy cache;
! 
  	private transient final MetaClass optimizer;
! 
  	public final Class getMappedClass() {
  		return mappedClass;
  	}
! 
  	public final String getClassName() {
  		return className;
  	}
! 
  	public String identifierSelectFragment(String name, String suffix) {
  		return new SelectFragment()
  			.setSuffix(suffix)
***************
*** 137,151 ****
  			.toFragmentString()
  			.substring(2); //strip leading ", "
  	}
! 	
  	public Type getPropertyType(String path) {
  		return (Type) typesByPropertyPath.get(path);
  	}
! 	
  	public Cascades.CascadeStyle[] getPropertyCascadeStyles() {
  		return cascadeStyles;
  	}
! 	
  	/**
  	 * Set the given values to the mapped properties of the given object
  	 */
--- 138,152 ----
  			.toFragmentString()
  			.substring(2); //strip leading ", "
  	}
! 
  	public Type getPropertyType(String path) {
  		return (Type) typesByPropertyPath.get(path);
  	}
! 
  	public Cascades.CascadeStyle[] getPropertyCascadeStyles() {
  		return cascadeStyles;
  	}
! 
  	/**
  	 * Set the given values to the mapped properties of the given object
  	 */
***************
*** 154,168 ****
  			if (optimizer!=null) {
  				optimizer.setPropertyValues(object, values);
  				return;
! 			}  
  		}
  		catch (Throwable t) {
  			throw new PropertyAccessException(t, "exception setting property value with CGLIB", true, mappedClass, "?");
  		}
! 		
  		for (int j=0; j<hydrateSpan; j++) getSetters()[j].set(object, values[j]);
  	}
! 	
  	/**
  	 * Return the values of the mapped properties of the object
  	 */
--- 155,169 ----
  			if (optimizer!=null) {
  				optimizer.setPropertyValues(object, values);
  				return;
! 			}
  		}
  		catch (Throwable t) {
  			throw new PropertyAccessException(t, "exception setting property value with CGLIB", true, mappedClass, "?");
  		}
! 
  		for (int j=0; j<hydrateSpan; j++) getSetters()[j].set(object, values[j]);
  	}
! 
  	/**
  	 * Return the values of the mapped properties of the object
  	 */
***************
*** 175,200 ****
  		catch (Throwable t) {
  			throw new PropertyAccessException(t, "exception getting property value with CGLIB", false, mappedClass, "?");
  		}
! 		
  		Object[] result = new Object[hydrateSpan];
  		for (int j=0; j<hydrateSpan; j++) result[j] = getGetters()[j].get(object);
  		return result;
  	}
! 	
  	/**
  	 * Get the value of the numbered property
  	 */
  	public Object getPropertyValue(Object object, int i) throws HibernateException {
  		return getGetters()[i].get(object);
  	}
! 	
  	/**
  	 * Set the value of the numbered property
  	 */
  	public void setPropertyValue(Object object, int i, Object value) throws HibernateException {
  		getSetters()[i].set(object, value);
  	}
! 	
  	/**
  	 * Determine if the given field values are dirty
  	 */
--- 176,201 ----
  		catch (Throwable t) {
  			throw new PropertyAccessException(t, "exception getting property value with CGLIB", false, mappedClass, "?");
  		}
! 
  		Object[] result = new Object[hydrateSpan];
  		for (int j=0; j<hydrateSpan; j++) result[j] = getGetters()[j].get(object);
  		return result;
  	}
! 
  	/**
  	 * Get the value of the numbered property
  	 */
  	public Object getPropertyValue(Object object, int i) throws HibernateException {
  		return getGetters()[i].get(object);
  	}
! 
  	/**
  	 * Set the value of the numbered property
  	 */
  	public void setPropertyValue(Object object, int i, Object value) throws HibernateException {
  		getSetters()[i].set(object, value);
  	}
! 
  	/**
  	 * Determine if the given field values are dirty
  	 */
***************
*** 212,218 ****
  			return props;
  		}
  	}
! 	
  	public Serializable getIdentifier(Object object) throws HibernateException {
  		final Object id;
  		if (hasEmbeddedIdentifier) {
--- 213,219 ----
  			return props;
  		}
  	}
! 
  	public Serializable getIdentifier(Object object) throws HibernateException {
  		final Object id;
  		if (hasEmbeddedIdentifier) {
***************
*** 229,240 ****
  			throw new ClassCastException( "Identifier classes must be serializable: " + cce.getMessage() );
  		}
  	}
! 	
  	public Object getVersion(Object object) throws HibernateException {
  		if ( !versioned ) return null;
  		return versionGetter.get(object);
  	}
! 	
  	public void setIdentifier(Object object, Serializable id) throws HibernateException {
  		if (hasEmbeddedIdentifier) {
  			ComponentType copier = (ComponentType) identifierType;
--- 230,241 ----
  			throw new ClassCastException( "Identifier classes must be serializable: " + cce.getMessage() );
  		}
  	}
! 
  	public Object getVersion(Object object) throws HibernateException {
  		if ( !versioned ) return null;
  		return versionGetter.get(object);
  	}
! 
  	public void setIdentifier(Object object, Serializable id) throws HibernateException {
  		if (hasEmbeddedIdentifier) {
  			ComponentType copier = (ComponentType) identifierType;
***************
*** 244,250 ****
  			identifierSetter.set(object, id);
  		}
  	}
! 	
  	/**
  	 * Return a new instance initialized with the given identifier
  	 */
--- 245,251 ----
  			identifierSetter.set(object, id);
  		}
  	}
! 
  	/**
  	 * Return a new instance initialized with the given identifier
  	 */
***************
*** 254,260 ****
  		}
  		else {
  			if (abstractClass) throw new HibernateException("Cannot instantiate abstract class or interface: " + className);
! 			if (optimizer != null) { 
  				try {
  					return optimizer.newInstance();
  				}
--- 255,261 ----
  		}
  		else {
  			if (abstractClass) throw new HibernateException("Cannot instantiate abstract class or interface: " + className);
! 			if (optimizer != null) {
  				try {
  					return optimizer.newInstance();
  				}
***************
*** 272,402 ****
  			}
  		}
  	}
! 	
  	// Getters and Setters
! 	
  	protected ReflectHelper.Setter[] getSetters() {
  		return setters;
  	}
! 	
  	protected ReflectHelper.Getter[] getGetters() {
  		return getters;
  	}
! 	
  	public Type[] getPropertyTypes() {
  		return propertyTypes;
  	}
! 	
  	public Type getIdentifierType() {
  		return identifierType;
  	}
! 	
  	public String[] getIdentifierColumnNames() {
  		return identifierColumnNames;
  	}
! 	
  	public boolean isPolymorphic() {
  		return polymorphic;
  	}
! 	
  	public boolean isInherited() {
  		return inherited;
  	}
! 	
  	public boolean hasCompositeKey() {
  		return identifierColumnNames.length>1;
  	}
! 	
  	public boolean hasCascades() {
  		return hasCascades;
  	}
! 	
  	public CacheConcurrencyStrategy getCache() {
  		return cache;
  	}
! 	
  	public boolean hasIdentifierProperty() {
  		return identifierGetter!=null;
  	}
! 	
  	public Method getProxyGetIdentifierMethod() {
  		return proxyGetIdentifierMethod;
  	}
! 	
  	public VersionType getVersionType() {
  		return versionType;
  	}
  	public int getVersionProperty() {
  		return versionProperty;
  	}
! 	
  	public boolean isVersioned() {
  		return versioned;
  	}
! 	
  	public boolean isIdentifierAssignedByInsert() {
  		return useIdentityColumn;
  	}
! 	
  	public boolean isUnsaved(Serializable id) {
  		return unsavedIdentifierValue.isUnsaved(id);
  	}
! 	
  	public String[] getPropertyNames() {
  		return propertyNames;
  	}
! 	
  	public String getIdentifierPropertyName() {
  		return identifierPropertyName;
  	}
! 	
  	public String getVersionColumnName() {
  		return versionColumnName;
  	}
! 	
  	public final String[] getPropertyColumnNames(String path) {
  		return (String[]) columnNamesByPropertyPath.get(path);
  	}
! 	
  	public boolean implementsLifecycle() {
  		return implementsLifecycle;
  	}
! 	
  	public boolean implementsValidatable() {
  		return implementsValidatable;
  	}
! 	
  	public boolean hasCollections() {
  		return hasCollections;
  	}
! 	
  	public boolean isMutable() {
  		return mutable;
  	}
! 	
  	public boolean hasCache() {
  		return cache!=null;
  	}
! 	
  	public boolean hasSubclasses() {
  		return hasSubclasses;
  	}
! 	
  	public Class[] getProxyInterfaces() {
  		return proxyInterfaces;
  	}
! 	
  	public boolean hasProxy() {
  		return hasProxy;
  	}
! 	
  	/**
  	 * The query that returns the generated identifier for an identity column
  	 */
  	protected final String sqlIdentitySelect() {
  		return identitySelectString;
  	}
! 	
  	public IdentifierGenerator getIdentifierGenerator() throws HibernateException {
  		if (idgen==null) throw new HibernateException(
  			"No ID SchemaExport is configured for class " +
--- 273,407 ----
  			}
  		}
  	}
! 
  	// Getters and Setters
! 
  	protected ReflectHelper.Setter[] getSetters() {
  		return setters;
  	}
! 
  	protected ReflectHelper.Getter[] getGetters() {
  		return getters;
  	}
! 
  	public Type[] getPropertyTypes() {
  		return propertyTypes;
  	}
! 
  	public Type getIdentifierType() {
  		return identifierType;
  	}
! 
  	public String[] getIdentifierColumnNames() {
  		return identifierColumnNames;
  	}
! 
!   public Type[] getIdentifierColumnTypes() {
!     return identifierColumnTypes;
!   }
! 
  	public boolean isPolymorphic() {
  		return polymorphic;
  	}
! 
  	public boolean isInherited() {
  		return inherited;
  	}
! 
  	public boolean hasCompositeKey() {
  		return identifierColumnNames.length>1;
  	}
! 
  	public boolean hasCascades() {
  		return hasCascades;
  	}
! 
  	public CacheConcurrencyStrategy getCache() {
  		return cache;
  	}
! 
  	public boolean hasIdentifierProperty() {
  		return identifierGetter!=null;
  	}
! 
  	public Method getProxyGetIdentifierMethod() {
  		return proxyGetIdentifierMethod;
  	}
! 
  	public VersionType getVersionType() {
  		return versionType;
  	}
  	public int getVersionProperty() {
  		return versionProperty;
  	}
! 
  	public boolean isVersioned() {
  		return versioned;
  	}
! 
  	public boolean isIdentifierAssignedByInsert() {
  		return useIdentityColumn;
  	}
! 
  	public boolean isUnsaved(Serializable id) {
  		return unsavedIdentifierValue.isUnsaved(id);
  	}
! 
  	public String[] getPropertyNames() {
  		return propertyNames;
  	}
! 
  	public String getIdentifierPropertyName() {
  		return identifierPropertyName;
  	}
! 
  	public String getVersionColumnName() {
  		return versionColumnName;
  	}
! 
  	public final String[] getPropertyColumnNames(String path) {
  		return (String[]) columnNamesByPropertyPath.get(path);
  	}
! 
  	public boolean implementsLifecycle() {
  		return implementsLifecycle;
  	}
! 
  	public boolean implementsValidatable() {
  		return implementsValidatable;
  	}
! 
  	public boolean hasCollections() {
  		return hasCollections;
  	}
! 
  	public boolean isMutable() {
  		return mutable;
  	}
! 
  	public boolean hasCache() {
  		return cache!=null;
  	}
! 
  	public boolean hasSubclasses() {
  		return hasSubclasses;
  	}
! 
  	public Class[] getProxyInterfaces() {
  		return proxyInterfaces;
  	}
! 
  	public boolean hasProxy() {
  		return hasProxy;
  	}
! 
  	/**
  	 * The query that returns the generated identifier for an identity column
  	 */
  	protected final String sqlIdentitySelect() {
  		return identitySelectString;
  	}
! 
  	public IdentifierGenerator getIdentifierGenerator() throws HibernateException {
  		if (idgen==null) throw new HibernateException(
  			"No ID SchemaExport is configured for class " +
***************
*** 405,411 ****
  		);
  		return idgen;
  	}
! 	
  	protected void check(int rows, Serializable id) throws HibernateException {
  		if (rows<1) {
  			throw new StaleObjectStateException( getMappedClass(), id );
--- 410,416 ----
  		);
  		return idgen;
  	}
! 
  	protected void check(int rows, Serializable id) throws HibernateException {
  		if (rows<1) {
  			throw new StaleObjectStateException( getMappedClass(), id );
***************
*** 414,452 ****
  			throw new HibernateException( "Duplicate identifier in table for "  + getClassName() + ": " + id );
  		}
  	}
! 	
  	protected AbstractEntityPersister(PersistentClass model, SessionFactoryImplementor factory) throws MappingException {
! 		
  		this.dialect = factory.getDialect();
! 		
  		// CLASS
! 		
  		className = model.getPersistentClass().getName();
  		mappedClass = model.getPersistentClass();
! 		
  		mutable = model.isMutable();
  		dynamicUpdate = model.useDynamicUpdate();
! 		
  		polymorphic = model.isPolymorphic();
  		explicitPolymorphism = model.isExplicitPolymorphism();
  		inherited = model.isInherited();
  		superclass = inherited ? model.getSuperclass().getPersistentClass() : null;
  		hasSubclasses = model.hasSubclasses();
! 		
  		constructor = ReflectHelper.getDefaultConstructor(mappedClass);
  		abstractClass = ReflectHelper.isAbstractClass(mappedClass);
! 		
  		// IDENTIFIER
! 		
  		hasEmbeddedIdentifier = model.hasEmbeddedIdentifier();
  		identifierPropertyName = model.hasIdentifierProperty() ? model.getIdentifierProperty().getName() : null;
  		Value idValue = model.getIdentifier();
  		identifierType = idValue.getType();
! 		
  		if (identifierPropertyName!=null) {
  			identifierSetter = ReflectHelper.getSetter(mappedClass, identifierPropertyName);
  			identifierGetter = ReflectHelper.getGetter(mappedClass, identifierPropertyName);
! 			
  			Method proxyGetter = identifierGetter.getMethod();
  			try {
  				Class prox = model.getProxyInterface();
--- 419,457 ----
  			throw new HibernateException( "Duplicate identifier in table for "  + getClassName() + ": " + id );
  		}
  	}
! 
  	protected AbstractEntityPersister(PersistentClass model, SessionFactoryImplementor factory) throws MappingException {
! 
  		this.dialect = factory.getDialect();
! 
  		// CLASS
! 
  		className = model.getPersistentClass().getName();
  		mappedClass = model.getPersistentClass();
! 
  		mutable = model.isMutable();
  		dynamicUpdate = model.useDynamicUpdate();
! 
  		polymorphic = model.isPolymorphic();
  		explicitPolymorphism = model.isExplicitPolymorphism();
  		inherited = model.isInherited();
  		superclass = inherited ? model.getSuperclass().getPersistentClass() : null;
  		hasSubclasses = model.hasSubclasses();
! 
  		constructor = ReflectHelper.getDefaultConstructor(mappedClass);
  		abstractClass = ReflectHelper.isAbstractClass(mappedClass);
! 
  		// IDENTIFIER
! 
  		hasEmbeddedIdentifier = model.hasEmbeddedIdentifier();
  		identifierPropertyName = model.hasIdentifierProperty() ? model.getIdentifierProperty().getName() : null;
  		Value idValue = model.getIdentifier();
  		identifierType = idValue.getType();
! 
  		if (identifierPropertyName!=null) {
  			identifierSetter = ReflectHelper.getSetter(mappedClass, identifierPropertyName);
  			identifierGetter = ReflectHelper.getGetter(mappedClass, identifierPropertyName);
! 
  			Method proxyGetter = identifierGetter.getMethod();
  			try {
  				Class prox = model.getProxyInterface();
***************
*** 460,498 ****
  			identifierSetter = null;
  			proxyGetIdentifierMethod = null;
  		}
! 		
  		// HYDRATE SPAN
! 		
  		int m=0;
  		Iterator iter = model.getPropertyClosureIterator();
  		while ( iter.hasNext() ) {
  			m++; iter.next();
  		}
  		hydrateSpan=m;
! 		
! 		
  		// IDENTIFIER
! 		
  		int idColumnSpan = model.getIdentifier().getColumnSpan();
  		identifierColumnNames = new String[idColumnSpan];
! 		
  		iter = idValue.getColumnIterator();
  		int i=0;
  		while ( iter.hasNext() ) {
  			Column col = (Column) iter.next();
  			identifierColumnNames[i] = col.getName();
  			i++;
  		}
! 				
  		// GENERATOR
! 		
  		idgen = model.getIdentifier().createIdentifierGenerator(dialect);
  		useIdentityColumn = idgen instanceof IdentityGenerator;
  		identitySelectString = useIdentityColumn ? dialect.getIdentitySelectString() : null;
! 		
! 		
! 		// UNSAVED-VALUE:
! 		
  		String unsavedValue = model.getIdentifier().getNullValue();
  		if ( unsavedValue==null || "any".equals(unsavedValue) ) {
  			unsavedIdentifierValue=Cascades.SAVE_ANY;
--- 465,506 ----
  			identifierSetter = null;
  			proxyGetIdentifierMethod = null;
  		}
! 
  		// HYDRATE SPAN
! 
  		int m=0;
  		Iterator iter = model.getPropertyClosureIterator();
  		while ( iter.hasNext() ) {
  			m++; iter.next();
  		}
  		hydrateSpan=m;
! 
! 
  		// IDENTIFIER
! 
  		int idColumnSpan = model.getIdentifier().getColumnSpan();
  		identifierColumnNames = new String[idColumnSpan];
!     // construct array of column types
!     identifierColumnTypes = new Type[idColumnSpan];
! 
  		iter = idValue.getColumnIterator();
  		int i=0;
  		while ( iter.hasNext() ) {
  			Column col = (Column) iter.next();
  			identifierColumnNames[i] = col.getName();
+       identifierColumnTypes[i] = col.getType();
  			i++;
  		}
! 
  		// GENERATOR
! 
  		idgen = model.getIdentifier().createIdentifierGenerator(dialect);
  		useIdentityColumn = idgen instanceof IdentityGenerator;
  		identitySelectString = useIdentityColumn ? dialect.getIdentitySelectString() : null;
! 
! 
!     // UNSAVED-VALUE:
! 
  		String unsavedValue = model.getIdentifier().getNullValue();
  		if ( unsavedValue==null || "any".equals(unsavedValue) ) {
  			unsavedIdentifierValue=Cascades.SAVE_ANY;
***************
*** 515,530 ****
  				throw new MappingException("Could not parse unsaved-value: " + unsavedValue);
  			}
  		}
! 		
  		// VERSION:
! 		
  		if ( model.isVersioned() ) {
  			versionColumnName = ( (Column) model.getVersion().getColumnIterator().next() ).getName();
  		}
  		else {
  			versionColumnName = null;
  		}
! 		
  		if ( model.isVersioned() ) {
  			versionPropertyName = model.getVersion().getName();
  			versioned = true;
--- 523,538 ----
  				throw new MappingException("Could not parse unsaved-value: " + unsavedValue);
  			}
  		}
! 
  		// VERSION:
! 
  		if ( model.isVersioned() ) {
  			versionColumnName = ( (Column) model.getVersion().getColumnIterator().next() ).getName();
  		}
  		else {
  			versionColumnName = null;
  		}
! 
  		if ( model.isVersioned() ) {
  			versionPropertyName = model.getVersion().getName();
  			versioned = true;
***************
*** 537,545 ****
  			versionType = null;
  			versionGetter = null;
  		}
! 		
  		// PROPERTIES
! 		
  		propertyTypes = new Type[hydrateSpan];
  		propertyNames = new String[hydrateSpan];
  		propertyUpdateability = new boolean[hydrateSpan];
--- 545,553 ----
  			versionType = null;
  			versionGetter = null;
  		}
! 
  		// PROPERTIES
! 
  		propertyTypes = new Type[hydrateSpan];
  		propertyNames = new String[hydrateSpan];
  		propertyUpdateability = new boolean[hydrateSpan];
***************
*** 550,561 ****
  		String setterNames[] = new String[hydrateSpan];
  		String getterNames[] = new String[hydrateSpan];
  		Class types[] = new Class[hydrateSpan];
! 		
  		iter = model.getPropertyClosureIterator();
  		i=0;
  		int tempVersionProperty=-66;
  		boolean foundCascade = false;
! 		
  		while( iter.hasNext() ) {
  			Property prop = (Property) iter.next();
  			if ( prop==model.getVersion() ) tempVersionProperty = i;
--- 558,569 ----
  		String setterNames[] = new String[hydrateSpan];
  		String getterNames[] = new String[hydrateSpan];
  		Class types[] = new Class[hydrateSpan];
! 
  		iter = model.getPropertyClosureIterator();
  		i=0;
  		int tempVersionProperty=-66;
  		boolean foundCascade = false;
! 
  		while( iter.hasNext() ) {
  			Property prop = (Property) iter.next();
  			if ( prop==model.getVersion() ) tempVersionProperty = i;
***************
*** 568,599 ****
  			propertyTypes[i] = prop.getType();
  			propertyUpdateability[i] = prop.isUpdateable();
  			propertyInsertability[i] = prop.isInsertable();
! 			
  			gettersByPropertyName.put( propertyNames[i], getters[i] );
  			settersByPropertyName.put( propertyNames[i], setters[i] );
! 			
  			cascadeStyles[i] = prop.getCascadeStyle();
  			if ( cascadeStyles[i]!=Cascades.STYLE_NONE ) foundCascade = true;
! 			
  			i++;
  		}
! 		
  		optimizer = Environment.useReflectionOptimizer() ?
  			ReflectHelper.getMetaClass(mappedClass, getterNames, setterNames, types) :
  			null;
! 		
  		hasCascades = foundCascade;
  		versionProperty = tempVersionProperty;
! 		
  		// CALLBACK INTERFACES
  		implementsLifecycle = Lifecycle.class.isAssignableFrom(mappedClass);
  		implementsValidatable = Validatable.class.isAssignableFrom(mappedClass);
! 		
  		cache = model.getCache();
! 		
  		hasCollections = initHasCollections();
! 		
! 		
  		// PROXIES
  		Class pi = model.getProxyInterface();
  		hasProxy = pi!=null && Environment.jvmSupportsProxies();
--- 576,607 ----
  			propertyTypes[i] = prop.getType();
  			propertyUpdateability[i] = prop.isUpdateable();
  			propertyInsertability[i] = prop.isInsertable();
! 
  			gettersByPropertyName.put( propertyNames[i], getters[i] );
  			settersByPropertyName.put( propertyNames[i], setters[i] );
! 
  			cascadeStyles[i] = prop.getCascadeStyle();
  			if ( cascadeStyles[i]!=Cascades.STYLE_NONE ) foundCascade = true;
! 
  			i++;
  		}
! 
  		optimizer = Environment.useReflectionOptimizer() ?
  			ReflectHelper.getMetaClass(mappedClass, getterNames, setterNames, types) :
  			null;
! 
  		hasCascades = foundCascade;
  		versionProperty = tempVersionProperty;
! 
  		// CALLBACK INTERFACES
  		implementsLifecycle = Lifecycle.class.isAssignableFrom(mappedClass);
  		implementsValidatable = Validatable.class.isAssignableFrom(mappedClass);
! 
  		cache = model.getCache();
! 
  		hasCollections = initHasCollections();
! 
! 
  		// PROXIES
  		Class pi = model.getProxyInterface();
  		hasProxy = pi!=null && Environment.jvmSupportsProxies();
***************
*** 601,607 ****
  		pis.add(HibernateProxy.class);
  		if ( !mappedClass.equals(pi) ) pis.add(pi);
  		concreteProxyClass = pi;
! 		
  		if (hasProxy) {
  			iter = model.getSubclassIterator();
  			while ( iter.hasNext() ) {
--- 609,615 ----
  		pis.add(HibernateProxy.class);
  		if ( !mappedClass.equals(pi) ) pis.add(pi);
  		concreteProxyClass = pi;
! 
  		if (hasProxy) {
  			iter = model.getSubclassIterator();
  			while ( iter.hasNext() ) {
***************
*** 611,624 ****
  				if ( !sc.getPersistentClass().equals(pi) ) pis.add(pi);
  			}
  		}
! 		
  		proxyInterfaces = (Class[]) pis.toArray(NO_CLASSES);
  	}
! 	
  	private boolean initHasCollections() {
  		return initHasCollections(propertyTypes);
  	}
! 	
  	private boolean initHasCollections(Type[] types) {
  		for ( int i=0; i<types.length; i++ ) {
  			if ( types[i].isPersistentCollectionType() ) {
--- 619,632 ----
  				if ( !sc.getPersistentClass().equals(pi) ) pis.add(pi);
  			}
  		}
! 
  		proxyInterfaces = (Class[]) pis.toArray(NO_CLASSES);
  	}
! 
  	private boolean initHasCollections() {
  		return initHasCollections(propertyTypes);
  	}
! 
  	private boolean initHasCollections(Type[] types) {
  		for ( int i=0; i<types.length; i++ ) {
  			if ( types[i].isPersistentCollectionType() ) {
***************
*** 632,658 ****
  		}
  		return false;
  	}
! 	
  	public ClassMetadata getClassMetadata() {
  		return this;
  	}
! 	
  	public Class getConcreteProxyClass() {
  		return concreteProxyClass;
  	}
! 		
  	public Class getMappedSuperclass() {
  		return superclass;
  	}
! 	
  	public boolean isExplicitPolymorphism() {
  		return explicitPolymorphism;
  	}
! 	
  	public boolean[] getPropertyUpdateability() {
  		return propertyUpdateability;
  	}
! 	
  	protected boolean useDynamicUpdate() {
  		return dynamicUpdate;
  	}
--- 640,666 ----
  		}
  		return false;
  	}
! 
  	public ClassMetadata getClassMetadata() {
  		return this;
  	}
! 
  	public Class getConcreteProxyClass() {
  		return concreteProxyClass;
  	}
! 
  	public Class getMappedSuperclass() {
  		return superclass;
  	}
! 
  	public boolean isExplicitPolymorphism() {
  		return explicitPolymorphism;
  	}
! 
  	public boolean[] getPropertyUpdateability() {
  		return propertyUpdateability;
  	}
! 
  	protected boolean useDynamicUpdate() {
  		return dynamicUpdate;
  	}
***************
*** 660,678 ****
  	public boolean[] getPropertyInsertability() {
  		return propertyInsertability;
  	}
! 	
  	public Object getPropertyValue(Object object, String propertyName)
  		throws HibernateException {
! 		
  		return ( (ReflectHelper.Getter) gettersByPropertyName.get(propertyName) ).get(object);
  	}
  
  	public void setPropertyValue(Object object, String propertyName, Object value)
  		throws HibernateException {
! 		
  		( (ReflectHelper.Setter) settersByPropertyName.get(propertyName) ).set(object, value);
  	}
! 	
  	protected boolean hasEmbeddedIdentifier() {
  		return hasEmbeddedIdentifier;
  	}
--- 668,686 ----
  	public boolean[] getPropertyInsertability() {
  		return propertyInsertability;
  	}
! 
  	public Object getPropertyValue(Object object, String propertyName)
  		throws HibernateException {
! 
  		return ( (ReflectHelper.Getter) gettersByPropertyName.get(propertyName) ).get(object);
  	}
  
  	public void setPropertyValue(Object object, String propertyName, Object value)
  		throws HibernateException {
! 
  		( (ReflectHelper.Setter) settersByPropertyName.get(propertyName) ).set(object, value);
  	}
! 
  	protected boolean hasEmbeddedIdentifier() {
  		return hasEmbeddedIdentifier;
  	}
Index: hibernate-2.0/src/net/sf/hibernate/persister/EntityPersister.java
diff -c hibernate-2.0/src/net/sf/hibernate/persister/EntityPersister.java:1.1.1.2 hibernate-2.0/src/net/sf/hibernate/persister/EntityPersister.java:1.3
*** hibernate-2.0/src/net/sf/hibernate/persister/EntityPersister.java:1.1.1.2	Tue Apr 22 14:28:25 2003
--- hibernate-2.0/src/net/sf/hibernate/persister/EntityPersister.java	Tue Apr 22 16:33:27 2003
***************
*** 1,8 ****
! //$Id: EntityPersister.java,v 1.1.1.2 2003/04/22 19:28:25 paulsenj Exp $
  package net.sf.hibernate.persister;
  
  import net.sf.hibernate.util.JDBCExceptionReporter;
  import net.sf.hibernate.util.StringHelper;
  import net.sf.hibernate.loader.EntityLoader;
  import net.sf.hibernate.loader.SimpleEntityLoader;
  import net.sf.hibernate.loader.UniqueEntityLoader;
--- 1,9 ----
! //$Id: EntityPersister.java,v 1.3 2003/04/22 21:33:27 paulsenj Exp $
  package net.sf.hibernate.persister;
  
  import net.sf.hibernate.util.JDBCExceptionReporter;
  import net.sf.hibernate.util.StringHelper;
+ import net.sf.hibernate.util.TypeHelper;
  import net.sf.hibernate.loader.EntityLoader;
  import net.sf.hibernate.loader.SimpleEntityLoader;
  import net.sf.hibernate.loader.UniqueEntityLoader;
***************
*** 55,111 ****
   * class.
   */
  public class EntityPersister extends AbstractEntityPersister implements Queryable {
! 	
  	private final SessionFactoryImplementor factory;
! 	
  	// the class hierarchy structure
  	private final String qualifiedTableName;
  	private final String[] tableNames;
  	private final boolean hasUpdateableColumns;
  	private final Class[] subclassClosure;
! 	
  	// SQL strings
  	private final String sqlDeleteString;
  	private final String sqlInsertString;
  	private final String sqlUpdateString;
  	private final String sqlIdentityInsertString;
! 	
  	// properties of this class, including inherited properties
  	private final int[] propertyColumnSpans;
  	private final boolean[] propertyDefinedOnSubclass;
  	private final String[][] propertyColumnNames;
  	private final String[][] propertyColumnAliases;
! 	
  	// the closure of all columns used by the entire hierarchy including
  	// subclasses and superclasses of this class
  	private final String[] subclassColumnClosure;
  	private final String[] subclassColumnAliasClosure;
! 	
  	// the closure of all properties in the entire hierarchy including
  	// subclasses and superclasses of this class
  	private final String[][] subclassPropertyColumnNameClosure;
  	private final Type[] subclassPropertyTypeClosure;
  	private final int[] subclassPropertyEnableJoinedFetch;
! 	
  	// discriminator column
  	private final HashMap subclassesByDiscriminatorValue = new HashMap();
! 	private final boolean forceDiscriminator;	
  	private final String discriminatorColumnName;
  	private final DiscriminatorType discriminatorType;
  	private final String discriminatorSQLString;
! 	
  	protected final Map loaders = new HashMap();
  	protected final Map lockers = new HashMap();
! 	
  	private static final String[] STRING_ARRAY = {};
  	private static final Type[] TYPE_ARRAY = {};
! 	
  	private static final Log log = LogFactory.getLog(EntityPersister.class);
! 	
  	public void postInstantiate(SessionFactoryImplementor factory) throws MappingException {
! 		
  		initPropertyPaths(factory);
! 		
  		//TODO: move into initPropertyPaths
  		HashMap mods = new HashMap();
  		Iterator iter = typesByPropertyPath.entrySet().iterator();
--- 56,113 ----
   * class.
   */
  public class EntityPersister extends AbstractEntityPersister implements Queryable {
! 
  	private final SessionFactoryImplementor factory;
! 
  	// the class hierarchy structure
  	private final String qualifiedTableName;
  	private final String[] tableNames;
  	private final boolean hasUpdateableColumns;
  	private final Class[] subclassClosure;
! 
  	// SQL strings
  	private final String sqlDeleteString;
  	private final String sqlInsertString;
  	private final String sqlUpdateString;
  	private final String sqlIdentityInsertString;
! 
  	// properties of this class, including inherited properties
  	private final int[] propertyColumnSpans;
  	private final boolean[] propertyDefinedOnSubclass;
  	private final String[][] propertyColumnNames;
+   private final Type[][] propertyColumnTypes;
  	private final String[][] propertyColumnAliases;
! 
  	// the closure of all columns used by the entire hierarchy including
  	// subclasses and superclasses of this class
  	private final String[] subclassColumnClosure;
  	private final String[] subclassColumnAliasClosure;
! 
  	// the closure of all properties in the entire hierarchy including
  	// subclasses and superclasses of this class
  	private final String[][] subclassPropertyColumnNameClosure;
  	private final Type[] subclassPropertyTypeClosure;
  	private final int[] subclassPropertyEnableJoinedFetch;
! 
  	// discriminator column
  	private final HashMap subclassesByDiscriminatorValue = new HashMap();
! 	private final boolean forceDiscriminator;
  	private final String discriminatorColumnName;
  	private final DiscriminatorType discriminatorType;
  	private final String discriminatorSQLString;
! 
  	protected final Map loaders = new HashMap();
  	protected final Map lockers = new HashMap();
! 
  	private static final String[] STRING_ARRAY = {};
  	private static final Type[] TYPE_ARRAY = {};
! 
  	private static final Log log = LogFactory.getLog(EntityPersister.class);
! 
  	public void postInstantiate(SessionFactoryImplementor factory) throws MappingException {
! 
  		initPropertyPaths(factory);
! 
  		//TODO: move into initPropertyPaths
  		HashMap mods = new HashMap();
  		Iterator iter = typesByPropertyPath.entrySet().iterator();
***************
*** 118,124 ****
  				if ( columns.length==0 ) columns = getIdentifierColumnNames(); //ie. a 1-to-one association
  				EntityType etype = (EntityType) type;
  				Type idType = factory.getIdentifierType( etype.getPersistentClass() );
! 				
  				String idpath = path + StringHelper.DOT + PathExpressionParser.ENTITY_ID;
  				mods.put(idpath, idType);
  				columnNamesByPropertyPath.put(idpath, columns);
--- 120,126 ----
  				if ( columns.length==0 ) columns = getIdentifierColumnNames(); //ie. a 1-to-one association
  				EntityType etype = (EntityType) type;
  				Type idType = factory.getIdentifierType( etype.getPersistentClass() );
! 
  				String idpath = path + StringHelper.DOT + PathExpressionParser.ENTITY_ID;
  				mods.put(idpath, idType);
  				columnNamesByPropertyPath.put(idpath, columns);
***************
*** 126,132 ****
  					AbstractComponentType actype = (AbstractComponentType) idType;
  					String[] props = actype.getPropertyNames();
  					Type[] subtypes = actype.getSubtypes();
! 					if ( actype.getColumnSpan(factory)!=columns.length ) 
  						throw new MappingException("broken mapping for: " + getClassName() + StringHelper.DOT + path);
  					int j=0;
  					for ( int i=0; i<props.length; i++ ) {
--- 128,134 ----
  					AbstractComponentType actype = (AbstractComponentType) idType;
  					String[] props = actype.getPropertyNames();
  					Type[] subtypes = actype.getSubtypes();
! 					if ( actype.getColumnSpan(factory)!=columns.length )
  						throw new MappingException("broken mapping for: " + getClassName() + StringHelper.DOT + path);
  					int j=0;
  					for ( int i=0; i<props.length; i++ ) {
***************
*** 142,217 ****
  			}
  		}
  		typesByPropertyPath.putAll(mods);
! 		
! 		
  		UniqueEntityLoader loader = new EntityLoader(this, factory);
! 		
  		loaders.put( LockMode.NONE, loader );
  		loaders.put( LockMode.READ, loader );
! 		
  		String selectForUpdate = factory.getDialect().supportsForUpdate() ?
  		generateSelectForUpdateString() :
  		generateSelectString();
! 		
  		loaders.put(
  			LockMode.UPGRADE,
  			new SimpleEntityLoader( this, selectForUpdate, LockMode.UPGRADE )
  		);
! 		
  		String selectForUpdateNowait = factory.getDialect().supportsForUpdateNowait() ?
  		generateSelectForUpdateNowaitString() :
  		selectForUpdate;
! 		
  		loaders.put(
  			LockMode.UPGRADE_NOWAIT,
  			new SimpleEntityLoader( this, selectForUpdateNowait, LockMode.UPGRADE_NOWAIT )
  		);
! 		
  	}
! 	
  	public boolean isDefinedOnSubclass(int i) {
  		return propertyDefinedOnSubclass[i];
  	}
! 	
  	public String getDiscriminatorColumnName() {
  		return discriminatorColumnName;
  	}
! 	
  	public int enableJoinedFetch(int i) {
  		return subclassPropertyEnableJoinedFetch[i];
  	}
! 	
  	public Type getSubclassPropertyType(int i) {
  		return subclassPropertyTypeClosure[i];
  	}
  	public int countSubclassProperties() {
  		return subclassPropertyTypeClosure.length;
  	}
! 	
  	public String getTableName() {
  		return qualifiedTableName;
  	}
! 	
  	public String[] getSubclassPropertyColumnNames(int i) {
  		return subclassPropertyColumnNameClosure[i];
  	}
! 	
  	public String[] getPropertyColumnNames(int i) {
  		return propertyColumnAliases[i];
  	}
! 	
  	public DiscriminatorType getDiscriminatorType() {
  		return discriminatorType;
  	}
! 	
  	public String getDiscriminatorSQLString() {
  		return discriminatorSQLString;
  	}
! 	
  	public Class[] getSubclassClosure() {
  		return subclassClosure;
  	}
! 	
  	public Class getSubclassForDiscriminatorValue(Object value) {
  		if (value==null) {
  			return (Class) subclassesByDiscriminatorValue.get(ObjectUtils.NULL);
--- 144,219 ----
  			}
  		}
  		typesByPropertyPath.putAll(mods);
! 
! 
  		UniqueEntityLoader loader = new EntityLoader(this, factory);
! 
  		loaders.put( LockMode.NONE, loader );
  		loaders.put( LockMode.READ, loader );
! 
  		String selectForUpdate = factory.getDialect().supportsForUpdate() ?
  		generateSelectForUpdateString() :
  		generateSelectString();
! 
  		loaders.put(
  			LockMode.UPGRADE,
  			new SimpleEntityLoader( this, selectForUpdate, LockMode.UPGRADE )
  		);
! 
  		String selectForUpdateNowait = factory.getDialect().supportsForUpdateNowait() ?
  		generateSelectForUpdateNowaitString() :
  		selectForUpdate;
! 
  		loaders.put(
  			LockMode.UPGRADE_NOWAIT,
  			new SimpleEntityLoader( this, selectForUpdateNowait, LockMode.UPGRADE_NOWAIT )
  		);
! 
  	}
! 
  	public boolean isDefinedOnSubclass(int i) {
  		return propertyDefinedOnSubclass[i];
  	}
! 
  	public String getDiscriminatorColumnName() {
  		return discriminatorColumnName;
  	}
! 
  	public int enableJoinedFetch(int i) {
  		return subclassPropertyEnableJoinedFetch[i];
  	}
! 
  	public Type getSubclassPropertyType(int i) {
  		return subclassPropertyTypeClosure[i];
  	}
  	public int countSubclassProperties() {
  		return subclassPropertyTypeClosure.length;
  	}
! 
  	public String getTableName() {
  		return qualifiedTableName;
  	}
! 
  	public String[] getSubclassPropertyColumnNames(int i) {
  		return subclassPropertyColumnNameClosure[i];
  	}
! 
  	public String[] getPropertyColumnNames(int i) {
  		return propertyColumnAliases[i];
  	}
! 
  	public DiscriminatorType getDiscriminatorType() {
  		return discriminatorType;
  	}
! 
  	public String getDiscriminatorSQLString() {
  		return discriminatorSQLString;
  	}
! 
  	public Class[] getSubclassClosure() {
  		return subclassClosure;
  	}
! 
  	public Class getSubclassForDiscriminatorValue(Object value) {
  		if (value==null) {
  			return (Class) subclassesByDiscriminatorValue.get(ObjectUtils.NULL);
***************
*** 220,345 ****
  			return (Class) subclassesByDiscriminatorValue.get(value);
  		}
  	}
! 	
  	public Serializable getIdentifierSpace() {
  		return qualifiedTableName;
  	}
! 	
  	public Serializable[] getPropertySpaces() {
  		return tableNames;
  	}
! 	
  	//Access cached SQL
! 	
  	/**
  	 * The query that deletes a row by id (and version)
  	 */
  	protected final String getSQLDeleteString() {
  		return sqlDeleteString;
  	}
! 	
  	/**
  	 * The query that inserts a row with a given id
  	 */
  	protected final String getSQLInsertString() {
  		return sqlInsertString;
  	}
! 	
  	/**
  	 * The query that inserts a row, letting the database generate an id
  	 */
  	protected final String getSQLIdentityInsertString() {
  		return sqlIdentityInsertString;
  	}
! 	
  	/**
  	 * The query that updates a row by id (and version)
  	 */
  	protected final String getSQLUpdateString() {
  		return sqlUpdateString;
  	}
! 	
  	// Generate all the SQL
! 	
  	/**
  	 * Generate the SQL that deletes a row by id (and version)
  	 */
  	protected String generateDeleteString() {
  		return new Delete()
  			.setTableName( getTableName() )
  			.setPrimaryKeyColumnNames( getIdentifierColumnNames() )
  			.setVersionColumnName( getVersionColumnName() )
  			.toStatementString();
  	}
! 	
  	/**
  	 * Generate the SQL that inserts a row
  	 */
  	protected String generateInsertString(boolean identityInsert, boolean[] includeProperty) {
! 		Insert insert = new Insert(dialect)
  			.setTableName( getTableName() );
  		for (int i=0; i<hydrateSpan; i++) {
! 			if ( includeProperty[i] ) insert.addColumns( propertyColumnNames[i] );
  		}
  		if ( isPolymorphic() ) insert.addColumn( getDiscriminatorColumnName(), discriminatorSQLString );
  		if (!identityInsert) {
! 			insert.addColumns( getIdentifierColumnNames() );
  		}
  		else {
  			insert.addIdentityColumn( getIdentifierColumnNames()[0] );
  		}
  		return insert.toStatementString();
  	}
! 	
  	/**
  	 * Generate the SQL that selects a row by id using <tt>FOR UPDATE</tt>
  	 */
  	protected String generateSelectForUpdateString() {
  		return generateSelectString() + " for update";
  	}
! 	
  	/**
  	 * Generate the SQL that selects a row by id using <tt>FOR UPDATE</tt>
  	 */
  	protected String generateSelectForUpdateNowaitString() {
  		return generateSelectString() + " for update nowait";
  	}
! 	
  	/**
  	 * Generate the SQL that selects a row by id
  	 */
  	protected String generateSelectString() {
! 		SimpleSelect select = new SimpleSelect()
  			.setTableName( getTableName() )
  			.addColumns( getIdentifierColumnNames() )
  			.addColumns( subclassColumnClosure, subclassColumnAliasClosure );
  		if ( hasSubclasses() ) select.addColumn( getDiscriminatorColumnName() );
! 		return select.addCondition( getIdentifierColumnNames(), "=?" ).toStatementString();
  	}
! 	
  	/**
  	 * Generate the SQL that updates a row by id (and version)
  	 */
  	protected String generateUpdateString(boolean[] includeProperty) {
! 		Update update = new Update()
  			.setTableName( getTableName() )
  			//.addColumns( getColumnNames() )
  			.setPrimaryKeyColumnNames( getIdentifierColumnNames() )
  			.setVersionColumnName( getVersionColumnName() );
  		for ( int i=0; i<hydrateSpan; i++ ) {
! 			if ( includeProperty[i] ) update.addColumns( propertyColumnNames[i] );
  		}
  		return update.toStatementString();
  	}
! 	
  	/**
  	 * Generate the SQL that pessimistic locks a row by id (and version)
  	 */
  	protected String generateLockString() {
  		SimpleSelect select = new SimpleSelect()
  			.setTableName( getTableName() )
  			.addColumn( getIdentifierColumnNames()[0] )
! 			.addCondition( getIdentifierColumnNames(), "=?" );
  		if ( isVersioned() ) {
  			select.addWhereToken("and")
  				.addCondition( getVersionColumnName(), "=?" );
--- 222,355 ----
  			return (Class) subclassesByDiscriminatorValue.get(value);
  		}
  	}
! 
  	public Serializable getIdentifierSpace() {
  		return qualifiedTableName;
  	}
! 
  	public Serializable[] getPropertySpaces() {
  		return tableNames;
  	}
! 
  	//Access cached SQL
! 
  	/**
  	 * The query that deletes a row by id (and version)
  	 */
  	protected final String getSQLDeleteString() {
  		return sqlDeleteString;
  	}
! 
  	/**
  	 * The query that inserts a row with a given id
  	 */
  	protected final String getSQLInsertString() {
  		return sqlInsertString;
  	}
! 
  	/**
  	 * The query that inserts a row, letting the database generate an id
  	 */
  	protected final String getSQLIdentityInsertString() {
  		return sqlIdentityInsertString;
  	}
! 
  	/**
  	 * The query that updates a row by id (and version)
  	 */
  	protected final String getSQLUpdateString() {
  		return sqlUpdateString;
  	}
! 
  	// Generate all the SQL
! 
  	/**
  	 * Generate the SQL that deletes a row by id (and version)
  	 */
  	protected String generateDeleteString() {
+     // use type placeholders when constructing sql
  		return new Delete()
  			.setTableName( getTableName() )
  			.setPrimaryKeyColumnNames( getIdentifierColumnNames() )
+       .setPrimaryKeyColumnPlaceHolders( TypeHelper.getPlaceHolders(getIdentifierColumnTypes()) )
  			.setVersionColumnName( getVersionColumnName() )
  			.toStatementString();
  	}
! 
  	/**
  	 * Generate the SQL that inserts a row
  	 */
  	protected String generateInsertString(boolean identityInsert, boolean[] includeProperty) {
!     // use type placeholders when constructing sql
!     Insert insert = new Insert(dialect)
  			.setTableName( getTableName() );
  		for (int i=0; i<hydrateSpan; i++) {
! 			if ( includeProperty[i] )
!         insert.addColumns(propertyColumnNames[i], TypeHelper.getPlaceHolders(propertyColumnTypes[i]) );
  		}
  		if ( isPolymorphic() ) insert.addColumn( getDiscriminatorColumnName(), discriminatorSQLString );
  		if (!identityInsert) {
! 			insert.addColumns( getIdentifierColumnNames(), TypeHelper.getPlaceHolders(getIdentifierColumnTypes()) );
  		}
  		else {
  			insert.addIdentityColumn( getIdentifierColumnNames()[0] );
  		}
  		return insert.toStatementString();
  	}
! 
  	/**
  	 * Generate the SQL that selects a row by id using <tt>FOR UPDATE</tt>
  	 */
  	protected String generateSelectForUpdateString() {
  		return generateSelectString() + " for update";
  	}
! 
  	/**
  	 * Generate the SQL that selects a row by id using <tt>FOR UPDATE</tt>
  	 */
  	protected String generateSelectForUpdateNowaitString() {
  		return generateSelectString() + " for update nowait";
  	}
! 
  	/**
  	 * Generate the SQL that selects a row by id
  	 */
  	protected String generateSelectString() {
!     // use type placeholders when constructing sql
!     SimpleSelect select = new SimpleSelect()
  			.setTableName( getTableName() )
  			.addColumns( getIdentifierColumnNames() )
  			.addColumns( subclassColumnClosure, subclassColumnAliasClosure );
  		if ( hasSubclasses() ) select.addColumn( getDiscriminatorColumnName() );
! 		return select.addCondition( getIdentifierColumnNames(), "=", TypeHelper.getPlaceHolders(getIdentifierColumnTypes()) ).toStatementString();
  	}
! 
  	/**
  	 * Generate the SQL that updates a row by id (and version)
  	 */
  	protected String generateUpdateString(boolean[] includeProperty) {
!     // use type placeholders when contructing sql
!     Update update = new Update()
  			.setTableName( getTableName() )
  			//.addColumns( getColumnNames() )
  			.setPrimaryKeyColumnNames( getIdentifierColumnNames() )
+       .setPrimaryKeyColumnPlaceHolders( TypeHelper.getPlaceHolders(getIdentifierColumnTypes()) )
  			.setVersionColumnName( getVersionColumnName() );
  		for ( int i=0; i<hydrateSpan; i++ ) {
! 			if ( includeProperty[i] ) update.addColumns( propertyColumnNames[i], TypeHelper.getPlaceHolders(propertyColumnTypes[i]) );
  		}
  		return update.toStatementString();
  	}
! 
  	/**
  	 * Generate the SQL that pessimistic locks a row by id (and version)
  	 */
  	protected String generateLockString() {
+     // use type placeholders when constructing sql
  		SimpleSelect select = new SimpleSelect()
  			.setTableName( getTableName() )
  			.addColumn( getIdentifierColumnNames()[0] )
! 			.addCondition( getIdentifierColumnNames(), "=", TypeHelper.getPlaceHolders(getIdentifierColumnTypes()) );
  		if ( isVersioned() ) {
  			select.addWhereToken("and")
  				.addCondition( getVersionColumnName(), "=?" );
***************
*** 347,360 ****
  		return select.toStatementString();
  
  	}
! 	
  	/**
  	 * Marshall the fields of a persistent instance to a prepared statement
  	 */
  	protected int dehydrate(Serializable id, Object[] fields, boolean[] includeProperty, PreparedStatement st, SessionImplementor session) throws SQLException, HibernateException {
! 		
  		if ( log.isTraceEnabled() ) log.trace("Dehydrating entity: " + getClassName() + '#' + id);
! 		
  		int index = 1;
  		for (int j=0; j<hydrateSpan; j++) {
  			if ( includeProperty[j] ) {
--- 357,370 ----
  		return select.toStatementString();
  
  	}
! 
  	/**
  	 * Marshall the fields of a persistent instance to a prepared statement
  	 */
  	protected int dehydrate(Serializable id, Object[] fields, boolean[] includeProperty, PreparedStatement st, SessionImplementor session) throws SQLException, HibernateException {
! 
  		if ( log.isTraceEnabled() ) log.trace("Dehydrating entity: " + getClassName() + '#' + id);
! 
  		int index = 1;
  		for (int j=0; j<hydrateSpan; j++) {
  			if ( includeProperty[j] ) {
***************
*** 362,408 ****
  				index += propertyColumnSpans[j];
  			}
  		}
! 		
  		if ( id!=null ) {
  			getIdentifierType().nullSafeSet( st, id, index, session );
  			index += getIdentifierColumnNames().length;
  		}
! 		
  		return index;
! 		
  	}
! 	
  	// Execute the SQL:
! 	
  	/**
  	 * Load an instance using either the <tt>forUpdateLoader</tt> or the outer joining <tt>loader</tt>,
  	 * depending upon the value of the <tt>lock</tt> parameter
  	 */
  	public Object load(Serializable id,	Object optionalObject, LockMode lockMode, SessionImplementor session)
  	throws HibernateException, SQLException {
! 		
  		if ( log.isTraceEnabled() ) log.trace( "Materializing entity: " + getClassName() + '#' + id );
! 		
  		return ( (UniqueEntityLoader) loaders.get(lockMode) ).load(session, id, optionalObject);
  	}
! 	
  	/**
  	 * Do a version check
  	 */
  	public void lock(Serializable id, Object version, Object object, LockMode lockMode, SessionImplementor session) throws HibernateException, SQLException {
! 		
  		if ( lockMode.greaterThan(LockMode.NONE) ) {
! 			
  			if ( log.isTraceEnabled() ) {
  				log.trace("Locking entity: " + getClassName() + '#' + id);
  				if ( isVersioned() ) log.trace("Version: " + version);
  			}
! 			
  			PreparedStatement st = session.getBatcher().prepareStatement( (String) lockers.get(lockMode) );
  			try {
  				getIdentifierType().nullSafeSet(st, id, 1, session);
  				if ( isVersioned() ) getVersionType().nullSafeSet(st, version, 2, session);
! 				
  				ResultSet rs = st.executeQuery();
  				try {
  					if ( !rs.next() ) throw new StaleObjectStateException( getMappedClass(), id );
--- 372,418 ----
  				index += propertyColumnSpans[j];
  			}
  		}
! 
  		if ( id!=null ) {
  			getIdentifierType().nullSafeSet( st, id, index, session );
  			index += getIdentifierColumnNames().length;
  		}
! 
  		return index;
! 
  	}
! 
  	// Execute the SQL:
! 
  	/**
  	 * Load an instance using either the <tt>forUpdateLoader</tt> or the outer joining <tt>loader</tt>,
  	 * depending upon the value of the <tt>lock</tt> parameter
  	 */
  	public Object load(Serializable id,	Object optionalObject, LockMode lockMode, SessionImplementor session)
  	throws HibernateException, SQLException {
! 
  		if ( log.isTraceEnabled() ) log.trace( "Materializing entity: " + getClassName() + '#' + id );
! 
  		return ( (UniqueEntityLoader) loaders.get(lockMode) ).load(session, id, optionalObject);
  	}
! 
  	/**
  	 * Do a version check
  	 */
  	public void lock(Serializable id, Object version, Object object, LockMode lockMode, SessionImplementor session) throws HibernateException, SQLException {
! 
  		if ( lockMode.greaterThan(LockMode.NONE) ) {
! 
  			if ( log.isTraceEnabled() ) {
  				log.trace("Locking entity: " + getClassName() + '#' + id);
  				if ( isVersioned() ) log.trace("Version: " + version);
  			}
! 
  			PreparedStatement st = session.getBatcher().prepareStatement( (String) lockers.get(lockMode) );
  			try {
  				getIdentifierType().nullSafeSet(st, id, 1, session);
  				if ( isVersioned() ) getVersionType().nullSafeSet(st, version, 2, session);
! 
  				ResultSet rs = st.executeQuery();
  				try {
  					if ( !rs.next() ) throw new StaleObjectStateException( getMappedClass(), id );
***************
*** 418,472 ****
  			finally {
  				session.getBatcher().closeStatement(st);
  			}
! 			
  		}
! 		
  	}
! 	
  	/**
  	 * Persist an object
  	 */
  	public void insert(Serializable id, Object[] fields, Object object, SessionImplementor session) throws SQLException, HibernateException {
! 		
  		if ( log.isTraceEnabled() ) {
  			log.trace("Inserting entity: " + getClassName() + '#' + id);
  			if ( isVersioned() ) log.trace( "Version: " + Versioning.getVersion(fields, this) );
  		}
! 		
  		// Render the SQL query
  		PreparedStatement statement = session.getBatcher().prepareBatchStatement( getSQLInsertString() );
! 		
  		try {
! 			
  			// Write the values of fields onto the prepared statement - we MUST use the state at the time the
  			// insert was issued (cos of foreign key constraints). Not necessarily the object's current state
! 			
  			dehydrate(id, fields, getPropertyInsertability(), statement, session);
! 			
  			session.getBatcher().addToBatch(1);
  			//statement.executeUpdate();
! 			
  		}
  		catch (SQLException sqle) {
  			JDBCExceptionReporter.logExceptions(sqle);
  			throw sqle;
  		}
! 		
  	}
! 	
  	/**
  	 * Persist an object, using a natively generated identifier
  	 */
  	public Serializable insert(Object[] fields, Object object, SessionImplementor session) throws SQLException, HibernateException {
! 		
  		if ( log.isTraceEnabled() ) {
  			log.trace("Inserting entity: " + getClassName() + " (native id)");
  			if ( isVersioned() ) log.trace( "Version: " + Versioning.getVersion(fields, this) );
  		}
! 		
  		// Render the SQL query
  		PreparedStatement statement = session.getBatcher().prepareStatement( getSQLIdentityInsertString() );
! 		
  		try {
  			dehydrate(null, fields, getPropertyInsertability(), statement, session);
  			statement.executeUpdate();
--- 428,482 ----
  			finally {
  				session.getBatcher().closeStatement(st);
  			}
! 
  		}
! 
  	}
! 
  	/**
  	 * Persist an object
  	 */
  	public void insert(Serializable id, Object[] fields, Object object, SessionImplementor session) throws SQLException, HibernateException {
! 
  		if ( log.isTraceEnabled() ) {
  			log.trace("Inserting entity: " + getClassName() + '#' + id);
  			if ( isVersioned() ) log.trace( "Version: " + Versioning.getVersion(fields, this) );
  		}
! 
  		// Render the SQL query
  		PreparedStatement statement = session.getBatcher().prepareBatchStatement( getSQLInsertString() );
! 
  		try {
! 
  			// Write the values of fields onto the prepared statement - we MUST use the state at the time the
  			// insert was issued (cos of foreign key constraints). Not necessarily the object's current state
! 
  			dehydrate(id, fields, getPropertyInsertability(), statement, session);
! 
  			session.getBatcher().addToBatch(1);
  			//statement.executeUpdate();
! 
  		}
  		catch (SQLException sqle) {
  			JDBCExceptionReporter.logExceptions(sqle);
  			throw sqle;
  		}
! 
  	}
! 
  	/**
  	 * Persist an object, using a natively generated identifier
  	 */
  	public Serializable insert(Object[] fields, Object object, SessionImplementor session) throws SQLException, HibernateException {
! 
  		if ( log.isTraceEnabled() ) {
  			log.trace("Inserting entity: " + getClassName() + " (native id)");
  			if ( isVersioned() ) log.trace( "Version: " + Versioning.getVersion(fields, this) );
  		}
! 
  		// Render the SQL query
  		PreparedStatement statement = session.getBatcher().prepareStatement( getSQLIdentityInsertString() );
! 
  		try {
  			dehydrate(null, fields, getPropertyInsertability(), statement, session);
  			statement.executeUpdate();
***************
*** 478,489 ****
  		finally {
  			session.getBatcher().closeStatement(statement);
  		}
! 		
  		// fetch the generated id:
  		PreparedStatement idselect = session.getBatcher().prepareStatement( sqlIdentitySelect() );
! 		
  		try {
! 			
  			ResultSet rs = idselect.executeQuery();
  			final Serializable id;
  			try {
--- 488,499 ----
  		finally {
  			session.getBatcher().closeStatement(statement);
  		}
! 
  		// fetch the generated id:
  		PreparedStatement idselect = session.getBatcher().prepareStatement( sqlIdentitySelect() );
! 
  		try {
! 
  			ResultSet rs = idselect.executeQuery();
  			final Serializable id;
  			try {
***************
*** 494,500 ****
  				rs.close();
  			}
  			log.debug("Natively generated identity: " + id);
! 			
  			return id;
  		}
  		catch (SQLException sqle) {
--- 504,510 ----
  				rs.close();
  			}
  			log.debug("Natively generated identity: " + id);
! 
  			return id;
  		}
  		catch (SQLException sqle) {
***************
*** 504,522 ****
  		finally {
  			session.getBatcher().closeStatement(idselect);
  		}
! 		
  	}
! 	
  	/**
  	 * Delete an object
  	 */
  	public void delete(Serializable id, Object version, Object object, SessionImplementor session) throws SQLException, HibernateException {
! 		
  		if ( log.isTraceEnabled() ) {
  			log.trace("Deleting entity: " + getClassName() + '#' + id);
  			if ( isVersioned() ) log.trace( "Version: " + version );
  		}
! 		
  		//Render the SQL query
  		final PreparedStatement statement;// = session.getPreparedStatement( sqlDelete() );
  		if ( isVersioned() ) {
--- 514,532 ----
  		finally {
  			session.getBatcher().closeStatement(idselect);
  		}
! 
  	}
! 
  	/**
  	 * Delete an object
  	 */
  	public void delete(Serializable id, Object version, Object object, SessionImplementor session) throws SQLException, HibernateException {
! 
  		if ( log.isTraceEnabled() ) {
  			log.trace("Deleting entity: " + getClassName() + '#' + id);
  			if ( isVersioned() ) log.trace( "Version: " + version );
  		}
! 
  		//Render the SQL query
  		final PreparedStatement statement;// = session.getPreparedStatement( sqlDelete() );
  		if ( isVersioned() ) {
***************
*** 525,540 ****
  		else {
  			statement = session.getBatcher().prepareBatchStatement( getSQLDeleteString() );
  		}
! 		
  		try {
! 			
  			// Do the key. The key is immutable so we can use the _current_ object state - not necessarily
  			// the state at the time the delete was issued
! 			
  			getIdentifierType().nullSafeSet( statement, id, 1, session );
! 			
  			// We should use the _current_ object state (ie. after any updates that occurred during flush)
! 			
  			if ( isVersioned() ) {
  				getVersionType().nullSafeSet( statement, version, getIdentifierColumnNames().length + 1, session );
  				check( statement.executeUpdate(), id );
--- 535,550 ----
  		else {
  			statement = session.getBatcher().prepareBatchStatement( getSQLDeleteString() );
  		}
! 
  		try {
! 
  			// Do the key. The key is immutable so we can use the _current_ object state - not necessarily
  			// the state at the time the delete was issued
! 
  			getIdentifierType().nullSafeSet( statement, id, 1, session );
! 
  			// We should use the _current_ object state (ie. after any updates that occurred during flush)
! 
  			if ( isVersioned() ) {
  				getVersionType().nullSafeSet( statement, version, getIdentifierColumnNames().length + 1, session );
  				check( statement.executeUpdate(), id );
***************
*** 543,549 ****
  				session.getBatcher().addToBatch(1);
  			}
  			//check( statement.executeUpdate(), id );
! 			
  		}
  		catch (SQLException sqle) {
  			JDBCExceptionReporter.logExceptions(sqle);
--- 553,559 ----
  				session.getBatcher().addToBatch(1);
  			}
  			//check( statement.executeUpdate(), id );
! 
  		}
  		catch (SQLException sqle) {
  			JDBCExceptionReporter.logExceptions(sqle);
***************
*** 553,559 ****
  			if ( isVersioned() ) session.getBatcher().closeStatement(statement);
  		}
  	}
! 	
  	/**
  	 * Update an object
  	 */
--- 563,569 ----
  			if ( isVersioned() ) session.getBatcher().closeStatement(statement);
  		}
  	}
! 
  	/**
  	 * Update an object
  	 */
***************
*** 565,571 ****
  				for (int j=0; j<dirtyFields.length; j++) {
  					if ( dirtyFields[j]==i ) dirty=true;
  				}
! 				propsToUpdate[i] = dirty || getVersionProperty()==i; 
  				//don't need to check property mutability (dirty checking algorithm handles that)
  			}
  			update(id, fields, propsToUpdate, oldVersion, object, generateUpdateString(propsToUpdate), session);
--- 575,581 ----
  				for (int j=0; j<dirtyFields.length; j++) {
  					if ( dirtyFields[j]==i ) dirty=true;
  				}
! 				propsToUpdate[i] = dirty || getVersionProperty()==i;
  				//don't need to check property mutability (dirty checking algorithm handles that)
  			}
  			update(id, fields, propsToUpdate, oldVersion, object, generateUpdateString(propsToUpdate), session);
***************
*** 574,588 ****
  			update(id, fields, getPropertyUpdateability(), oldVersion, object, getSQLUpdateString(), session);
  		}
  	}
! 	
  	protected void update(Serializable id, Object[] fields, boolean[] includeProperty, Object oldVersion, Object object, String sql, SessionImplementor session) throws SQLException, HibernateException {
  		if ( log.isTraceEnabled() ) {
  			log.trace("Updating entity: " + getClassName() + '#' + id);
  			if ( isVersioned() ) log.trace( "Existing version: " + oldVersion + " -> New version: " + fields[ getVersionProperty() ] );
  		}
! 		
  		if (!hasUpdateableColumns) return;
! 		
  		final PreparedStatement statement;
  		if ( isVersioned() ) {
  			statement = session.getBatcher().prepareStatement(sql);
--- 584,598 ----
  			update(id, fields, getPropertyUpdateability(), oldVersion, object, getSQLUpdateString(), session);
  		}
  	}
! 
  	protected void update(Serializable id, Object[] fields, boolean[] includeProperty, Object oldVersion, Object object, String sql, SessionImplementor session) throws SQLException, HibernateException {
  		if ( log.isTraceEnabled() ) {
  			log.trace("Updating entity: " + getClassName() + '#' + id);
  			if ( isVersioned() ) log.trace( "Existing version: " + oldVersion + " -> New version: " + fields[ getVersionProperty() ] );
  		}
! 
  		if (!hasUpdateableColumns) return;
! 
  		final PreparedStatement statement;
  		if ( isVersioned() ) {
  			statement = session.getBatcher().prepareStatement(sql);
***************
*** 590,602 ****
  		else {
  			statement = session.getBatcher().prepareBatchStatement(sql);
  		}
! 		
  		try {
! 			
  			//Now write the values of fields onto the prepared statement
! 			
  			int versionParam = dehydrate(id, fields, includeProperty, statement, session);
! 			
  			if ( isVersioned() ) {
  				getVersionType().nullSafeSet( statement, oldVersion, versionParam, session );
  				check( statement.executeUpdate(), id );
--- 600,612 ----
  		else {
  			statement = session.getBatcher().prepareBatchStatement(sql);
  		}
! 
  		try {
! 
  			//Now write the values of fields onto the prepared statement
! 
  			int versionParam = dehydrate(id, fields, includeProperty, statement, session);
! 
  			if ( isVersioned() ) {
  				getVersionType().nullSafeSet( statement, oldVersion, versionParam, session );
  				check( statement.executeUpdate(), id );
***************
*** 604,610 ****
  			else {
  				session.getBatcher().addToBatch(1);
  			}
! 			
  		}
  		catch (SQLException sqle) {
  			JDBCExceptionReporter.logExceptions(sqle);
--- 614,620 ----
  			else {
  				session.getBatcher().addToBatch(1);
  			}
! 
  		}
  		catch (SQLException sqle) {
  			JDBCExceptionReporter.logExceptions(sqle);
***************
*** 613,637 ****
  		finally {
  			if ( isVersioned() ) session.getBatcher().closeStatement(statement);
  		}
! 		
  	}
! 	
  	//INITIALIZATION:
! 	
  	public EntityPersister(PersistentClass model, SessionFactoryImplementor factory) throws MappingException {
! 		
  		super(model, factory);
! 		
  		// CLASS + TABLE
! 		
  		Class mappedClass = model.getPersistentClass();
  		this.factory = factory;
  		Table table = model.getRootTable();
  		qualifiedTableName = table.getQualifiedName( factory.getDefaultSchema() );
  		tableNames = new String[] { qualifiedTableName };
! 		
  		// DISCRIMINATOR
! 		
  		final Object discriminatorValue;
  		if ( model.isPolymorphic() ) {
  			Value d = model.getDiscriminator();
--- 623,647 ----
  		finally {
  			if ( isVersioned() ) session.getBatcher().closeStatement(statement);
  		}
! 
  	}
! 
  	//INITIALIZATION:
! 
  	public EntityPersister(PersistentClass model, SessionFactoryImplementor factory) throws MappingException {
! 
  		super(model, factory);
! 
  		// CLASS + TABLE
! 
  		Class mappedClass = model.getPersistentClass();
  		this.factory = factory;
  		Table table = model.getRootTable();
  		qualifiedTableName = table.getQualifiedName( factory.getDefaultSchema() );
  		tableNames = new String[] { qualifiedTableName };
! 
  		// DISCRIMINATOR
! 
  		final Object discriminatorValue;
  		if ( model.isPolymorphic() ) {
  			Value d = model.getDiscriminator();
***************
*** 663,687 ****
  			discriminatorValue = null;
  			discriminatorSQLString = null;
  		}
! 		
  		// PROPERTIES
! 		
  		propertyColumnNames = new String[hydrateSpan][];
  		propertyColumnAliases = new String[hydrateSpan][];
  		propertyColumnSpans = new int[hydrateSpan];
  		HashSet thisClassProperties = new HashSet();
! 		
  		Iterator iter = model.getPropertyClosureIterator();
  		int i=0;
! 		
  		boolean foundColumn = false;
  		while( iter.hasNext() ) {
  			Property prop = (Property) iter.next();
  			int span = prop.getColumnSpan();
  			propertyColumnSpans[i] = span;
  			thisClassProperties.add(prop);
! 			
  			String[] colNames = new String[span];
  			String[] colAliases = new String[span];
  			Iterator colIter = prop.getColumnIterator();
  			int j=0;
--- 673,699 ----
  			discriminatorValue = null;
  			discriminatorSQLString = null;
  		}
! 
  		// PROPERTIES
! 
  		propertyColumnNames = new String[hydrateSpan][];
+     propertyColumnTypes = new Type[hydrateSpan][];
  		propertyColumnAliases = new String[hydrateSpan][];
  		propertyColumnSpans = new int[hydrateSpan];
  		HashSet thisClassProperties = new HashSet();
! 
  		Iterator iter = model.getPropertyClosureIterator();
  		int i=0;
! 
  		boolean foundColumn = false;
  		while( iter.hasNext() ) {
  			Property prop = (Property) iter.next();
  			int span = prop.getColumnSpan();
  			propertyColumnSpans[i] = span;
  			thisClassProperties.add(prop);
! 
  			String[] colNames = new String[span];
+       Type[]   colTypes = new Type[span];
  			String[] colAliases = new String[span];
  			Iterator colIter = prop.getColumnIterator();
  			int j=0;
***************
*** 689,717 ****
  				Column col = (Column) colIter.next();
  				colAliases[j] = col.getAlias();
  				colNames[j] = col.getName();
  				j++;
  				if ( prop.isUpdateable() ) foundColumn=true;
  			}
  			propertyColumnNames[i] = colNames;
  			propertyColumnAliases[i] = colAliases;
! 			
  			//initPropertyPaths(prop, StringHelper.EMPTY_STRING, factory);
  			i++;
  		}
! 		
  		/*if ( model.hasIdentifierProperty() && model.getIdentifierProperty().isComposite() ) {
  			initPropertyPaths( model.getIdentifierProperty(), StringHelper.EMPTY_STRING, factory );
  		}*/
! 		
  		hasUpdateableColumns = foundColumn;
! 		
  		ArrayList columns = new ArrayList();
  		ArrayList types = new ArrayList();
  		ArrayList propColumns = new ArrayList();
  		ArrayList aliases = new ArrayList();
  		ArrayList joinedFetchesList = new ArrayList();
  		ArrayList definedBySubclass = new ArrayList();
! 		
  		iter = model.getSubclassPropertyClosureIterator();
  		while ( iter.hasNext() ) {
  			Property prop = (Property) iter.next();
--- 701,731 ----
  				Column col = (Column) colIter.next();
  				colAliases[j] = col.getAlias();
  				colNames[j] = col.getName();
+         colTypes[j] = col.getType();
  				j++;
  				if ( prop.isUpdateable() ) foundColumn=true;
  			}
  			propertyColumnNames[i] = colNames;
+       propertyColumnTypes[i] = colTypes;
  			propertyColumnAliases[i] = colAliases;
! 
  			//initPropertyPaths(prop, StringHelper.EMPTY_STRING, factory);
  			i++;
  		}
! 
  		/*if ( model.hasIdentifierProperty() && model.getIdentifierProperty().isComposite() ) {
  			initPropertyPaths( model.getIdentifierProperty(), StringHelper.EMPTY_STRING, factory );
  		}*/
! 
  		hasUpdateableColumns = foundColumn;
! 
  		ArrayList columns = new ArrayList();
  		ArrayList types = new ArrayList();
  		ArrayList propColumns = new ArrayList();
  		ArrayList aliases = new ArrayList();
  		ArrayList joinedFetchesList = new ArrayList();
  		ArrayList definedBySubclass = new ArrayList();
! 
  		iter = model.getSubclassPropertyClosureIterator();
  		while ( iter.hasNext() ) {
  			Property prop = (Property) iter.next();
***************
*** 735,741 ****
  		subclassPropertyTypeClosure = (Type[]) types.toArray(TYPE_ARRAY);
  		subclassPropertyColumnNameClosure = (String[][]) propColumns.toArray( new String[ propColumns.size() ][] );
  		subclassColumnAliasClosure = (String[]) aliases.toArray(STRING_ARRAY);
! 		
  		subclassPropertyEnableJoinedFetch = new int[ joinedFetchesList.size() ];
  		iter = joinedFetchesList.iterator();
  		int j=0;
--- 749,755 ----
  		subclassPropertyTypeClosure = (Type[]) types.toArray(TYPE_ARRAY);
  		subclassPropertyColumnNameClosure = (String[][]) propColumns.toArray( new String[ propColumns.size() ][] );
  		subclassColumnAliasClosure = (String[]) aliases.toArray(STRING_ARRAY);
! 
  		subclassPropertyEnableJoinedFetch = new int[ joinedFetchesList.size() ];
  		iter = joinedFetchesList.iterator();
  		int j=0;
***************
*** 744,765 ****
  		iter = definedBySubclass.iterator();
  		j=0;
  		while ( iter.hasNext() ) propertyDefinedOnSubclass[j++] = ( (Boolean) iter.next() ).booleanValue();
! 		
  		sqlDeleteString = generateDeleteString();
  		sqlInsertString = generateInsertString( false, getPropertyInsertability() );
! 		sqlIdentityInsertString = isIdentifierAssignedByInsert() ? 
! 			generateInsertString( true, getPropertyInsertability() ) : 
  			null;
  		sqlUpdateString = generateUpdateString( getPropertyUpdateability() );
! 		
  		String lockString = generateLockString();
  		lockers.put(LockMode.READ, lockString);
  		String lockExclusiveString = dialect.supportsForUpdate() ? lockString + " for update" : lockString;
  		lockers.put(LockMode.UPGRADE, lockExclusiveString);
  		String lockExclusiveNowaitString = dialect.supportsForUpdateNowait() ? lockString + " for update nowait" : lockExclusiveString;
  		lockers.put(LockMode.UPGRADE_NOWAIT, lockExclusiveNowaitString);
! 		
! 		
  		int subclassSpan = model.getSubclassSpan() + 1;
  		subclassClosure = new Class[subclassSpan];
  		subclassClosure[0] = mappedClass;
--- 758,779 ----
  		iter = definedBySubclass.iterator();
  		j=0;
  		while ( iter.hasNext() ) propertyDefinedOnSubclass[j++] = ( (Boolean) iter.next() ).booleanValue();
! 
  		sqlDeleteString = generateDeleteString();
  		sqlInsertString = generateInsertString( false, getPropertyInsertability() );
! 		sqlIdentityInsertString = isIdentifierAssignedByInsert() ?
! 			generateInsertString( true, getPropertyInsertability() ) :
  			null;
  		sqlUpdateString = generateUpdateString( getPropertyUpdateability() );
! 
  		String lockString = generateLockString();
  		lockers.put(LockMode.READ, lockString);
  		String lockExclusiveString = dialect.supportsForUpdate() ? lockString + " for update" : lockString;
  		lockers.put(LockMode.UPGRADE, lockExclusiveString);
  		String lockExclusiveNowaitString = dialect.supportsForUpdateNowait() ? lockString + " for update nowait" : lockExclusiveString;
  		lockers.put(LockMode.UPGRADE_NOWAIT, lockExclusiveNowaitString);
! 
! 
  		int subclassSpan = model.getSubclassSpan() + 1;
  		subclassClosure = new Class[subclassSpan];
  		subclassClosure[0] = mappedClass;
***************
*** 771,777 ****
  				subclassesByDiscriminatorValue.put(discriminatorValue, mappedClass);
  			}
  		}
! 		
  		// SUBCLASSES
  		if ( model.isPolymorphic() ) {
  			iter = model.getSubclassIterator();
--- 785,791 ----
  				subclassesByDiscriminatorValue.put(discriminatorValue, mappedClass);
  			}
  		}
! 
  		// SUBCLASSES
  		if ( model.isPolymorphic() ) {
  			iter = model.getSubclassIterator();
***************
*** 795,831 ****
  				}
  			}
  		}
! 		
  	}
! 	
  	private void initPropertyPaths(Mapping mapping) throws MappingException {
! 		
  		Type[] propertyTypes = getPropertyTypes();
  		String[] propertyNames = getPropertyNames();
  		for ( int i=0; i<propertyNames.length; i++ ) {
  			initPropertyPaths( propertyNames[i], propertyTypes[i], propertyColumnNames[i], mapping );
  		}
! 		
  		String idProp = getIdentifierPropertyName();
  		if (idProp!=null) initPropertyPaths( idProp, getIdentifierType(), getIdentifierColumnNames(), mapping );
  		if ( hasEmbeddedIdentifier() ) initPropertyPaths( null, getIdentifierType(), getIdentifierColumnNames(), mapping );
  		initPropertyPaths( PathExpressionParser.ENTITY_ID, getIdentifierType(), getIdentifierColumnNames(), mapping );
! 		
  		if ( isPolymorphic() ) {
  			typesByPropertyPath.put( PathExpressionParser.ENTITY_CLASS, getDiscriminatorType() );
  			columnNamesByPropertyPath.put( PathExpressionParser.ENTITY_CLASS, new String[] { getDiscriminatorColumnName() } );
  		}
  	}
! 	
  	private void initPropertyPaths(String propertyName, Type propertyType, String[] columns, Mapping mapping) throws MappingException {
! 		
  		if (propertyName!=null) {
  			typesByPropertyPath.put(propertyName, propertyType);
  			columnNamesByPropertyPath.put(propertyName, columns);
  		}
! 	
  		if ( propertyType.isComponentType() ) {
! 			AbstractComponentType compType = (AbstractComponentType) propertyType; 
  			String[] props = compType.getPropertyNames();
  			Type[] types = compType.getSubtypes();
  			int count=0;
--- 809,845 ----
  				}
  			}
  		}
! 
  	}
! 
  	private void initPropertyPaths(Mapping mapping) throws MappingException {
! 
  		Type[] propertyTypes = getPropertyTypes();
  		String[] propertyNames = getPropertyNames();
  		for ( int i=0; i<propertyNames.length; i++ ) {
  			initPropertyPaths( propertyNames[i], propertyTypes[i], propertyColumnNames[i], mapping );
  		}
! 
  		String idProp = getIdentifierPropertyName();
  		if (idProp!=null) initPropertyPaths( idProp, getIdentifierType(), getIdentifierColumnNames(), mapping );
  		if ( hasEmbeddedIdentifier() ) initPropertyPaths( null, getIdentifierType(), getIdentifierColumnNames(), mapping );
  		initPropertyPaths( PathExpressionParser.ENTITY_ID, getIdentifierType(), getIdentifierColumnNames(), mapping );
! 
  		if ( isPolymorphic() ) {
  			typesByPropertyPath.put( PathExpressionParser.ENTITY_CLASS, getDiscriminatorType() );
  			columnNamesByPropertyPath.put( PathExpressionParser.ENTITY_CLASS, new String[] { getDiscriminatorColumnName() } );
  		}
  	}
! 
  	private void initPropertyPaths(String propertyName, Type propertyType, String[] columns, Mapping mapping) throws MappingException {
! 
  		if (propertyName!=null) {
  			typesByPropertyPath.put(propertyName, propertyType);
  			columnNamesByPropertyPath.put(propertyName, columns);
  		}
! 
  		if ( propertyType.isComponentType() ) {
! 			AbstractComponentType compType = (AbstractComponentType) propertyType;
  			String[] props = compType.getPropertyNames();
  			Type[] types = compType.getSubtypes();
  			int count=0;
***************
*** 840,856 ****
  			}
  		}
  	}
! 		
  	public String[] getTableNames() {
  		return tableNames;
  	}
! 	
  	public String fromTableFragment(String name) {
  		return getTableName() + ' '  + name;
  	}
  
  	public String queryWhereFragment(String name, boolean innerJoin, boolean includeSubclasses) throws MappingException {
! 		
  		if ( innerJoin && ( forceDiscriminator || isInherited() ) ) {
  			InFragment frag = new InFragment()
  				.setColumn( name, getDiscriminatorColumnName() );
--- 854,870 ----
  			}
  		}
  	}
! 
  	public String[] getTableNames() {
  		return tableNames;
  	}
! 
  	public String fromTableFragment(String name) {
  		return getTableName() + ' '  + name;
  	}
  
  	public String queryWhereFragment(String name, boolean innerJoin, boolean includeSubclasses) throws MappingException {
! 
  		if ( innerJoin && ( forceDiscriminator || isInherited() ) ) {
  			InFragment frag = new InFragment()
  				.setColumn( name, getDiscriminatorColumnName() );
***************
*** 865,904 ****
  		else {
  			return StringHelper.EMPTY_STRING;
  		}
! 		
  	}
! 	
  	public String[] toColumns(String name, String property) throws QueryException {
! 		
  		String[] cols = getPropertyColumnNames(property);
! 		
  		if (cols==null) throw new QueryException("unresolved property: " + property);
! 		
  		if (cols.length==0) {
  			// ie. a nested collection or a one-to-one
  			cols = getIdentifierColumnNames();
  		}
! 		
  		return StringHelper.prefix(cols, name + StringHelper.DOT);
  	}
! 	
  	public String[] toColumns(String name, int i) {
  		return StringHelper.prefix( subclassPropertyColumnNameClosure[i], name + StringHelper.DOT );
  	}
! 	
  	public String propertySelectFragment(String name, String suffix) {
! 		
  		SelectFragment frag = new SelectFragment()
  			.setSuffix(suffix);
  		if ( hasSubclasses() ) frag.addColumn( name, getDiscriminatorColumnName() );
  		return frag.addColumns( name, subclassColumnClosure, subclassColumnAliasClosure )
  			.toFragmentString();
  	}
! 	
  	public String getConcreteClassAlias(String alias) {
  		return alias;
  	}
! 	
  	public String fromJoinFragment(String alias, boolean innerJoin, boolean includeSubclasses) {
  		return StringHelper.EMPTY_STRING;
  	}
--- 879,918 ----
  		else {
  			return StringHelper.EMPTY_STRING;
  		}
! 
  	}
! 
  	public String[] toColumns(String name, String property) throws QueryException {
! 
  		String[] cols = getPropertyColumnNames(property);
! 
  		if (cols==null) throw new QueryException("unresolved property: " + property);
! 
  		if (cols.length==0) {
  			// ie. a nested collection or a one-to-one
  			cols = getIdentifierColumnNames();
  		}
! 
  		return StringHelper.prefix(cols, name + StringHelper.DOT);
  	}
! 
  	public String[] toColumns(String name, int i) {
  		return StringHelper.prefix( subclassPropertyColumnNameClosure[i], name + StringHelper.DOT );
  	}
! 
  	public String propertySelectFragment(String name, String suffix) {
! 
  		SelectFragment frag = new SelectFragment()
  			.setSuffix(suffix);
  		if ( hasSubclasses() ) frag.addColumn( name, getDiscriminatorColumnName() );
  		return frag.addColumns( name, subclassColumnClosure, subclassColumnAliasClosure )
  			.toFragmentString();
  	}
! 
  	public String getConcreteClassAlias(String alias) {
  		return alias;
  	}
! 
  	public String fromJoinFragment(String alias, boolean innerJoin, boolean includeSubclasses) {
  		return StringHelper.EMPTY_STRING;
  	}
Index: hibernate-2.0/src/net/sf/hibernate/persister/Loadable.java
diff -c hibernate-2.0/src/net/sf/hibernate/persister/Loadable.java:1.1.1.1 hibernate-2.0/src/net/sf/hibernate/persister/Loadable.java:1.2
*** hibernate-2.0/src/net/sf/hibernate/persister/Loadable.java:1.1.1.1	Tue Apr 22 11:17:23 2003
--- hibernate-2.0/src/net/sf/hibernate/persister/Loadable.java	Tue Apr 22 13:32:16 2003
***************
*** 1,4 ****
! //$Id: Loadable.java,v 1.1.1.1 2003/04/22 16:17:23 paulsenj Exp $
  package net.sf.hibernate.persister;
  
  import net.sf.hibernate.type.DiscriminatorType;
--- 1,4 ----
! //$Id: Loadable.java,v 1.2 2003/04/22 18:32:16 paulsenj Exp $
  package net.sf.hibernate.persister;
  
  import net.sf.hibernate.type.DiscriminatorType;
***************
*** 12,79 ****
   * @see net.sf.hibernate.loader.OuterJoinLoader
   */
  public interface Loadable extends ClassPersister {
! 	
  	/**
  	 * Get the names of columns used to persist the identifier
  	 */
  	public String[] getIdentifierColumnNames();
! 	
  	/**
  	 * Does this persistent class have subclasses?
  	 */
  	public boolean hasSubclasses();
! 	
  	/**
  	 * Get the name of the column used as a discriminator
  	 */
  	public String getDiscriminatorColumnName();
! 	
  	/**
  	 * Get the discriminator type
  	 */
  	public DiscriminatorType getDiscriminatorType();
! 	
  	/**
  	 * Get the concrete subclass corresponding to the given discriminator
  	 * value
  	 */
  	public Class getSubclassForDiscriminatorValue(Object value);
! 	
  	/**
  	 * Get the column names for the numbered property of <em>this</em> class
  	 */
  	public String[] getPropertyColumnNames(int i);
! 	
  	//USED BY OuterJoinLoader + subclasses
! 	
  	/**
  	 * Get the fully-qualified tablename used to persist this class
  	 */
  	public String getTableName();
! 	
  	/**
  	 * How many properties are there, for this class and all subclasses?
  	 * (optional operation)
  	 */
  	public int countSubclassProperties();
! 	
  	/**
  	 * May this property be fetched using an SQL outerjoin?
  	 * (optional operation)
  	 */
  	public int enableJoinedFetch(int i);
! 	
  	/**
  	 * Is this property defined on a subclass of the mapped class?
  	 */
  	public boolean isDefinedOnSubclass(int i);
! 	
  	/**
  	 * Get an array of the types of all properties of all subclasses
  	 * (optional operation)
  	 */
  	public Type getSubclassPropertyType(int i);
! 	
  	/**
  	 * Return the column names used to persist all properties of
  	 * all subclasses of the persistent class
--- 12,84 ----
   * @see net.sf.hibernate.loader.OuterJoinLoader
   */
  public interface Loadable extends ClassPersister {
! 
  	/**
  	 * Get the names of columns used to persist the identifier
  	 */
  	public String[] getIdentifierColumnNames();
! 
!   /**
!    * Get the types of columns used to persist the identifier
!    */
!   public Type[] getIdentifierColumnTypes();
! 
  	/**
  	 * Does this persistent class have subclasses?
  	 */
  	public boolean hasSubclasses();
! 
  	/**
  	 * Get the name of the column used as a discriminator
  	 */
  	public String getDiscriminatorColumnName();
! 
  	/**
  	 * Get the discriminator type
  	 */
  	public DiscriminatorType getDiscriminatorType();
! 
  	/**
  	 * Get the concrete subclass corresponding to the given discriminator
  	 * value
  	 */
  	public Class getSubclassForDiscriminatorValue(Object value);
! 
  	/**
  	 * Get the column names for the numbered property of <em>this</em> class
  	 */
  	public String[] getPropertyColumnNames(int i);
! 
  	//USED BY OuterJoinLoader + subclasses
! 
  	/**
  	 * Get the fully-qualified tablename used to persist this class
  	 */
  	public String getTableName();
! 
  	/**
  	 * How many properties are there, for this class and all subclasses?
  	 * (optional operation)
  	 */
  	public int countSubclassProperties();
! 
  	/**
  	 * May this property be fetched using an SQL outerjoin?
  	 * (optional operation)
  	 */
  	public int enableJoinedFetch(int i);
! 
  	/**
  	 * Is this property defined on a subclass of the mapped class?
  	 */
  	public boolean isDefinedOnSubclass(int i);
! 
  	/**
  	 * Get an array of the types of all properties of all subclasses
  	 * (optional operation)
  	 */
  	public Type getSubclassPropertyType(int i);
! 
  	/**
  	 * Return the column names used to persist all properties of
  	 * all subclasses of the persistent class
***************
*** 86,98 ****
  	 * (optional operation)
  	 */
  	public String[] toColumns(String name, int i);
! 	
  	/**
  	 * Get the table alias for the particular subclass state
  	 * (optional operation)
  	 */
  	public String getConcreteClassAlias(String alias);
! 	
  	/**
  	 * Given a query alias and an identifying suffix, render the
  	 * intentifier select fragment
--- 91,103 ----
  	 * (optional operation)
  	 */
  	public String[] toColumns(String name, int i);
! 
  	/**
  	 * Get the table alias for the particular subclass state
  	 * (optional operation)
  	 */
  	public String getConcreteClassAlias(String alias);
! 
  	/**
  	 * Given a query alias and an identifying suffix, render the
  	 * intentifier select fragment
***************
*** 119,125 ****
  	 * (optional operation)
  	 */
  	public String fromJoinFragment(String alias, boolean innerJoin, boolean includeSubclasses);
! 	
  }
  
  
--- 124,130 ----
  	 * (optional operation)
  	 */
  	public String fromJoinFragment(String alias, boolean innerJoin, boolean includeSubclasses);
! 
  }
  
  
Index: hibernate-2.0/src/net/sf/hibernate/persister/NormalizedEntityPersister.java
diff -c hibernate-2.0/src/net/sf/hibernate/persister/NormalizedEntityPersister.java:1.1.1.2 hibernate-2.0/src/net/sf/hibernate/persister/NormalizedEntityPersister.java:1.3
*** hibernate-2.0/src/net/sf/hibernate/persister/NormalizedEntityPersister.java:1.1.1.2	Tue Apr 22 14:28:25 2003
--- hibernate-2.0/src/net/sf/hibernate/persister/NormalizedEntityPersister.java	Tue Apr 22 16:33:27 2003
***************
*** 1,9 ****
! //$Id: NormalizedEntityPersister.java,v 1.1.1.2 2003/04/22 19:28:25 paulsenj Exp $
  package net.sf.hibernate.persister;
  
  import net.sf.hibernate.util.ArrayHelper;
  import net.sf.hibernate.util.JDBCExceptionReporter;
  import net.sf.hibernate.util.StringHelper;
  import net.sf.hibernate.loader.EntityLoader;
  import net.sf.hibernate.loader.UniqueEntityLoader;
  import net.sf.hibernate.mapping.Column;
--- 1,10 ----
! //$Id: NormalizedEntityPersister.java,v 1.3 2003/04/22 21:33:27 paulsenj Exp $
  package net.sf.hibernate.persister;
  
  import net.sf.hibernate.util.ArrayHelper;
  import net.sf.hibernate.util.JDBCExceptionReporter;
  import net.sf.hibernate.util.StringHelper;
+ import net.sf.hibernate.util.TypeHelper;
  import net.sf.hibernate.loader.EntityLoader;
  import net.sf.hibernate.loader.UniqueEntityLoader;
  import net.sf.hibernate.mapping.Column;
***************
*** 56,87 ****
   * mapping strategy.<br>
   */
  public class NormalizedEntityPersister extends AbstractEntityPersister {
! 	
  	private final SessionFactoryImplementor factory;
! 	
  	// the class hierarchy structure
  	private final String qualifiedTableName;
  	private final String[] tableNames;
  	private final String[][] tableKeyColumns;
! 	
  	private final Class[] subclassClosure;
  	private final String[] subclassTableNameClosure;
  	private final String[][] subclassTableKeyColumns;
  	private final boolean[] isClassOrSuperclassTable;
! 	
  	// SQL strings
  	private final String[] sqlDeleteStrings;
  	private final String[] sqlInsertStrings;
  	private final String[] sqlIdentityInsertStrings;
  	private final String[] sqlUpdateStrings;
! 	
  	// properties of this class, including inherited properties
  	private final int[] propertyColumnSpans;
  	private final int[] propertyTables;
  	private final boolean[] propertyHasColumns;
  	private final String[][] propertyColumnNames;
  	private final String[][] propertyColumnNameAliases;
! 	
  	// the closure of all properties in the entire hierarchy including
  	// subclasses and superclasses of this class
  	private final String[][] subclassPropertyColumnNameClosure;
--- 57,89 ----
   * mapping strategy.<br>
   */
  public class NormalizedEntityPersister extends AbstractEntityPersister {
! 
  	private final SessionFactoryImplementor factory;
! 
  	// the class hierarchy structure
  	private final String qualifiedTableName;
  	private final String[] tableNames;
  	private final String[][] tableKeyColumns;
!   private final Type[][] tableKeyColumnTypes;
  	private final Class[] subclassClosure;
  	private final String[] subclassTableNameClosure;
  	private final String[][] subclassTableKeyColumns;
  	private final boolean[] isClassOrSuperclassTable;
! 
  	// SQL strings
  	private final String[] sqlDeleteStrings;
  	private final String[] sqlInsertStrings;
  	private final String[] sqlIdentityInsertStrings;
  	private final String[] sqlUpdateStrings;
! 
  	// properties of this class, including inherited properties
  	private final int[] propertyColumnSpans;
  	private final int[] propertyTables;
  	private final boolean[] propertyHasColumns;
  	private final String[][] propertyColumnNames;
+   private final Type[][] propertyColumnTypes;
  	private final String[][] propertyColumnNameAliases;
! 
  	// the closure of all properties in the entire hierarchy including
  	// subclasses and superclasses of this class
  	private final String[][] subclassPropertyColumnNameClosure;
***************
*** 89,103 ****
  	private final Type[] subclassPropertyTypeClosure;
  	private final int[] subclassPropertyEnableJoinedFetch;
  	private final boolean[] propertyDefinedOnSubclass;
! 	
  	private final HashMap tableNumberByPropertyPath = new HashMap();
! 	
  	// the closure of all columns used by the entire hierarchy including
  	// subclasses and superclasses of this class
  	private final String[] subclassColumnClosure;
  	private final String[] subclassColumnClosureAliases;
  	private final int[] subclassColumnTableNumberClosure;
! 	
  	// subclass discrimination works by assigning particular
  	// values to certain combinations of null primary key
  	// values in the outer join using an SQL CASE
--- 91,105 ----
  	private final Type[] subclassPropertyTypeClosure;
  	private final int[] subclassPropertyEnableJoinedFetch;
  	private final boolean[] propertyDefinedOnSubclass;
! 
  	private final HashMap tableNumberByPropertyPath = new HashMap();
! 
  	// the closure of all columns used by the entire hierarchy including
  	// subclasses and superclasses of this class
  	private final String[] subclassColumnClosure;
  	private final String[] subclassColumnClosureAliases;
  	private final int[] subclassColumnTableNumberClosure;
! 
  	// subclass discrimination works by assigning particular
  	// values to certain combinations of null primary key
  	// values in the outer join using an SQL CASE
***************
*** 105,130 ****
  	private final String[] discriminators;
  	private final String[] notNullColumns;
  	private final int[] tableNumbers;
! 	
  	private final DiscriminatorType discriminatorType;
  	private final String discriminatorSQLString;
  	private final String discriminatorColumnName;
! 	
  	protected UniqueEntityLoader loader;
  	protected final Map lockers = new HashMap();
! 	
  	private final boolean[] allProperties;
! 	
  	private static final String[] STRING_ARRAY = {};
  	private static final Type[] TYPE_ARRAY = {};
  	private static final Class[] NO_CLASSES = new Class[0];
! 	
  	private static final Log log = LogFactory.getLog(NormalizedEntityPersister.class);
! 	
  	public void postInstantiate(SessionFactoryImplementor factory) throws MappingException {
! 		
  		initPropertyPaths(factory);
! 		
  		//TODO: move into initPropertyPaths
  		HashMap mods = new HashMap();
  		Iterator iter = typesByPropertyPath.entrySet().iterator();
--- 107,132 ----
  	private final String[] discriminators;
  	private final String[] notNullColumns;
  	private final int[] tableNumbers;
! 
  	private final DiscriminatorType discriminatorType;
  	private final String discriminatorSQLString;
  	private final String discriminatorColumnName;
! 
  	protected UniqueEntityLoader loader;
  	protected final Map lockers = new HashMap();
! 
  	private final boolean[] allProperties;
! 
  	private static final String[] STRING_ARRAY = {};
  	private static final Type[] TYPE_ARRAY = {};
  	private static final Class[] NO_CLASSES = new Class[0];
! 
  	private static final Log log = LogFactory.getLog(NormalizedEntityPersister.class);
! 
  	public void postInstantiate(SessionFactoryImplementor factory) throws MappingException {
! 
  		initPropertyPaths(factory);
! 
  		//TODO: move into initPropertyPaths
  		HashMap mods = new HashMap();
  		Iterator iter = typesByPropertyPath.entrySet().iterator();
***************
*** 142,148 ****
  				}
  				EntityType etype = (EntityType) type;
  				Type idType = factory.getIdentifierType( etype.getPersistentClass() );
! 				
  				String idpath = path + StringHelper.DOT + PathExpressionParser.ENTITY_ID;
  				mods.put(idpath, idType);
  				columnNamesByPropertyPath.put(idpath, columns);
--- 144,150 ----
  				}
  				EntityType etype = (EntityType) type;
  				Type idType = factory.getIdentifierType( etype.getPersistentClass() );
! 
  				String idpath = path + StringHelper.DOT + PathExpressionParser.ENTITY_ID;
  				mods.put(idpath, idType);
  				columnNamesByPropertyPath.put(idpath, columns);
***************
*** 161,423 ****
  			}
  		}
  		typesByPropertyPath.putAll(mods);
! 		
! 		
  		loader = //new SimpleEntityLoader(this, generateSelectString(), LockMode.READ);
  		new EntityLoader(this, factory);
! 		
  	}
! 	
! 	
  	public boolean isDefinedOnSubclass(int i) {
  		return propertyDefinedOnSubclass[i];
  	}
! 	
  	public String getTableName() {
  		return qualifiedTableName;
  	}
! 	
  	public String getDiscriminatorColumnName() {
  		return discriminatorColumnName;
  	}
! 	
  	public Type getSubclassPropertyType(int i) {
  		return subclassPropertyTypeClosure[i];
  	}
  	public int countSubclassProperties() {
  		return subclassPropertyTypeClosure.length;
  	}
! 	
  	public String[] getSubclassPropertyColumnNames(int i) {
  		return subclassPropertyColumnNameClosure[i];
  	}
! 	
  	public String[] getPropertyColumnNames(int i) {
  		return propertyColumnNameAliases[i];
  	}
! 	
  	public DiscriminatorType getDiscriminatorType() {
  		return discriminatorType;
  	}
! 	
  	public String getDiscriminatorSQLString() {
  		return discriminatorSQLString;
  	}
! 	
  	public Class[] getSubclassClosure() {
  		return subclassClosure;
  	}
! 	
  	public Class getSubclassForDiscriminatorValue(Object value) {
  		return (Class) subclassesByDiscriminatorValue.get(value);
  	}
! 	
  	public int enableJoinedFetch(int i) {
  		return subclassPropertyEnableJoinedFetch[i];
  	}
! 	
  	public Serializable getIdentifierSpace() {
  		return qualifiedTableName;
  	}
! 	
  	public Serializable[] getPropertySpaces() {
  		return tableNames; // don't need subclass tables, because they can't appear in conditions
  	}
! 	
  	//Access cached SQL
! 	
  	/**
  	 * The queries that delete rows by id (and version)
  	 */
  	protected final String[] getSQLDeleteStrings() {
  		return sqlDeleteStrings;
  	}
! 	
  	/**
  	 * The queries that insert rows with a given id
  	 */
  	protected final String[] getSQLInsertStrings() {
  		return sqlInsertStrings;
  	}
! 	
  	/**
  	 * The queries that insert rows, letting the database generate an id
  	 */
  	protected final String[] getSQLIdentityInsertStrings() {
  		return sqlIdentityInsertStrings;
  	}
! 	
  	/**
  	 * The queries that update rows by id (and version)
  	 */
  	protected final String[] getSQLUpdateStrings() {
  		return sqlUpdateStrings;
  	}
! 	
  	// Generate all the SQL
! 	
  	/**
  	 * Generate the SQL that deletes rows by id (and version)
  	 */
  	protected String[] generateDeleteStrings() {
! 		String[] result = new String[ tableNames.length ];
  		for ( int i=0; i<tableNames.length; i++ ) {
  			Delete delete = new Delete()
  				.setTableName( tableNames[i] )
! 				.setPrimaryKeyColumnNames( tableKeyColumns[i] );
  			if (i==0) delete.setVersionColumnName( getVersionColumnName() );
  			result[i] = delete.toStatementString();
  		}
  		return result;
  	}
! 	
  	/**
  	 * Generate the SQL that inserts rows
  	 */
  	protected String[] generateInsertStrings(boolean identityInsert, boolean[] includeProperty) {
! 		
  		String[] result = new String[tableNames.length];
  		for ( int j=0; j<tableNames.length; j++ ) {
! 			
  			Insert insert = new Insert(dialect)
  				.setTableName( tableNames[j] );
! 				
  			for (int i=0; i<getPropertyTypes().length; i++) {
  				if ( includeProperty[i] && propertyTables[i]==j ) {
! 					insert.addColumns( propertyColumnNames[i] );
  				}
  			}
! 			
  			if (identityInsert && j==0) {
  				insert.addIdentityColumn( tableKeyColumns[j][0] );
  			}
  			else {
! 				insert.addColumns( tableKeyColumns[j] );
  			}
! 			
  			result[j] = insert.toStatementString();
! 			
  		}
  		return result;
  	}
! 	
  	/**
  	 * Generate the SQL that updates rows by id (and version)
  	 */
  	protected String[] generateUpdateStrings(boolean[] includeProperty) {
  		String[] result = new String[ tableNames.length ];
  		for ( int j=0; j<tableNames.length; j++ ) {
  			Update update = new Update()
  				.setTableName( tableNames[j] )
! 				.setPrimaryKeyColumnNames( tableKeyColumns[j] );
! 				
  			if (j==0) update.setVersionColumnName( getVersionColumnName() );
! 			
  			boolean hasColumns = false;
  			for (int i=0; i<propertyColumnNames.length; i++) {
  				if ( includeProperty[i] && propertyTables[i]==j ) {
! 					update.addColumns( propertyColumnNames[i] );
  					hasColumns = hasColumns || propertyColumnNames[i].length > 0;
  				}
  			}
! 			
  			result[j] = hasColumns ? update.toStatementString() : null;
  		}
  		return result;
  	}
! 	
  	/**
  	 * Generate the SQL that pessimistic locks a row by id (and version)
  	 */
  	protected String generateLockString() {
  		SimpleSelect select = new SimpleSelect()
  			.setTableName( getTableName() )
  			.addColumn( getIdentifierColumnNames()[0] )
! 			.addCondition( getIdentifierColumnNames(), "=?" );
  		if ( isVersioned() ) {
  			select.addWhereToken("and")
  				.addCondition( getVersionColumnName(), "=?" );
  		}
  		return select.toStatementString();
  	}
! 	
  	/**
  	 * Marshall the fields of a persistent instance to a prepared statement
  	 */
  	protected int dehydrate(Serializable id, Object[] fields, boolean[] includeProperty, PreparedStatement[] statements, SessionImplementor session) throws SQLException, HibernateException {
! 		
  		if ( log.isTraceEnabled() ) log.trace("Dehydrating entity: " + getClassName() + '#' + id);
! 		
  		int versionParam = 0;
! 		
  		for ( int i=0; i<tableNames.length; i++ ) {
  			int index = dehydrate(id, fields, includeProperty, i, statements[i], session);
  			if (i==0) versionParam = index;
  		}
! 		
  		return versionParam;
! 		
  	}
! 	
  	private int dehydrate(Serializable id, Object[] fields, boolean[] includeProperty, int table, PreparedStatement statement, SessionImplementor session) throws SQLException, HibernateException {
! 		
  		if (statement==null) return -1;
! 		
  		int index = 1;
! 		
  		for (int j=0; j<hydrateSpan; j++) {
! 			
  			if ( includeProperty[j] && propertyTables[j]==table ) {
  				getPropertyTypes()[j].nullSafeSet( statement, fields[j], index, session );
  				index += propertyColumnSpans[j];
  			}
! 			
  		}
! 		
  		if ( id!=null ) {
  			getIdentifierType().nullSafeSet( statement, id, index, session );
  			index+=getIdentifierColumnNames().length;
  		}
! 		
  		return index;
  	}
! 	
! 	
  	// Execute the SQL:
! 	
  	/**
  	 * Load an instance using either the <tt>forUpdateLoader</tt> or the outer joining <tt>loader</tt>,
  	 * depending upon the value of the <tt>lock</tt> parameter
  	 */
  	public Object load(Serializable id,	Object optionalObject, LockMode lockMode, SessionImplementor session)
  	throws HibernateException, SQLException {
! 		
  		if ( log.isTraceEnabled() ) log.trace( "Materializing entity: " + getClassName() + '#' + id );
! 		
  		Object result = loader.load(session, id, optionalObject);
! 		
  		if (result!=null) lock(id, getVersion(result), result, lockMode, session);
! 		
  		return result;
  	}
! 	
  	/**
  	 * Do a version check
  	 */
  	public void lock(Serializable id, Object version, Object object, LockMode lockMode, SessionImplementor session) throws HibernateException, SQLException {
! 		
  		if ( lockMode.greaterThan(LockMode.NONE) ) {
! 			
  			if ( log.isTraceEnabled() ) {
  				log.trace("Locking entity: " + getClassName() + '#' + id);
  				if ( isVersioned() ) log.trace("Version: " + version);
  			}
! 			
  			PreparedStatement st = session.getBatcher().prepareStatement( (String) lockers.get(lockMode) );
  			try {
  				getIdentifierType().nullSafeSet(st, id, 1, session);
  				if ( isVersioned() ) getVersionType().nullSafeSet(st, version, 2, session);
! 				
  				ResultSet rs = st.executeQuery();
  				try {
  					if ( !rs.next() ) throw new StaleObjectStateException(getMappedClass(), id);
--- 163,431 ----
  			}
  		}
  		typesByPropertyPath.putAll(mods);
! 
! 
  		loader = //new SimpleEntityLoader(this, generateSelectString(), LockMode.READ);
  		new EntityLoader(this, factory);
! 
  	}
! 
! 
  	public boolean isDefinedOnSubclass(int i) {
  		return propertyDefinedOnSubclass[i];
  	}
! 
  	public String getTableName() {
  		return qualifiedTableName;
  	}
! 
  	public String getDiscriminatorColumnName() {
  		return discriminatorColumnName;
  	}
! 
  	public Type getSubclassPropertyType(int i) {
  		return subclassPropertyTypeClosure[i];
  	}
  	public int countSubclassProperties() {
  		return subclassPropertyTypeClosure.length;
  	}
! 
  	public String[] getSubclassPropertyColumnNames(int i) {
  		return subclassPropertyColumnNameClosure[i];
  	}
! 
  	public String[] getPropertyColumnNames(int i) {
  		return propertyColumnNameAliases[i];
  	}
! 
  	public DiscriminatorType getDiscriminatorType() {
  		return discriminatorType;
  	}
! 
  	public String getDiscriminatorSQLString() {
  		return discriminatorSQLString;
  	}
! 
  	public Class[] getSubclassClosure() {
  		return subclassClosure;
  	}
! 
  	public Class getSubclassForDiscriminatorValue(Object value) {
  		return (Class) subclassesByDiscriminatorValue.get(value);
  	}
! 
  	public int enableJoinedFetch(int i) {
  		return subclassPropertyEnableJoinedFetch[i];
  	}
! 
  	public Serializable getIdentifierSpace() {
  		return qualifiedTableName;
  	}
! 
  	public Serializable[] getPropertySpaces() {
  		return tableNames; // don't need subclass tables, because they can't appear in conditions
  	}
! 
  	//Access cached SQL
! 
  	/**
  	 * The queries that delete rows by id (and version)
  	 */
  	protected final String[] getSQLDeleteStrings() {
  		return sqlDeleteStrings;
  	}
! 
  	/**
  	 * The queries that insert rows with a given id
  	 */
  	protected final String[] getSQLInsertStrings() {
  		return sqlInsertStrings;
  	}
! 
  	/**
  	 * The queries that insert rows, letting the database generate an id
  	 */
  	protected final String[] getSQLIdentityInsertStrings() {
  		return sqlIdentityInsertStrings;
  	}
! 
  	/**
  	 * The queries that update rows by id (and version)
  	 */
  	protected final String[] getSQLUpdateStrings() {
  		return sqlUpdateStrings;
  	}
! 
  	// Generate all the SQL
! 
  	/**
  	 * Generate the SQL that deletes rows by id (and version)
  	 */
  	protected String[] generateDeleteStrings() {
!     // use type placeholders to construct sql
!     String[] result = new String[ tableNames.length ];
  		for ( int i=0; i<tableNames.length; i++ ) {
  			Delete delete = new Delete()
  				.setTableName( tableNames[i] )
! 				.setPrimaryKeyColumnNames( tableKeyColumns[i] )
!         .setPrimaryKeyColumnPlaceHolders( TypeHelper.getPlaceHolders(tableKeyColumnTypes[i]) );
  			if (i==0) delete.setVersionColumnName( getVersionColumnName() );
  			result[i] = delete.toStatementString();
  		}
  		return result;
  	}
! 
  	/**
  	 * Generate the SQL that inserts rows
  	 */
  	protected String[] generateInsertStrings(boolean identityInsert, boolean[] includeProperty) {
! 
!     // use type placeholders to construct sql
  		String[] result = new String[tableNames.length];
  		for ( int j=0; j<tableNames.length; j++ ) {
! 
  			Insert insert = new Insert(dialect)
  				.setTableName( tableNames[j] );
! 
  			for (int i=0; i<getPropertyTypes().length; i++) {
  				if ( includeProperty[i] && propertyTables[i]==j ) {
! 					insert.addColumns( propertyColumnNames[i], TypeHelper.getPlaceHolders(propertyColumnTypes[i]) );
  				}
  			}
! 
  			if (identityInsert && j==0) {
  				insert.addIdentityColumn( tableKeyColumns[j][0] );
  			}
  			else {
! 				insert.addColumns( tableKeyColumns[j], TypeHelper.getPlaceHolders(tableKeyColumnTypes[j]) );
  			}
! 
  			result[j] = insert.toStatementString();
! 
  		}
  		return result;
  	}
! 
  	/**
  	 * Generate the SQL that updates rows by id (and version)
  	 */
  	protected String[] generateUpdateStrings(boolean[] includeProperty) {
+     // use type placeholders when constructing sql
  		String[] result = new String[ tableNames.length ];
  		for ( int j=0; j<tableNames.length; j++ ) {
  			Update update = new Update()
  				.setTableName( tableNames[j] )
! 				.setPrimaryKeyColumnNames( tableKeyColumns[j] )
!         .setPrimaryKeyColumnPlaceHolders( TypeHelper.getPlaceHolders(tableKeyColumnTypes[j]));
! 
  			if (j==0) update.setVersionColumnName( getVersionColumnName() );
! 
  			boolean hasColumns = false;
  			for (int i=0; i<propertyColumnNames.length; i++) {
  				if ( includeProperty[i] && propertyTables[i]==j ) {
! 					update.addColumns( propertyColumnNames[i], TypeHelper.getPlaceHolders(propertyColumnTypes[i]) );
  					hasColumns = hasColumns || propertyColumnNames[i].length > 0;
  				}
  			}
! 
  			result[j] = hasColumns ? update.toStatementString() : null;
  		}
  		return result;
  	}
! 
  	/**
  	 * Generate the SQL that pessimistic locks a row by id (and version)
  	 */
  	protected String generateLockString() {
+     // use type placeholders when constructing sql
  		SimpleSelect select = new SimpleSelect()
  			.setTableName( getTableName() )
  			.addColumn( getIdentifierColumnNames()[0] )
! 			.addCondition( getIdentifierColumnNames(), "=", TypeHelper.getPlaceHolders(getIdentifierColumnTypes()) );
  		if ( isVersioned() ) {
  			select.addWhereToken("and")
  				.addCondition( getVersionColumnName(), "=?" );
  		}
  		return select.toStatementString();
  	}
! 
  	/**
  	 * Marshall the fields of a persistent instance to a prepared statement
  	 */
  	protected int dehydrate(Serializable id, Object[] fields, boolean[] includeProperty, PreparedStatement[] statements, SessionImplementor session) throws SQLException, HibernateException {
! 
  		if ( log.isTraceEnabled() ) log.trace("Dehydrating entity: " + getClassName() + '#' + id);
! 
  		int versionParam = 0;
! 
  		for ( int i=0; i<tableNames.length; i++ ) {
  			int index = dehydrate(id, fields, includeProperty, i, statements[i], session);
  			if (i==0) versionParam = index;
  		}
! 
  		return versionParam;
! 
  	}
! 
  	private int dehydrate(Serializable id, Object[] fields, boolean[] includeProperty, int table, PreparedStatement statement, SessionImplementor session) throws SQLException, HibernateException {
! 
  		if (statement==null) return -1;
! 
  		int index = 1;
! 
  		for (int j=0; j<hydrateSpan; j++) {
! 
  			if ( includeProperty[j] && propertyTables[j]==table ) {
  				getPropertyTypes()[j].nullSafeSet( statement, fields[j], index, session );
  				index += propertyColumnSpans[j];
  			}
! 
  		}
! 
  		if ( id!=null ) {
  			getIdentifierType().nullSafeSet( statement, id, index, session );
  			index+=getIdentifierColumnNames().length;
  		}
! 
  		return index;
  	}
! 
! 
  	// Execute the SQL:
! 
  	/**
  	 * Load an instance using either the <tt>forUpdateLoader</tt> or the outer joining <tt>loader</tt>,
  	 * depending upon the value of the <tt>lock</tt> parameter
  	 */
  	public Object load(Serializable id,	Object optionalObject, LockMode lockMode, SessionImplementor session)
  	throws HibernateException, SQLException {
! 
  		if ( log.isTraceEnabled() ) log.trace( "Materializing entity: " + getClassName() + '#' + id );
! 
  		Object result = loader.load(session, id, optionalObject);
! 
  		if (result!=null) lock(id, getVersion(result), result, lockMode, session);
! 
  		return result;
  	}
! 
  	/**
  	 * Do a version check
  	 */
  	public void lock(Serializable id, Object version, Object object, LockMode lockMode, SessionImplementor session) throws HibernateException, SQLException {
! 
  		if ( lockMode.greaterThan(LockMode.NONE) ) {
! 
  			if ( log.isTraceEnabled() ) {
  				log.trace("Locking entity: " + getClassName() + '#' + id);
  				if ( isVersioned() ) log.trace("Version: " + version);
  			}
! 
  			PreparedStatement st = session.getBatcher().prepareStatement( (String) lockers.get(lockMode) );
  			try {
  				getIdentifierType().nullSafeSet(st, id, 1, session);
  				if ( isVersioned() ) getVersionType().nullSafeSet(st, version, 2, session);
! 
  				ResultSet rs = st.executeQuery();
  				try {
  					if ( !rs.next() ) throw new StaleObjectStateException(getMappedClass(), id);
***************
*** 433,468 ****
  			finally {
  				session.getBatcher().closeStatement(st);
  			}
! 			
  		}
! 		
  	}
! 	
  	/**
  	 * Persist an object
  	 */
  	public void insert(Serializable id, Object[] fields, Object object, SessionImplementor session) throws SQLException, HibernateException {
! 		
  		if ( log.isTraceEnabled() ) {
  			log.trace("Inserting entity: " + getClassName() + '#' + id);
  			if ( isVersioned() ) log.trace( "Version: " + Versioning.getVersion(fields, this) );
  		}
! 		
  		// Render the SQL query
  		final PreparedStatement[] statements = new PreparedStatement[ tableNames.length ];
  		try {
! 			
  			for ( int i=0; i<tableNames.length; i++ ) {
  				statements[i] = session.getBatcher().prepareStatement( getSQLInsertStrings()[i] );
  			}
! 			
  			// Write the values of fields onto the prepared statement - we MUST use the state at the time the
  			// insert was issued (cos of foreign key constraints). Not necessarily the object's current state
! 			
  			dehydrate(id, fields, getPropertyInsertability(), statements, session);
! 			
  			for ( int i=0; i<tableNames.length; i++ ) statements[i].executeUpdate();
! 			
  		}
  		catch (SQLException sqle) {
  			JDBCExceptionReporter.logExceptions(sqle);
--- 441,476 ----
  			finally {
  				session.getBatcher().closeStatement(st);
  			}
! 
  		}
! 
  	}
! 
  	/**
  	 * Persist an object
  	 */
  	public void insert(Serializable id, Object[] fields, Object object, SessionImplementor session) throws SQLException, HibernateException {
! 
  		if ( log.isTraceEnabled() ) {
  			log.trace("Inserting entity: " + getClassName() + '#' + id);
  			if ( isVersioned() ) log.trace( "Version: " + Versioning.getVersion(fields, this) );
  		}
! 
  		// Render the SQL query
  		final PreparedStatement[] statements = new PreparedStatement[ tableNames.length ];
  		try {
! 
  			for ( int i=0; i<tableNames.length; i++ ) {
  				statements[i] = session.getBatcher().prepareStatement( getSQLInsertStrings()[i] );
  			}
! 
  			// Write the values of fields onto the prepared statement - we MUST use the state at the time the
  			// insert was issued (cos of foreign key constraints). Not necessarily the object's current state
! 
  			dehydrate(id, fields, getPropertyInsertability(), statements, session);
! 
  			for ( int i=0; i<tableNames.length; i++ ) statements[i].executeUpdate();
! 
  		}
  		catch (SQLException sqle) {
  			JDBCExceptionReporter.logExceptions(sqle);
***************
*** 473,493 ****
  				if ( statements[i]!=null ) session.getBatcher().closeStatement( statements[i] );
  			}
  		}
! 		
  	}
! 	
  	/**
  	 * Persist an object, using a natively generated identifier
  	 */
  	public Serializable insert(Object[] fields, Object object, SessionImplementor session) throws SQLException, HibernateException {
! 		
  		if ( log.isTraceEnabled() ) {
  			log.trace("Inserting entity: " + getClassName() + " (native id)");
  			if ( isVersioned() ) log.trace( "Version: " + Versioning.getVersion(fields, this) );
  		}
! 		
  		String[] sql = getSQLIdentityInsertStrings();
! 		
  		PreparedStatement statement = session.getBatcher().prepareStatement( sql[0] );
  		try {
  			dehydrate(null, fields, allProperties, 0, statement, session);
--- 481,501 ----
  				if ( statements[i]!=null ) session.getBatcher().closeStatement( statements[i] );
  			}
  		}
! 
  	}
! 
  	/**
  	 * Persist an object, using a natively generated identifier
  	 */
  	public Serializable insert(Object[] fields, Object object, SessionImplementor session) throws SQLException, HibernateException {
! 
  		if ( log.isTraceEnabled() ) {
  			log.trace("Inserting entity: " + getClassName() + " (native id)");
  			if ( isVersioned() ) log.trace( "Version: " + Versioning.getVersion(fields, this) );
  		}
! 
  		String[] sql = getSQLIdentityInsertStrings();
! 
  		PreparedStatement statement = session.getBatcher().prepareStatement( sql[0] );
  		try {
  			dehydrate(null, fields, allProperties, 0, statement, session);
***************
*** 500,511 ****
  		finally {
  			session.getBatcher().closeStatement(statement);
  		}
! 		
  		// fetch the generated id:
  		PreparedStatement idselect = session.getBatcher().prepareStatement( sqlIdentitySelect() );
  		final Serializable id;
  		try {
! 			
  			ResultSet rs = idselect.executeQuery();
  			try {
  				if ( !rs.next() ) throw new HibernateException("The database returned no natively generated identity value");
--- 508,519 ----
  		finally {
  			session.getBatcher().closeStatement(statement);
  		}
! 
  		// fetch the generated id:
  		PreparedStatement idselect = session.getBatcher().prepareStatement( sqlIdentitySelect() );
  		final Serializable id;
  		try {
! 
  			ResultSet rs = idselect.executeQuery();
  			try {
  				if ( !rs.next() ) throw new HibernateException("The database returned no natively generated identity value");
***************
*** 515,521 ****
  				rs.close();
  			}
  			log.debug("Natively generated identity: " + id);
! 			
  		}
  		catch (SQLException sqle) {
  			JDBCExceptionReporter.logExceptions(sqle);
--- 523,529 ----
  				rs.close();
  			}
  			log.debug("Natively generated identity: " + id);
! 
  		}
  		catch (SQLException sqle) {
  			JDBCExceptionReporter.logExceptions(sqle);
***************
*** 524,534 ****
  		finally {
  			session.getBatcher().closeStatement(idselect);
  		}
! 		
  		for ( int i=1; i<tableNames.length; i++ )  {
! 			
  			statement = session.getBatcher().prepareStatement( sql[i] );
! 			
  			try {
  				dehydrate(id, fields, allProperties, i, statement, session);
  				statement.executeUpdate();
--- 532,542 ----
  		finally {
  			session.getBatcher().closeStatement(idselect);
  		}
! 
  		for ( int i=1; i<tableNames.length; i++ )  {
! 
  			statement = session.getBatcher().prepareStatement( sql[i] );
! 
  			try {
  				dehydrate(id, fields, allProperties, i, statement, session);
  				statement.executeUpdate();
***************
*** 540,582 ****
  			finally {
  				session.getBatcher().closeStatement(statement);
  			}
! 			
  		}
! 		
  		return id;
! 		
  	}
! 	
  	/**
  	 * Delete an object
  	 */
  	public void delete(Serializable id, Object version, Object object, SessionImplementor session) throws SQLException, HibernateException {
! 		
  		if ( log.isTraceEnabled() ) {
  			log.trace("Deleting entity: " + getClassName() + '#' + id);
  			//if (versioned) log.trace( "Version: " + version );
  		}
! 		
  		final PreparedStatement[] statements = new PreparedStatement[tableNames.length];
  		try {
! 			
  			for ( int i=0; i<tableNames.length; i++ ) {
  				statements[i] = session.getBatcher().prepareStatement( getSQLDeleteStrings()[i] );
  			}
! 			
  			if ( isVersioned() ) getVersionType().nullSafeSet( statements[0], version, getIdentifierColumnNames().length + 1, session );
! 			
  			for ( int i=tableNames.length-1; i>=0; i-- ) {
! 				
  				// Do the key. The key is immutable so we can use the _current_ object state - not necessarily
  				// the state at the time the delete was issued
! 				
  				getIdentifierType().nullSafeSet( statements[i], id, 1, session );
! 				
  				check( statements[i].executeUpdate(), id );
! 				
  			}
! 			
  		}
  		catch (SQLException sqle) {
  			JDBCExceptionReporter.logExceptions(sqle);
--- 548,590 ----
  			finally {
  				session.getBatcher().closeStatement(statement);
  			}
! 
  		}
! 
  		return id;
! 
  	}
! 
  	/**
  	 * Delete an object
  	 */
  	public void delete(Serializable id, Object version, Object object, SessionImplementor session) throws SQLException, HibernateException {
! 
  		if ( log.isTraceEnabled() ) {
  			log.trace("Deleting entity: " + getClassName() + '#' + id);
  			//if (versioned) log.trace( "Version: " + version );
  		}
! 
  		final PreparedStatement[] statements = new PreparedStatement[tableNames.length];
  		try {
! 
  			for ( int i=0; i<tableNames.length; i++ ) {
  				statements[i] = session.getBatcher().prepareStatement( getSQLDeleteStrings()[i] );
  			}
! 
  			if ( isVersioned() ) getVersionType().nullSafeSet( statements[0], version, getIdentifierColumnNames().length + 1, session );
! 
  			for ( int i=tableNames.length-1; i>=0; i-- ) {
! 
  				// Do the key. The key is immutable so we can use the _current_ object state - not necessarily
  				// the state at the time the delete was issued
! 
  				getIdentifierType().nullSafeSet( statements[i], id, 1, session );
! 
  				check( statements[i].executeUpdate(), id );
! 
  			}
! 
  		}
  		catch (SQLException sqle) {
  			JDBCExceptionReporter.logExceptions(sqle);
***************
*** 588,594 ****
  			}
  		}
  	}
! 	
  	/**
  	 * Update an object
  	 */
--- 596,602 ----
  			}
  		}
  	}
! 
  	/**
  	 * Update an object
  	 */
***************
*** 621,651 ****
  			update(id, fields, getPropertyUpdateability(), tableUpdateNeeded, oldVersion, object, getSQLUpdateStrings(), session);
  		}
  	}
! 	
  	protected void update(Serializable id, Object[] fields, boolean[] includeProperty, boolean[] includeTable, Object oldVersion, Object object, String[] sql, SessionImplementor session) throws SQLException, HibernateException {
! 		
  		if ( log.isTraceEnabled() ) {
  			log.trace("Updating entity: " + getClassName() + '#' + id);
  			if ( isVersioned() ) log.trace( "Existing version: " + oldVersion + " -> New version: " + fields[ getVersionProperty() ] );
  		}
! 		
  		int tables = tableNames.length;
! 		
  		final PreparedStatement[] statements = new PreparedStatement[tables];
  		try {
! 			
  			for ( int i=0; i<tables; i++ ) {
  				if ( includeTable[i] ) statements[i] = session.getBatcher().prepareStatement( sql[i] );
  			}
! 			
  			int versionParam = dehydrate(id, fields, includeProperty, statements, session);
! 			
  			if ( isVersioned() ) getVersionType().nullSafeSet( statements[0], oldVersion, versionParam, session );
! 			
  			for ( int i=0; i<tables; i++ ) {
  				if ( includeTable[i] ) check( statements[i].executeUpdate(), id );
  			}
! 			
  		}
  		catch (SQLException sqle) {
  			JDBCExceptionReporter.logExceptions(sqle);
--- 629,659 ----
  			update(id, fields, getPropertyUpdateability(), tableUpdateNeeded, oldVersion, object, getSQLUpdateStrings(), session);
  		}
  	}
! 
  	protected void update(Serializable id, Object[] fields, boolean[] includeProperty, boolean[] includeTable, Object oldVersion, Object object, String[] sql, SessionImplementor session) throws SQLException, HibernateException {
! 
  		if ( log.isTraceEnabled() ) {
  			log.trace("Updating entity: " + getClassName() + '#' + id);
  			if ( isVersioned() ) log.trace( "Existing version: " + oldVersion + " -> New version: " + fields[ getVersionProperty() ] );
  		}
! 
  		int tables = tableNames.length;
! 
  		final PreparedStatement[] statements = new PreparedStatement[tables];
  		try {
! 
  			for ( int i=0; i<tables; i++ ) {
  				if ( includeTable[i] ) statements[i] = session.getBatcher().prepareStatement( sql[i] );
  			}
! 
  			int versionParam = dehydrate(id, fields, includeProperty, statements, session);
! 
  			if ( isVersioned() ) getVersionType().nullSafeSet( statements[0], oldVersion, versionParam, session );
! 
  			for ( int i=0; i<tables; i++ ) {
  				if ( includeTable[i] ) check( statements[i].executeUpdate(), id );
  			}
! 
  		}
  		catch (SQLException sqle) {
  			JDBCExceptionReporter.logExceptions(sqle);
***************
*** 656,678 ****
  				if ( statements[i]!=null ) session.getBatcher().closeStatement( statements[i] );
  			}
  		}
! 		
  	}
! 	
  	//INITIALIZATION:
! 	
  	public NormalizedEntityPersister(PersistentClass model, SessionFactoryImplementor factory) throws MappingException {
! 		
  		super(model, factory);
! 		
  		// CLASS + TABLE
! 		
  		this.factory = factory;
  		Table table = model.getRootTable();
  		qualifiedTableName = table.getQualifiedName( factory.getDefaultSchema() );
! 		
  		// DISCRIMINATOR
! 		
  		final Object discriminatorValue;
  		if ( model.isPolymorphic() ) {
  			discriminatorColumnName = "clazz_";
--- 664,686 ----
  				if ( statements[i]!=null ) session.getBatcher().closeStatement( statements[i] );
  			}
  		}
! 
  	}
! 
  	//INITIALIZATION:
! 
  	public NormalizedEntityPersister(PersistentClass model, SessionFactoryImplementor factory) throws MappingException {
! 
  		super(model, factory);
! 
  		// CLASS + TABLE
! 
  		this.factory = factory;
  		Table table = model.getRootTable();
  		qualifiedTableName = table.getQualifiedName( factory.getDefaultSchema() );
! 
  		// DISCRIMINATOR
! 
  		final Object discriminatorValue;
  		if ( model.isPolymorphic() ) {
  			discriminatorColumnName = "clazz_";
***************
*** 691,704 ****
  			discriminatorValue = null;
  			discriminatorSQLString = null;
  		}
! 		
  		//MULTITABLES
! 		
  		ArrayList tables = new ArrayList();
  		ArrayList keyColumns = new ArrayList();
  		tables.add(qualifiedTableName);
  		keyColumns.add( getIdentifierColumnNames() );
! 		
  		int idColumnSpan = getIdentifierType().getColumnSpan(factory);
  		Iterator titer = model.getTableClosureIterator();
  		while ( titer.hasNext() ) {
--- 699,714 ----
  			discriminatorValue = null;
  			discriminatorSQLString = null;
  		}
! 
  		//MULTITABLES
! 
  		ArrayList tables = new ArrayList();
  		ArrayList keyColumns = new ArrayList();
+     ArrayList keyColumnTypes = new ArrayList();
  		tables.add(qualifiedTableName);
  		keyColumns.add( getIdentifierColumnNames() );
!     keyColumnTypes.add(getIdentifierColumnTypes());
! 
  		int idColumnSpan = getIdentifierType().getColumnSpan(factory);
  		Iterator titer = model.getTableClosureIterator();
  		while ( titer.hasNext() ) {
***************
*** 707,720 ****
  			if ( !tabname.equals(qualifiedTableName) ) {
  				tables.add(tabname);
  				String[] key = new String[idColumnSpan];
  				Iterator kiter = tab.getPrimaryKey().getColumnIterator();
! 				for ( int k=0; k<idColumnSpan; k++ ) key[k] = ( (Column) kiter.next() ).getName();
  				keyColumns.add(key);
  			}
  		}
  		tableNames = (String[]) tables.toArray( new String[0] );
  		tableKeyColumns = (String[][]) keyColumns.toArray( new String[0][] );
! 		
  		ArrayList subtables = new ArrayList();
  		keyColumns = new ArrayList();
  		subtables.add(qualifiedTableName);
--- 717,737 ----
  			if ( !tabname.equals(qualifiedTableName) ) {
  				tables.add(tabname);
  				String[] key = new String[idColumnSpan];
+         Type[] keyType = new Type[idColumnSpan];
  				Iterator kiter = tab.getPrimaryKey().getColumnIterator();
! 				for ( int k=0; k<idColumnSpan; k++ ) {
!           Column col = (Column) kiter.next();
!           key[k] = col.getName();
!           keyType[k] = col.getType();
!         }
  				keyColumns.add(key);
+         keyColumnTypes.add(keyType);
  			}
  		}
  		tableNames = (String[]) tables.toArray( new String[0] );
  		tableKeyColumns = (String[][]) keyColumns.toArray( new String[0][] );
!     tableKeyColumnTypes = (Type[][]) keyColumnTypes.toArray( new Type[0][] );
! 
  		ArrayList subtables = new ArrayList();
  		keyColumns = new ArrayList();
  		subtables.add(qualifiedTableName);
***************
*** 737,755 ****
  		for ( int j=0; j<subclassTableNameClosure.length; j++ ) {
  			isClassOrSuperclassTable[j] = tables.contains( subclassTableNameClosure[j] );
  		}
! 		
  		// PROPERTIES
! 		
  		propertyTables = new int[hydrateSpan];
  		propertyColumnNames = new String[hydrateSpan][];
  		propertyColumnNameAliases = new String[hydrateSpan][];
  		propertyColumnSpans = new int[hydrateSpan];
! 		
  		HashSet thisClassProperties = new HashSet();
! 		
  		Iterator iter = model.getPropertyClosureIterator();
  		int i=0;
! 		
  		while( iter.hasNext() ) {
  			Property prop = (Property) iter.next();
  			thisClassProperties.add(prop);
--- 754,773 ----
  		for ( int j=0; j<subclassTableNameClosure.length; j++ ) {
  			isClassOrSuperclassTable[j] = tables.contains( subclassTableNameClosure[j] );
  		}
! 
  		// PROPERTIES
! 
  		propertyTables = new int[hydrateSpan];
  		propertyColumnNames = new String[hydrateSpan][];
+     propertyColumnTypes = new Type[hydrateSpan][];
  		propertyColumnNameAliases = new String[hydrateSpan][];
  		propertyColumnSpans = new int[hydrateSpan];
! 
  		HashSet thisClassProperties = new HashSet();
! 
  		Iterator iter = model.getPropertyClosureIterator();
  		int i=0;
! 
  		while( iter.hasNext() ) {
  			Property prop = (Property) iter.next();
  			thisClassProperties.add(prop);
***************
*** 757,764 ****
  			String tabname = tab.getQualifiedName( factory.getDefaultSchema() );
  			propertyTables[i] = getTableId(tabname, tableNames);
  			propertyColumnSpans[i] = prop.getColumnSpan();
! 			
  			String[] propCols = new String[ propertyColumnSpans[i] ];
  			String[] propAliases = new String[ propertyColumnSpans[i] ];
  			Iterator colIter = prop.getColumnIterator();
  			int j=0;
--- 775,783 ----
  			String tabname = tab.getQualifiedName( factory.getDefaultSchema() );
  			propertyTables[i] = getTableId(tabname, tableNames);
  			propertyColumnSpans[i] = prop.getColumnSpan();
! 
  			String[] propCols = new String[ propertyColumnSpans[i] ];
+       Type[]   propTypes = new Type[propertyColumnSpans[i]];
  			String[] propAliases = new String[ propertyColumnSpans[i] ];
  			Iterator colIter = prop.getColumnIterator();
  			int j=0;
***************
*** 766,780 ****
  				Column col = (Column) colIter.next();
  				String colname = col.getName();
  				propCols[j] = colname;
  				propAliases[j] = col.getAlias() + tab.getUniqueInteger() + StringHelper.UNDERSCORE;
  				j++;
  			}
  			propertyColumnNames[i] = propCols;
  			propertyColumnNameAliases[i] = propAliases;
! 			
  			i++;
  		}
! 		
  		ArrayList columns = new ArrayList();
  		ArrayList types = new ArrayList();
  		ArrayList propColumns = new ArrayList();
--- 785,801 ----
  				Column col = (Column) colIter.next();
  				String colname = col.getName();
  				propCols[j] = colname;
+         propTypes[j] = col.getType();
  				propAliases[j] = col.getAlias() + tab.getUniqueInteger() + StringHelper.UNDERSCORE;
  				j++;
  			}
  			propertyColumnNames[i] = propCols;
+       propertyColumnTypes[i] = propTypes;
  			propertyColumnNameAliases[i] = propAliases;
! 
  			i++;
  		}
! 
  		ArrayList columns = new ArrayList();
  		ArrayList types = new ArrayList();
  		ArrayList propColumns = new ArrayList();
***************
*** 783,789 ****
  		ArrayList aliases = new ArrayList();
  		ArrayList propTables = new ArrayList();
  		ArrayList definedBySubclass = new ArrayList();
! 		
  		iter = model.getSubclassPropertyClosureIterator();
  		while ( iter.hasNext() ) {
  			Property prop = (Property) iter.next();
--- 804,810 ----
  		ArrayList aliases = new ArrayList();
  		ArrayList propTables = new ArrayList();
  		ArrayList definedBySubclass = new ArrayList();
! 
  		iter = model.getSubclassPropertyClosureIterator();
  		while ( iter.hasNext() ) {
  			Property prop = (Property) iter.next();
***************
*** 813,821 ****
  		subclassColumnTableNumberClosure = ArrayHelper.toIntArray(coltables);
  		subclassPropertyTypeClosure = (Type[]) types.toArray(TYPE_ARRAY);
  		subclassPropertyTableNumberClosure = ArrayHelper.toIntArray(propTables);
! 		
  		subclassPropertyColumnNameClosure = (String[][]) propColumns.toArray( new String[ propColumns.size() ][] );
! 		
  		subclassPropertyEnableJoinedFetch = new int[ joinedFetchesList.size() ];
  		iter = joinedFetchesList.iterator();
  		int j=0;
--- 834,842 ----
  		subclassColumnTableNumberClosure = ArrayHelper.toIntArray(coltables);
  		subclassPropertyTypeClosure = (Type[]) types.toArray(TYPE_ARRAY);
  		subclassPropertyTableNumberClosure = ArrayHelper.toIntArray(propTables);
! 
  		subclassPropertyColumnNameClosure = (String[][]) propColumns.toArray( new String[ propColumns.size() ][] );
! 
  		subclassPropertyEnableJoinedFetch = new int[ joinedFetchesList.size() ];
  		iter = joinedFetchesList.iterator();
  		int j=0;
***************
*** 824,846 ****
  		iter = definedBySubclass.iterator();
  		j=0;
  		while ( iter.hasNext() ) propertyDefinedOnSubclass[j++] = ( (Boolean) iter.next() ).booleanValue();
! 		
  		sqlDeleteStrings = generateDeleteStrings();
  		sqlInsertStrings = generateInsertStrings( false, getPropertyInsertability() );
  		sqlIdentityInsertStrings = isIdentifierAssignedByInsert() ? generateInsertStrings( true, getPropertyInsertability() ) : null;
  		sqlUpdateStrings = generateUpdateStrings( getPropertyUpdateability() );
! 		
  		String lockString = generateLockString();
  		lockers.put(LockMode.READ, lockString);
  		String lockExclusiveString = dialect.supportsForUpdate() ? lockString + " for update" : lockString;
  		lockers.put(LockMode.UPGRADE, lockExclusiveString);
  		String lockExclusiveNowaitString = dialect.supportsForUpdateNowait() ? lockString + " for update nowait" : lockExclusiveString;
  		lockers.put(LockMode.UPGRADE_NOWAIT, lockExclusiveNowaitString);
! 		
  		Class mappedClass = model.getPersistentClass();
! 		
  		// SUBCLASSES
! 		
  		int subclassSpan = model.getSubclassSpan() + 1;
  		subclassClosure = new Class[subclassSpan];
  		subclassClosure[subclassSpan-1] = mappedClass;
--- 845,867 ----
  		iter = definedBySubclass.iterator();
  		j=0;
  		while ( iter.hasNext() ) propertyDefinedOnSubclass[j++] = ( (Boolean) iter.next() ).booleanValue();
! 
  		sqlDeleteStrings = generateDeleteStrings();
  		sqlInsertStrings = generateInsertStrings( false, getPropertyInsertability() );
  		sqlIdentityInsertStrings = isIdentifierAssignedByInsert() ? generateInsertStrings( true, getPropertyInsertability() ) : null;
  		sqlUpdateStrings = generateUpdateStrings( getPropertyUpdateability() );
! 
  		String lockString = generateLockString();
  		lockers.put(LockMode.READ, lockString);
  		String lockExclusiveString = dialect.supportsForUpdate() ? lockString + " for update" : lockString;
  		lockers.put(LockMode.UPGRADE, lockExclusiveString);
  		String lockExclusiveNowaitString = dialect.supportsForUpdateNowait() ? lockString + " for update nowait" : lockExclusiveString;
  		lockers.put(LockMode.UPGRADE_NOWAIT, lockExclusiveNowaitString);
! 
  		Class mappedClass = model.getPersistentClass();
! 
  		// SUBCLASSES
! 
  		int subclassSpan = model.getSubclassSpan() + 1;
  		subclassClosure = new Class[subclassSpan];
  		subclassClosure[subclassSpan-1] = mappedClass;
***************
*** 861,867 ****
  			tableNumbers = null;
  			notNullColumns = null;
  		}
! 		
  		iter = model.getSubclassIterator();
  		int k=0;
  		while ( iter.hasNext() ) {
--- 882,888 ----
  			tableNumbers = null;
  			notNullColumns = null;
  		}
! 
  		iter = model.getSubclassIterator();
  		int k=0;
  		while ( iter.hasNext() ) {
***************
*** 884,908 ****
  			}
  			k++;
  		}
! 		
  		propertyHasColumns = new boolean[sqlUpdateStrings.length];
  		for ( int m=0; m<sqlUpdateStrings.length; m++ ) {
  			propertyHasColumns[m] = sqlUpdateStrings[m]!=null;
  		}
  
  		allProperties = new boolean[hydrateSpan];
! 		Arrays.fill(allProperties, true);		
! 		
  	}
  
  	private void initPropertyPaths(Mapping mapping) throws MappingException {
! 		
  		Type[] propertyTypes = getPropertyTypes();
  		String[] propertyNames = getPropertyNames();
  		for ( int i=0; i<propertyNames.length; i++ ) {
  			initPropertyPaths( propertyNames[i], propertyTypes[i], propertyColumnNames[i], propertyTables[i], mapping );
  		}
! 		
  		String idProp = getIdentifierPropertyName();
  		if (idProp!=null) initPropertyPaths( idProp, getIdentifierType(), getIdentifierColumnNames(), 0, mapping );
  		if ( hasEmbeddedIdentifier() ) initPropertyPaths( null, getIdentifierType(), getIdentifierColumnNames(), 0, mapping );
--- 905,929 ----
  			}
  			k++;
  		}
! 
  		propertyHasColumns = new boolean[sqlUpdateStrings.length];
  		for ( int m=0; m<sqlUpdateStrings.length; m++ ) {
  			propertyHasColumns[m] = sqlUpdateStrings[m]!=null;
  		}
  
  		allProperties = new boolean[hydrateSpan];
! 		Arrays.fill(allProperties, true);
! 
  	}
  
  	private void initPropertyPaths(Mapping mapping) throws MappingException {
! 
  		Type[] propertyTypes = getPropertyTypes();
  		String[] propertyNames = getPropertyNames();
  		for ( int i=0; i<propertyNames.length; i++ ) {
  			initPropertyPaths( propertyNames[i], propertyTypes[i], propertyColumnNames[i], propertyTables[i], mapping );
  		}
! 
  		String idProp = getIdentifierPropertyName();
  		if (idProp!=null) initPropertyPaths( idProp, getIdentifierType(), getIdentifierColumnNames(), 0, mapping );
  		if ( hasEmbeddedIdentifier() ) initPropertyPaths( null, getIdentifierType(), getIdentifierColumnNames(), 0, mapping );
***************
*** 912,928 ****
  		columnNamesByPropertyPath.put( PathExpressionParser.ENTITY_CLASS, new String[] { getDiscriminatorColumnName() } );
  		tableNumberByPropertyPath.put( PathExpressionParser.ENTITY_CLASS, new Integer(0) );
  	}
! 	
  	private void initPropertyPaths(String propertyName, Type propertyType, String[] columns, int table, Mapping mapping) throws MappingException {
! 		
  		if (propertyName!=null) {
  			typesByPropertyPath.put(propertyName, propertyType);
  			columnNamesByPropertyPath.put(propertyName, columns);
  			tableNumberByPropertyPath.put( propertyName, new Integer(table) );
  		}
! 	
  		if ( propertyType.isComponentType() ) {
! 			AbstractComponentType compType = (AbstractComponentType) propertyType; 
  			String[] props = compType.getPropertyNames();
  			Type[] types = compType.getSubtypes();
  			int count=0;
--- 933,949 ----
  		columnNamesByPropertyPath.put( PathExpressionParser.ENTITY_CLASS, new String[] { getDiscriminatorColumnName() } );
  		tableNumberByPropertyPath.put( PathExpressionParser.ENTITY_CLASS, new Integer(0) );
  	}
! 
  	private void initPropertyPaths(String propertyName, Type propertyType, String[] columns, int table, Mapping mapping) throws MappingException {
! 
  		if (propertyName!=null) {
  			typesByPropertyPath.put(propertyName, propertyType);
  			columnNamesByPropertyPath.put(propertyName, columns);
  			tableNumberByPropertyPath.put( propertyName, new Integer(table) );
  		}
! 
  		if ( propertyType.isComponentType() ) {
! 			AbstractComponentType compType = (AbstractComponentType) propertyType;
  			String[] props = compType.getPropertyNames();
  			Type[] types = compType.getSubtypes();
  			int count=0;
***************
*** 937,948 ****
  			}
  		}
  	}
! 	
! 	
  	public String fromTableFragment(String alias) {
  		return subclassTableNameClosure[0] + ' ' + alias;
  	}
! 	
  	private JoinFragment outerjoin(String name, boolean innerJoin, boolean includeSubclasses) {
  		JoinFragment outerjoin = factory.getDialect().createOuterJoinFragment();
  		for ( int i=1; i<subclassTableNameClosure.length; i++ ) {
--- 958,968 ----
  			}
  		}
  	}
! 
  	public String fromTableFragment(String alias) {
  		return subclassTableNameClosure[0] + ' ' + alias;
  	}
! 
  	private JoinFragment outerjoin(String name, boolean innerJoin, boolean includeSubclasses) {
  		JoinFragment outerjoin = factory.getDialect().createOuterJoinFragment();
  		for ( int i=1; i<subclassTableNameClosure.length; i++ ) {
***************
*** 958,986 ****
  		}
  		return outerjoin;
  	}
! 	
  	private int getTableId(String tableName, String[] tables) {
  		for ( int tab=0; tab<tables.length; tab++ ) {
  			if ( tableName.equals( tables[tab] ) ) return tab;
  		}
  		throw new AssertionFailure("table not found");
  	}
! 	
  	public String[] toColumns(String alias, String property) throws QueryException {
! 		
  		if ( PathExpressionParser.ENTITY_CLASS.equals(property) ) {
  			// This doesn't actually seem to work but it *might*
  			// work on some dbs. Also it doesn't work if there
  			// are multiple columns of results because it
  			// is not accounting for the suffix:
  			// return new String[] { getDiscriminatorColumnName() };
! 			
  			return new String[] { discriminatorFragment(alias).toFragmentString() };
  		}
! 		
  		String[] cols = getPropertyColumnNames(property);
  		if (cols==null) throw new QueryException("unresolved property: " + property);
! 		
  		int tab;
  		if (cols.length==0) {
  			// ie. a nested collection or a one-to-one
--- 978,1006 ----
  		}
  		return outerjoin;
  	}
! 
  	private int getTableId(String tableName, String[] tables) {
  		for ( int tab=0; tab<tables.length; tab++ ) {
  			if ( tableName.equals( tables[tab] ) ) return tab;
  		}
  		throw new AssertionFailure("table not found");
  	}
! 
  	public String[] toColumns(String alias, String property) throws QueryException {
! 
  		if ( PathExpressionParser.ENTITY_CLASS.equals(property) ) {
  			// This doesn't actually seem to work but it *might*
  			// work on some dbs. Also it doesn't work if there
  			// are multiple columns of results because it
  			// is not accounting for the suffix:
  			// return new String[] { getDiscriminatorColumnName() };
! 
  			return new String[] { discriminatorFragment(alias).toFragmentString() };
  		}
! 
  		String[] cols = getPropertyColumnNames(property);
  		if (cols==null) throw new QueryException("unresolved property: " + property);
! 
  		int tab;
  		if (cols.length==0) {
  			// ie. a nested collection or a one-to-one
***************
*** 990,1014 ****
  		else {
  			tab = ( (Integer) tableNumberByPropertyPath.get(property) ).intValue();
  		}
! 		
  		return StringHelper.prefix( cols, alias(alias, tab) + StringHelper.DOT );
  	}
! 	
  	public String[] toColumns(String alias, int i) {
  		int tab = subclassPropertyTableNumberClosure[i];
! 		return StringHelper.prefix( 
! 			subclassPropertyColumnNameClosure[i], 
  			alias(alias, tab) + StringHelper.DOT
  		);
  	}
! 	
  	public String propertySelectFragment(String alias, String suffix) {
! 		
  		String[] cols = subclassColumnClosure;
  		SelectFragment frag = new SelectFragment()
  			.setSuffix(suffix);
  		for ( int i=0; i<cols.length; i++ ) {
! 			frag.addColumn( 
  				alias( alias, subclassColumnTableNumberClosure[i] ),
  				cols[i],
  				subclassColumnClosureAliases[i]
--- 1010,1034 ----
  		else {
  			tab = ( (Integer) tableNumberByPropertyPath.get(property) ).intValue();
  		}
! 
  		return StringHelper.prefix( cols, alias(alias, tab) + StringHelper.DOT );
  	}
! 
  	public String[] toColumns(String alias, int i) {
  		int tab = subclassPropertyTableNumberClosure[i];
! 		return StringHelper.prefix(
! 			subclassPropertyColumnNameClosure[i],
  			alias(alias, tab) + StringHelper.DOT
  		);
  	}
! 
  	public String propertySelectFragment(String alias, String suffix) {
! 
  		String[] cols = subclassColumnClosure;
  		SelectFragment frag = new SelectFragment()
  			.setSuffix(suffix);
  		for ( int i=0; i<cols.length; i++ ) {
! 			frag.addColumn(
  				alias( alias, subclassColumnTableNumberClosure[i] ),
  				cols[i],
  				subclassColumnClosureAliases[i]
***************
*** 1016,1025 ****
  		}
  
  		if ( hasSubclasses() ) {
! 			return ", " + 
  				discriminatorFragment(alias)
  					.setReturnColumnName( getDiscriminatorColumnName(), suffix )
! 					.toFragmentString() + 
  				frag.toFragmentString();
  		}
  		else {
--- 1036,1045 ----
  		}
  
  		if ( hasSubclasses() ) {
! 			return ", " +
  				discriminatorFragment(alias)
  					.setReturnColumnName( getDiscriminatorColumnName(), suffix )
! 					.toFragmentString() +
  				frag.toFragmentString();
  		}
  		else {
***************
*** 1029,1035 ****
  
  	private CaseFragment discriminatorFragment(String alias) {
  		CaseFragment cases = dialect.createCaseFragment();
! 				
  		for ( int i=0; i< discriminators.length; i++ ) {
  			cases.addWhenColumnNotNull(
  				alias( alias, tableNumbers[i] ),
--- 1049,1055 ----
  
  	private CaseFragment discriminatorFragment(String alias) {
  		CaseFragment cases = dialect.createCaseFragment();
! 
  		for ( int i=0; i< discriminators.length; i++ ) {
  			cases.addWhenColumnNotNull(
  				alias( alias, tableNumbers[i] ),
***************
*** 1037,1056 ****
  				discriminators[i]
  			);
  		}
! 		
  		return cases;
  	}
! 	
  	private String alias(String name, int tableNumber) {
  		if (tableNumber==0) return name;
  		return name + StringHelper.UNDERSCORE + tableNumber;
  	}
! 	
  	public String getConcreteClassAlias(String alias) {
  		int tab = tableNumbers[ tableNumbers.length-1 ];
  		return alias + ( (tab==0) ? StringHelper.EMPTY_STRING : StringHelper.UNDERSCORE +Integer.toString(tab) );
  	}
! 	
  	public String fromJoinFragment(String alias, boolean innerJoin, boolean includeSubclasses) {
  		return outerjoin(alias, innerJoin, includeSubclasses).toFromFragmentString();
  	}
--- 1057,1076 ----
  				discriminators[i]
  			);
  		}
! 
  		return cases;
  	}
! 
  	private String alias(String name, int tableNumber) {
  		if (tableNumber==0) return name;
  		return name + StringHelper.UNDERSCORE + tableNumber;
  	}
! 
  	public String getConcreteClassAlias(String alias) {
  		int tab = tableNumbers[ tableNumbers.length-1 ];
  		return alias + ( (tab==0) ? StringHelper.EMPTY_STRING : StringHelper.UNDERSCORE +Integer.toString(tab) );
  	}
! 
  	public String fromJoinFragment(String alias, boolean innerJoin, boolean includeSubclasses) {
  		return outerjoin(alias, innerJoin, includeSubclasses).toFromFragmentString();
  	}
Index: hibernate-2.0/src/net/sf/hibernate/sql/Delete.java
diff -c hibernate-2.0/src/net/sf/hibernate/sql/Delete.java:1.1.1.2 hibernate-2.0/src/net/sf/hibernate/sql/Delete.java:1.4
*** hibernate-2.0/src/net/sf/hibernate/sql/Delete.java:1.1.1.2	Tue Apr 22 14:28:25 2003
--- hibernate-2.0/src/net/sf/hibernate/sql/Delete.java	Fri Apr 25 14:08:58 2003
***************
*** 1,30 ****
! //$Id: Delete.java,v 1.1.1.2 2003/04/22 19:28:25 paulsenj Exp $
  package net.sf.hibernate.sql;
  
- import net.sf.hibernate.util.StringHelper;
- 
  /**
   * An SQL <tt>INSERT</tt> statement
   */
  public class Delete {
! 	
  	private String tableName;
  	private String[] primaryKeyColumnNames;
  	private String versionColumnName;
  	private String where;
! 	
  	public Delete setTableName(String tableName) {
  		this.tableName = tableName;
  		return this;
  	}
! 	
  	public String toStatementString() {
  		StringBuffer buf = new StringBuffer( tableName.length() + 10 );
  		buf.append("delete from ")
  			.append(tableName)
! 			.append(" where ")
! 			.append( StringHelper.join("=? and ", primaryKeyColumnNames) )
! 			.append("=?");
  		if (where!=null) {
  			buf.append(" and ")
  				.append(where);
--- 1,35 ----
! //$Id: Delete.java,v 1.4 2003/04/25 19:08:58 paulsenj Exp $
  package net.sf.hibernate.sql;
  
  /**
   * An SQL <tt>INSERT</tt> statement
   */
  public class Delete {
! 
  	private String tableName;
  	private String[] primaryKeyColumnNames;
+   private String[] primaryKeyColumnPlaceHolders;
  	private String versionColumnName;
  	private String where;
! 
  	public Delete setTableName(String tableName) {
  		this.tableName = tableName;
  		return this;
  	}
! 
  	public String toStatementString() {
+     // use type placeholders when constructing sql
  		StringBuffer buf = new StringBuffer( tableName.length() + 10 );
  		buf.append("delete from ")
  			.append(tableName)
! 			.append(" where ");
!     for (int i = 0; i < primaryKeyColumnPlaceHolders.length; i++) {
!       buf.append(primaryKeyColumnNames[i])
!       .append("=")
!       .append(primaryKeyColumnPlaceHolders[i]);
!       if (i < primaryKeyColumnNames.length - 1)
!         buf.append(" and ");
!     }
  		if (where!=null) {
  			buf.append(" and ")
  				.append(where);
***************
*** 34,49 ****
  				.append(versionColumnName)
  				.append("=?");
  		}
! 		return buf.toString(); 
  	}
! 	
  	public Delete setWhere(String where) {
  		this.where=where;
  		return this;
  	}
! 	
  	public Delete setPrimaryKeyColumnNames(String[] primaryKeyColumnNames) {
  		this.primaryKeyColumnNames = primaryKeyColumnNames;
  		return this;
  	}
  
--- 39,59 ----
  				.append(versionColumnName)
  				.append("=?");
  		}
! 		return buf.toString();
  	}
! 
  	public Delete setWhere(String where) {
  		this.where=where;
  		return this;
  	}
! 
  	public Delete setPrimaryKeyColumnNames(String[] primaryKeyColumnNames) {
  		this.primaryKeyColumnNames = primaryKeyColumnNames;
+ 		return this;
+ 	}
+ 
+ 	public Delete setPrimaryKeyColumnPlaceHolders(String[] primaryKeyColumnPlaceHolders) {
+ 		this.primaryKeyColumnPlaceHolders = primaryKeyColumnPlaceHolders;
  		return this;
  	}
  
Index: hibernate-2.0/src/net/sf/hibernate/sql/Insert.java
diff -c hibernate-2.0/src/net/sf/hibernate/sql/Insert.java:1.1.1.1 hibernate-2.0/src/net/sf/hibernate/sql/Insert.java:1.2
*** hibernate-2.0/src/net/sf/hibernate/sql/Insert.java:1.1.1.1	Tue Apr 22 11:17:23 2003
--- hibernate-2.0/src/net/sf/hibernate/sql/Insert.java	Tue Apr 22 13:32:16 2003
***************
*** 1,4 ****
! //$Id: Insert.java,v 1.1.1.1 2003/04/22 16:17:23 paulsenj Exp $
  package net.sf.hibernate.sql;
  
  import java.util.Iterator;
--- 1,4 ----
! //$Id: Insert.java,v 1.2 2003/04/22 18:32:16 paulsenj Exp $
  package net.sf.hibernate.sql;
  
  import java.util.Iterator;
***************
*** 14,60 ****
   * An SQL <tt>INSERT</tt> statement
   */
  public class Insert {
! 	
  	public Insert(Dialect dialect) {
  		this.dialect = dialect;
  	}
! 	
  	private Dialect dialect;
  	private String tableName;
! 	
  	private Map columns = new SequencedHashMap();
! 	
! 	public Insert addColumn(String columnName) {
! 		return addColumn(columnName, "?");
! 	}
! 	
! 	public Insert addColumns(String[] columnNames) {
! 		for ( int i=0; i<columnNames.length; i++ ) {
! 			addColumn( columnNames[i] );
! 		}
! 		return this;
! 	}
  
  	public Insert addColumn(String columnName, String value) {
  		columns.put(columnName, value);
  		return this;
  	}
! 	
  	public Insert addColumn(String columnName, Object value, LiteralType type) throws Exception {
  		return addColumn( columnName, type.objectToSQLString(value) );
  	}
! 	
  	public Insert addIdentityColumn(String columnName) {
  		String value = dialect.getIdentityInsertString();
  		if (value!=null) addColumn(columnName, value);
  		return this;
  	}
! 	
  	public Insert setTableName(String tableName) {
  		this.tableName = tableName;
  		return this;
  	}
! 	
  	public String toStatementString() {
  		StringBuffer buf = new StringBuffer( columns.size()*15 + tableName.length() + 10 );
  		buf.append("insert into ")
--- 14,57 ----
   * An SQL <tt>INSERT</tt> statement
   */
  public class Insert {
! 
  	public Insert(Dialect dialect) {
  		this.dialect = dialect;
  	}
! 
  	private Dialect dialect;
  	private String tableName;
! 
  	private Map columns = new SequencedHashMap();
! 
!   // use type placeholders when constructing sql
!   public Insert addColumns(String[] columnNames, String[] placeHolders) {
!     for ( int i=0; i<columnNames.length; i++ ) {
!       addColumn( columnNames[i], placeHolders[i] );
!     }
!     return this;
!   }
  
  	public Insert addColumn(String columnName, String value) {
  		columns.put(columnName, value);
  		return this;
  	}
! 
  	public Insert addColumn(String columnName, Object value, LiteralType type) throws Exception {
  		return addColumn( columnName, type.objectToSQLString(value) );
  	}
! 
  	public Insert addIdentityColumn(String columnName) {
  		String value = dialect.getIdentityInsertString();
  		if (value!=null) addColumn(columnName, value);
  		return this;
  	}
! 
  	public Insert setTableName(String tableName) {
  		this.tableName = tableName;
  		return this;
  	}
! 
  	public String toStatementString() {
  		StringBuffer buf = new StringBuffer( columns.size()*15 + tableName.length() + 10 );
  		buf.append("insert into ")
***************
*** 77,82 ****
  			}
  			buf.append(')');
  		}
! 		return buf.toString(); 
  	}
  }
--- 74,79 ----
  			}
  			buf.append(')');
  		}
! 		return buf.toString();
  	}
  }
Index: hibernate-2.0/src/net/sf/hibernate/sql/Update.java
diff -c hibernate-2.0/src/net/sf/hibernate/sql/Update.java:1.1.1.2 hibernate-2.0/src/net/sf/hibernate/sql/Update.java:1.4
*** hibernate-2.0/src/net/sf/hibernate/sql/Update.java:1.1.1.2	Tue Apr 22 14:28:25 2003
--- hibernate-2.0/src/net/sf/hibernate/sql/Update.java	Fri Apr 25 14:08:58 2003
***************
*** 1,4 ****
! //$Id: Update.java,v 1.1.1.2 2003/04/22 19:28:25 paulsenj Exp $
  package net.sf.hibernate.sql;
  
  import java.util.Iterator;
--- 1,4 ----
! //$Id: Update.java,v 1.4 2003/04/25 19:08:58 paulsenj Exp $
  package net.sf.hibernate.sql;
  
  import java.util.Iterator;
***************
*** 13,29 ****
   * An SQL <tt>UPDATE</tt> statement
   */
  public class Update {
! 	
  	private String tableName;
  	private String primaryKeyColumnNames[];
  	private String versionColumnName;
  	private String where;
! 	
  	private Map columns = new SequencedHashMap();
! 	
! 	public Update addColumns(String[] columnNames) {
  		for ( int i=0; i<columnNames.length; i++ ) {
! 			addColumn( columnNames[i] );
  		}
  		return this;
  	}
--- 13,30 ----
   * An SQL <tt>UPDATE</tt> statement
   */
  public class Update {
! 
  	private String tableName;
  	private String primaryKeyColumnNames[];
+   private String[] primaryKeyColumnPlaceHolders;
  	private String versionColumnName;
  	private String where;
! 
  	private Map columns = new SequencedHashMap();
! 
! 	public Update addColumns(String[] columnNames, String[] placeHolders) {
  		for ( int i=0; i<columnNames.length; i++ ) {
! 			addColumn( columnNames[i], placeHolders[i] );
  		}
  		return this;
  	}
***************
*** 35,64 ****
  		return this;
  	}
  
- 	public Update addColumn(String columnName) {
- 		return addColumn(columnName, "?");
- 	}
- 
  	public Update addColumn(String columnName, String value) {
  		columns.put(columnName, value);
  		return this;
  	}
! 	
  	public Update addColumn(String columnName, Object value, LiteralType type) throws Exception {
  		return addColumn( columnName, type.objectToSQLString(value) );
  	}
! 	
  	public Update setTableName(String tableName) {
  		this.tableName = tableName;
  		return this;
  	}
! 	
  	public Update setWhere(String where) {
  		this.where=where;
  		return this;
  	}
! 	
  	public String toStatementString() {
  		StringBuffer buf = new StringBuffer( columns.size()*15 + tableName.length() + 10 );
  		buf.append("update ")
  			.append(tableName)
--- 36,62 ----
  		return this;
  	}
  
  	public Update addColumn(String columnName, String value) {
  		columns.put(columnName, value);
  		return this;
  	}
! 
  	public Update addColumn(String columnName, Object value, LiteralType type) throws Exception {
  		return addColumn( columnName, type.objectToSQLString(value) );
  	}
! 
  	public Update setTableName(String tableName) {
  		this.tableName = tableName;
  		return this;
  	}
! 
  	public Update setWhere(String where) {
  		this.where=where;
  		return this;
  	}
! 
  	public String toStatementString() {
+     // use type placeholders when constructing sql
  		StringBuffer buf = new StringBuffer( columns.size()*15 + tableName.length() + 10 );
  		buf.append("update ")
  			.append(tableName)
***************
*** 71,79 ****
  				.append( e.getValue() );
  			if ( iter.hasNext() ) buf.append(StringHelper.COMMA_SPACE);
  		}
! 		buf.append(" where ")
! 			.append( StringHelper.join("=? and ", primaryKeyColumnNames) )
! 			.append("=?");
  		if (where!=null) {
  			buf.append(" and ")
  				.append(where);
--- 69,83 ----
  				.append( e.getValue() );
  			if ( iter.hasNext() ) buf.append(StringHelper.COMMA_SPACE);
  		}
! 		buf.append(" where ");
!     for (int i = 0; i < primaryKeyColumnNames.length; i++) {
!       // paulsen
! 			buf.append( primaryKeyColumnNames[i] )
!       .append("=")
!       .append( primaryKeyColumnPlaceHolders[i]);
!       if (i < primaryKeyColumnNames.length - 1)
!         buf.append(" and ");
!     }
  		if (where!=null) {
  			buf.append(" and ")
  				.append(where);
***************
*** 83,93 ****
  				.append(versionColumnName)
  				.append("=?");
  		}
! 		return buf.toString(); 
  	}
  
  	public Update setPrimaryKeyColumnNames(String[] primaryKeyColumnNames) {
  		this.primaryKeyColumnNames = primaryKeyColumnNames;
  		return this;
  	}
  
--- 87,102 ----
  				.append(versionColumnName)
  				.append("=?");
  		}
! 		return buf.toString();
  	}
  
  	public Update setPrimaryKeyColumnNames(String[] primaryKeyColumnNames) {
  		this.primaryKeyColumnNames = primaryKeyColumnNames;
+ 		return this;
+ 	}
+ 
+ 	public Update setPrimaryKeyColumnPlaceHolders(String[] primaryKeyColumnPlaceHolders) {
+ 		this.primaryKeyColumnPlaceHolders = primaryKeyColumnPlaceHolders;
  		return this;
  	}
  
Index: hibernate-2.0/src/net/sf/hibernate/test/DoubleStringType.java
diff -c hibernate-2.0/src/net/sf/hibernate/test/DoubleStringType.java:1.1.1.2 hibernate-2.0/src/net/sf/hibernate/test/DoubleStringType.java:1.4
*** hibernate-2.0/src/net/sf/hibernate/test/DoubleStringType.java:1.1.1.2	Tue Apr 22 14:28:25 2003
--- hibernate-2.0/src/net/sf/hibernate/test/DoubleStringType.java	Tue Apr 29 10:31:18 2003
***************
*** 1,4 ****
! //$Id: DoubleStringType.java,v 1.1.1.2 2003/04/22 19:28:25 paulsenj Exp $
  package net.sf.hibernate.test;
  
  import java.io.Serializable;
--- 1,4 ----
! //$Id: DoubleStringType.java,v 1.4 2003/04/29 15:31:18 paulsenj Exp $
  package net.sf.hibernate.test;
  
  import java.io.Serializable;
***************
*** 14,36 ****
  import net.sf.hibernate.type.Type;
  
  public class DoubleStringType implements CompositeUserType {
! 	
  	private static final int[] TYPES = { Types.VARCHAR, Types.VARCHAR };
! 	
  	public int[] sqlTypes() {
  		return TYPES;
  	}
! 	
  	public Class returnedClass() {
  		return String[].class;
  	}
! 	
  	public boolean equals(Object x, Object y) {
  		if (x==y) return true;
  		if (x==null || y==null) return false;
  		return ((String[]) x)[0].equals( ((String[]) y)[0] ) && ((String[]) x)[1].equals( ((String[]) y)[1] );
  	}
! 	
  	public Object deepCopy(Object x) {
  		if (x==null) return null;
  		String[] result = new String[2];
--- 14,36 ----
  import net.sf.hibernate.type.Type;
  
  public class DoubleStringType implements CompositeUserType {
! 
  	private static final int[] TYPES = { Types.VARCHAR, Types.VARCHAR };
! 
  	public int[] sqlTypes() {
  		return TYPES;
  	}
! 
  	public Class returnedClass() {
  		return String[].class;
  	}
! 
  	public boolean equals(Object x, Object y) {
  		if (x==y) return true;
  		if (x==null || y==null) return false;
  		return ((String[]) x)[0].equals( ((String[]) y)[0] ) && ((String[]) x)[1].equals( ((String[]) y)[1] );
  	}
! 
  	public Object deepCopy(Object x) {
  		if (x==null) return null;
  		String[] result = new String[2];
***************
*** 39,65 ****
  		result[1] = input[1];
  		return result;
  	}
! 	
  	public boolean isMutable() { return true; }
! 	
  	public Object nullSafeGet(ResultSet rs,	String[] names, SessionImplementor session,	Object owner)
  	throws HibernateException, SQLException {
! 		
  		String first = (String) Hibernate.STRING.nullSafeGet(rs, names[0]);
  		String second = (String) Hibernate.STRING.nullSafeGet(rs, names[1]);
! 		
  		return ( first==null && second==null ) ? null : new String[] { first, second };
  	}
! 	
  	public void nullSafeSet(PreparedStatement st, Object value, int index, SessionImplementor session)
  	throws HibernateException, SQLException {
! 		
  		String[] strings = (value==null) ? new String[2] : (String[]) value;
! 		
  		Hibernate.STRING.nullSafeSet(st, strings[0], index);
  		Hibernate.STRING.nullSafeSet(st, strings[1], index+1);
  	}
! 	
  	public String[] getPropertyNames() {
  		return new String[] { "s1", "s2" };
  	}
--- 39,65 ----
  		result[1] = input[1];
  		return result;
  	}
! 
  	public boolean isMutable() { return true; }
! 
  	public Object nullSafeGet(ResultSet rs,	String[] names, SessionImplementor session,	Object owner)
  	throws HibernateException, SQLException {
! 
  		String first = (String) Hibernate.STRING.nullSafeGet(rs, names[0]);
  		String second = (String) Hibernate.STRING.nullSafeGet(rs, names[1]);
! 
  		return ( first==null && second==null ) ? null : new String[] { first, second };
  	}
! 
  	public void nullSafeSet(PreparedStatement st, Object value, int index, SessionImplementor session)
  	throws HibernateException, SQLException {
! 
  		String[] strings = (value==null) ? new String[2] : (String[]) value;
! 
  		Hibernate.STRING.nullSafeSet(st, strings[0], index);
  		Hibernate.STRING.nullSafeSet(st, strings[1], index+1);
  	}
! 
  	public String[] getPropertyNames() {
  		return new String[] { "s1", "s2" };
  	}
***************
*** 76,82 ****
  		Object component,
  		int property,
  		Object value) {
! 		
  		( (String[]) component )[property] = (String) value;
  	}
  
--- 76,82 ----
  		Object component,
  		int property,
  		Object value) {
! 
  		( (String[]) component )[property] = (String) value;
  	}
  
***************
*** 84,90 ****
  		Serializable cached,
  		SessionImplementor session,
  		Object owner) {
! 		
  		return deepCopy(cached);
  	}
  
--- 84,90 ----
  		Serializable cached,
  		SessionImplementor session,
  		Object owner) {
! 
  		return deepCopy(cached);
  	}
  
Index: hibernate-2.0/src/net/sf/hibernate/test/UDT.java
diff -c /dev/null hibernate-2.0/src/net/sf/hibernate/test/UDT.java:1.1
*** /dev/null	Wed Apr 30 16:03:14 2003
--- hibernate-2.0/src/net/sf/hibernate/test/UDT.java	Wed Apr 30 12:18:43 2003
***************
*** 0 ****
--- 1,28 ----
+ package net.sf.hibernate.test;
+ 
+ import java.io.Serializable;
+ 
+ /**
+  * User Defined Type for testing explict casts on placeholders in
+  * Hibernate generated SQL
+  */
+ public class UDT implements Serializable {
+   private String v;
+ 
+   public UDT(String v) {
+     this.v = v;
+   }
+ 
+   public String toString() {
+     return v;
+   }
+ 
+   public int hashCode() {
+     return v.hashCode();
+   }
+ 
+   public boolean equals(Object obj) {
+     return obj.toString().equals(this.toString());
+   }
+ }
+ 
Index: hibernate-2.0/src/net/sf/hibernate/test/UDTFoo.hbm.xml
diff -c /dev/null hibernate-2.0/src/net/sf/hibernate/test/UDTFoo.hbm.xml:1.1
*** /dev/null	Wed Apr 30 16:03:14 2003
--- hibernate-2.0/src/net/sf/hibernate/test/UDTFoo.hbm.xml	Wed Apr 30 12:18:43 2003
***************
*** 0 ****
--- 1,13 ----
+ <?xml version="1.0"?>
+ <!DOCTYPE hibernate-mapping PUBLIC
+         "-//Hibernate/Hibernate Mapping DTD//EN"
+         "http://hibernate.sourceforge.net/hibernate-mapping-2.0.dtd">
+ <hibernate-mapping>
+   <class name="net.sf.hibernate.test.UDTFoo" table="UDTFOO">
+     <id name="id" column="id" type="net.sf.hibernate.test.UDTType">
+       <generator class="assigned" />
+     </id>
+     <version name="version" column="version" type="integer"/>
+     <property name="text" column="text" type="string"/>
+   </class>
+ </hibernate-mapping>
\ No newline at end of file
Index: hibernate-2.0/src/net/sf/hibernate/test/UDTFoo.java
diff -c /dev/null hibernate-2.0/src/net/sf/hibernate/test/UDTFoo.java:1.1
*** /dev/null	Wed Apr 30 16:03:14 2003
--- hibernate-2.0/src/net/sf/hibernate/test/UDTFoo.java	Wed Apr 30 12:18:43 2003
***************
*** 0 ****
--- 1,34 ----
+ package net.sf.hibernate.test;
+ 
+ /**
+  * For testing UDT
+  */
+ public class UDTFoo {
+   private UDT id;
+   private Integer version;
+   private String text;
+ 
+   public UDT getId() {
+     return id;
+   }
+ 
+   public void setId(UDT id) {
+     this.id = id;
+   }
+ 
+   public Integer getVersion() {
+     return version;
+   }
+ 
+   public void setVersion(Integer version) {
+     this.version = version;
+   }
+ 
+   public String getText() {
+     return text;
+   }
+ 
+   public void setText(String text) {
+     this.text = text;
+   }
+ }
Index: hibernate-2.0/src/net/sf/hibernate/test/UDTTest.java
diff -c /dev/null hibernate-2.0/src/net/sf/hibernate/test/UDTTest.java:1.1
*** /dev/null	Wed Apr 30 16:03:14 2003
--- hibernate-2.0/src/net/sf/hibernate/test/UDTTest.java	Wed Apr 30 12:18:43 2003
***************
*** 0 ****
--- 1,115 ----
+ package net.sf.hibernate.test;
+ 
+ import junit.framework.Test;
+ import junit.framework.TestSuite;
+ import net.sf.hibernate.Session;
+ import net.sf.hibernate.ObjectNotFoundException;
+ import net.sf.hibernate.cfg.Configuration;
+ import net.sf.hibernate.dialect.DB2Dialect;
+ import net.sf.hibernate.dialect.Dialect;
+ 
+ import java.sql.Connection;
+ import java.sql.Statement;
+ import java.sql.SQLException;
+ 
+ /**
+  * JUnit Test Case for testing customizable placeholder interface.
+  * This test case will only run on DB2Dialect.
+  */
+ public class UDTTest extends TestCase {
+ 
+   public UDTTest(String arg) {
+ 		super(arg);
+ 	}
+ 
+ 	public void testUDT() throws Exception {
+     if (dialect instanceof DB2Dialect) {
+       Session s = sessions.openSession();
+ 
+       UDT theID = new UDT("0000000001");
+       UDTFoo foo = new UDTFoo();
+       foo.setId(theID);
+       foo.setText("some text");
+       s.save(foo);
+       s.flush();
+       s.connection().commit();
+       s.close();
+ 
+       s = sessions.openSession();
+       foo = (UDTFoo) s.load(UDTFoo.class, theID);
+       assertTrue( foo.getText().equals("some text") );
+       foo.setText("some new text");
+       s.flush();
+       s.connection().commit();
+       s.close();
+ 
+       s = sessions.openSession();
+       foo = (UDTFoo) s.load(UDTFoo.class, theID);
+       assertTrue( foo.getText().equals("some new text") );
+       s.delete(foo);
+       s.flush();
+       s.connection().commit();
+       s.close();
+ 
+       s = sessions.openSession();
+       foo = null;
+       try {
+         foo = (UDTFoo) s.load(UDTFoo.class, theID);
+       }
+       catch (ObjectNotFoundException ignored) {}
+       assertTrue(foo == null);
+       s.flush();
+       s.connection().commit();
+       s.close();
+     }
+ 	}
+ 
+ 	public static Test suite() throws Exception {
+ 		try {
+ 
+       Configuration cfg = new Configuration();
+       cfg.addClass(net.sf.hibernate.test.UDTFoo.class);
+ 
+       dialect = Dialect.getDialect();
+ 
+       sessions = cfg.buildSessionFactory();
+ 
+       if (dialect instanceof DB2Dialect) {
+         Session s = sessions.openSession();
+         Connection conn = s.connection();
+         Statement st = conn.createStatement();
+         try {
+           st.execute("drop table UDTFOO");
+         }
+         catch (SQLException ignored) {}
+         conn.commit();
+         try {
+           st.execute("drop distinct type UDT restrict");
+         }
+         catch (SQLException ignored) {}
+         conn.commit();
+         st.execute("create distinct type UDT as CHAR(10) with comparisons");
+         st.execute("create table UDTFOO (id UDT not null primary key, version INTEGER, text VARCHAR(100))");
+         st.execute("create unique index UDTFOO_PK on UDTFOO(id)");
+         st.close();
+         conn.commit();
+         conn.close();
+ 
+ 
+       }
+ 			return new TestSuite(UDTTest.class);
+ 		}
+ 		catch (Exception e) {
+ 			e.printStackTrace();
+ 			throw e;
+ 		}
+ 	}
+ 
+ }
+ 
+ 
+ 
+ 
+ 
+ 
+ 
Index: hibernate-2.0/src/net/sf/hibernate/test/UDTType.java
diff -c /dev/null hibernate-2.0/src/net/sf/hibernate/test/UDTType.java:1.1
*** /dev/null	Wed Apr 30 16:03:14 2003
--- hibernate-2.0/src/net/sf/hibernate/test/UDTType.java	Wed Apr 30 12:18:43 2003
***************
*** 0 ****
--- 1,64 ----
+ package net.sf.hibernate.test;
+ 
+ import net.sf.hibernate.UserType;
+ import net.sf.hibernate.HibernateException;
+ import net.sf.hibernate.Hibernate;
+ import net.sf.hibernate.type.CustomizablePlaceHolderType;
+ 
+ import java.sql.Types;
+ import java.sql.ResultSet;
+ import java.sql.SQLException;
+ import java.sql.PreparedStatement;
+ 
+ /**
+  * User Defined Type for testing explict casts on placeholders in
+  * Hibernate generated SQL
+  */
+ public class UDTType implements UserType, CustomizablePlaceHolderType {
+ 
+ 	private static final int[] TYPES = { Types.DISTINCT };
+ 
+ 	public int[] sqlTypes() {
+ 		return TYPES;
+ 	}
+ 
+ 	public Class returnedClass() {
+ 		return UDT.class;
+ 	}
+ 
+ 	public boolean equals(Object x, Object y) {
+ 		if (x==y) return true;
+ 		if (x==null || y==null) return false;
+ 		return x.toString().equals(y.toString());
+ 	}
+ 
+ 	public Object deepCopy(Object x) {
+ 		if (x==null) return null;
+ 		UDT result = new UDT(x.toString());
+ 		return result;
+ 	}
+ 
+ 	public boolean isMutable() {
+     return false;
+   }
+ 
+ 	public Object nullSafeGet(ResultSet rs,	String[] names,	Object owner)
+ 	throws HibernateException, SQLException {
+ 
+ 		String value = (String) Hibernate.STRING.nullSafeGet(rs, names[0]);
+ 
+ 		return ( value==null ) ? null : new UDT(value);
+ 	}
+ 
+ 	public void nullSafeSet(PreparedStatement st, Object value, int index)
+ 	throws HibernateException, SQLException {
+ 
+ 		UDT udt = (value==null) ? null : (UDT) value;
+ 
+ 		Hibernate.STRING.nullSafeSet(st, udt.toString(), index);
+ 	}
+ 
+   public String getPlaceHolder() {
+     return "UDT(CAST (? AS CHAR(10)))";
+   }
+ }
Index: hibernate-2.0/src/net/sf/hibernate/type/AbstractType.java
diff -c hibernate-2.0/src/net/sf/hibernate/type/AbstractType.java:1.1.1.2 hibernate-2.0/src/net/sf/hibernate/type/AbstractType.java:1.4
*** hibernate-2.0/src/net/sf/hibernate/type/AbstractType.java:1.1.1.2	Tue Apr 22 14:28:26 2003
--- hibernate-2.0/src/net/sf/hibernate/type/AbstractType.java	Tue Apr 29 09:30:25 2003
***************
*** 1,4 ****
! //$Id: AbstractType.java,v 1.1.1.2 2003/04/22 19:28:26 paulsenj Exp $
  package net.sf.hibernate.type;
  
  import java.io.Serializable;
--- 1,4 ----
! //$Id: AbstractType.java,v 1.4 2003/04/29 14:30:25 paulsenj Exp $
  package net.sf.hibernate.type;
  
  import java.io.Serializable;
***************
*** 12,38 ****
   * Mapping of the built in Type hierarchy.
   */
  public abstract class AbstractType implements Type {
! 	
  	public boolean isAssociationType() {
  		return false;
  	}
! 	
  	public boolean isPersistentCollectionType() {
  		return false;
  	}
! 	
  	public boolean isComponentType() {
  		return false;
  	}
! 	
  	public boolean isEntityType() {
  		return false;
  	}
! 	
! 	
  	public Serializable disassemble(Object value, SessionImplementor session)
  	throws HibernateException {
! 		
  		if (value==null) {
  			return null;
  		}
--- 12,38 ----
   * Mapping of the built in Type hierarchy.
   */
  public abstract class AbstractType implements Type {
! 
  	public boolean isAssociationType() {
  		return false;
  	}
! 
  	public boolean isPersistentCollectionType() {
  		return false;
  	}
! 
  	public boolean isComponentType() {
  		return false;
  	}
! 
  	public boolean isEntityType() {
  		return false;
  	}
! 
! 
  	public Serializable disassemble(Object value, SessionImplementor session)
  	throws HibernateException {
! 
  		if (value==null) {
  			return null;
  		}
***************
*** 40,46 ****
  			return (Serializable) deepCopy(value);
  		}
  	}
! 	
  	public Object assemble(Serializable cached, SessionImplementor session, Object owner) throws HibernateException {
  		if ( cached==null ) {
  			return null;
--- 40,46 ----
  			return (Serializable) deepCopy(value);
  		}
  	}
! 
  	public Object assemble(Serializable cached, SessionImplementor session, Object owner) throws HibernateException {
  		if ( cached==null ) {
  			return null;
***************
*** 49,83 ****
  			return deepCopy(cached);
  		}
  	}
! 	
  	public boolean isDirty(Object old, Object current, SessionImplementor session) throws HibernateException {
  		return !equals(old, current);
  	}
! 	
  	public Object hydrate(
  		ResultSet rs,
  		String[] names,
  		SessionImplementor session,
  		Object owner)
  	throws HibernateException, SQLException {
! 			
  		return nullSafeGet(rs, names, session, owner);
  	}
! 		
  	public Object resolveIdentifier(Object value, SessionImplementor session, Object owner)
  	throws HibernateException {
  		return value;
  	}
! 		
  
  	public boolean isObjectType() {
  		return false;
  	}
  
  }
! 	
! 	
! 	
! 	
! 	
! 	
--- 49,91 ----
  			return deepCopy(cached);
  		}
  	}
! 
  	public boolean isDirty(Object old, Object current, SessionImplementor session) throws HibernateException {
  		return !equals(old, current);
  	}
! 
  	public Object hydrate(
  		ResultSet rs,
  		String[] names,
  		SessionImplementor session,
  		Object owner)
  	throws HibernateException, SQLException {
! 
  		return nullSafeGet(rs, names, session, owner);
  	}
! 
  	public Object resolveIdentifier(Object value, SessionImplementor session, Object owner)
  	throws HibernateException {
  		return value;
  	}
! 
  
  	public boolean isObjectType() {
  		return false;
  	}
  
+ 
+ 	/**
+ 	 * Return "?" for place holder.
+ 	 */
+   public String getPlaceHolder() {
+     return "?";
+   }
+ 
  }
! 
! 
! 
! 
! 
! 
Index: hibernate-2.0/src/net/sf/hibernate/type/CustomType.java
diff -c hibernate-2.0/src/net/sf/hibernate/type/CustomType.java:1.1.1.2 hibernate-2.0/src/net/sf/hibernate/type/CustomType.java:1.4
*** hibernate-2.0/src/net/sf/hibernate/type/CustomType.java:1.1.1.2	Tue Apr 22 14:28:26 2003
--- hibernate-2.0/src/net/sf/hibernate/type/CustomType.java	Tue Apr 29 09:30:25 2003
***************
*** 1,4 ****
! //$Id: CustomType.java,v 1.1.1.2 2003/04/22 19:28:26 paulsenj Exp $
  package net.sf.hibernate.type;
  
  import java.io.Serializable;
--- 1,4 ----
! //$Id: CustomType.java,v 1.4 2003/04/29 14:30:25 paulsenj Exp $
  package net.sf.hibernate.type;
  
  import java.io.Serializable;
***************
*** 22,38 ****
   */
  
  public class CustomType extends AbstractType {
! 	
  	private final UserType userType;
  	private final String name;
  	private final int[] types;
! 	
  	protected UserType getUserType() {
  		return userType;
  	}
! 	
  	public CustomType(Class userTypeClass) throws MappingException {
! 		
  		name = userTypeClass.getName();
  
  		try {
--- 22,38 ----
   */
  
  public class CustomType extends AbstractType {
! 
  	private final UserType userType;
  	private final String name;
  	private final int[] types;
! 
  	protected UserType getUserType() {
  		return userType;
  	}
! 
  	public CustomType(Class userTypeClass) throws MappingException {
! 
  		name = userTypeClass.getName();
  
  		try {
***************
*** 52,88 ****
  		if ( !Serializable.class.isAssignableFrom( userType.returnedClass() ) ) {
  			LogFactory.getLog(CustomType.class).warn("custom type does not implement Serializable: " + userTypeClass);
  		}
! 		
  	}
! 	
  	/**
  	 * @see net.sf.hibernate.type.Type#sqlTypes(Mapping)
  	 */
  	public int[] sqlTypes(Mapping pi) {
  		return types;
  	}
! 	
  	/**
  	 * @see net.sf.hibernate.type.Type#getColumnSpan(Mapping)
  	 */
  	public int getColumnSpan(Mapping session) {
  		return types.length;
  	}
! 	
  	/**
  	 * @see net.sf.hibernate.type.Type#returnedClass()
  	 */
  	public Class getReturnedClass() {
  		return userType.returnedClass();
  	}
! 	
  	/**
  	 * @see net.sf.hibernate.type.Type#equals(Object, Object)
  	 */
  	public boolean equals(Object x, Object y) throws HibernateException {
  		return userType.equals(x, y);
  	}
! 	
  	/**
  	 * @see net.sf.hibernate.type.Type#nullSafeGet(ResultSet, String[], SessionImplementor, Object)
  	 */
--- 52,88 ----
  		if ( !Serializable.class.isAssignableFrom( userType.returnedClass() ) ) {
  			LogFactory.getLog(CustomType.class).warn("custom type does not implement Serializable: " + userTypeClass);
  		}
! 
  	}
! 
  	/**
  	 * @see net.sf.hibernate.type.Type#sqlTypes(Mapping)
  	 */
  	public int[] sqlTypes(Mapping pi) {
  		return types;
  	}
! 
  	/**
  	 * @see net.sf.hibernate.type.Type#getColumnSpan(Mapping)
  	 */
  	public int getColumnSpan(Mapping session) {
  		return types.length;
  	}
! 
  	/**
  	 * @see net.sf.hibernate.type.Type#returnedClass()
  	 */
  	public Class getReturnedClass() {
  		return userType.returnedClass();
  	}
! 
  	/**
  	 * @see net.sf.hibernate.type.Type#equals(Object, Object)
  	 */
  	public boolean equals(Object x, Object y) throws HibernateException {
  		return userType.equals(x, y);
  	}
! 
  	/**
  	 * @see net.sf.hibernate.type.Type#nullSafeGet(ResultSet, String[], SessionImplementor, Object)
  	 */
***************
*** 92,101 ****
  		SessionImplementor session,
  		Object owner
  	) throws HibernateException, SQLException {
! 			
  		return userType.nullSafeGet(rs, names, owner);
  	}
! 	
  	/**
  	 * @see net.sf.hibernate.type.Type#nullSafeGet(ResultSet, String, SessionImplementor, Object)
  	 */
--- 92,101 ----
  		SessionImplementor session,
  		Object owner
  	) throws HibernateException, SQLException {
! 
  		return userType.nullSafeGet(rs, names, owner);
  	}
! 
  	/**
  	 * @see net.sf.hibernate.type.Type#nullSafeGet(ResultSet, String, SessionImplementor, Object)
  	 */
***************
*** 105,114 ****
  		SessionImplementor session,
  		Object owner
  	) throws HibernateException, SQLException {
! 			
  		return nullSafeGet(rs, new String[] { name }, session, owner);
  	}
! 	
  	/**
  	 * @see net.sf.hibernate.type.Type#nullSafeSet(PreparedStatement, Object, int, SessionImplementor)
  	 */
--- 105,114 ----
  		SessionImplementor session,
  		Object owner
  	) throws HibernateException, SQLException {
! 
  		return nullSafeGet(rs, new String[] { name }, session, owner);
  	}
! 
  	/**
  	 * @see net.sf.hibernate.type.Type#nullSafeSet(PreparedStatement, Object, int, SessionImplementor)
  	 */
***************
*** 118,159 ****
  		int index,
  		SessionImplementor session
  	) throws HibernateException, SQLException {
! 			
  			userType.nullSafeSet(st, value, index);
  	}
! 	
  	/**
  	 * @see net.sf.hibernate.type.Type#toXML(Object, SessionFactoryImplementor)
  	 */
  	public String toXML(Object value, SessionFactoryImplementor factory) {
  		return value.toString();
  	}
! 	
  	/**
  	 * @see net.sf.hibernate.type.Type#getName()
  	 */
  	public String getName() {
  		return name;
  	}
! 	
  	/**
  	 * @see net.sf.hibernate.type.Type#deepCopy(Object)
  	 */
  	public Object deepCopy(Object value) throws HibernateException {
  		return userType.deepCopy(value);
  	}
! 	
  	/**
  	 * @see net.sf.hibernate.type.Type#isMutable()
  	 */
  	public boolean isMutable() {
  		return userType.isMutable();
  	}
! 	
  	public boolean hasNiceEquals() {
  		return false;
  	}
! 	
  }
  
  
--- 118,169 ----
  		int index,
  		SessionImplementor session
  	) throws HibernateException, SQLException {
! 
  			userType.nullSafeSet(st, value, index);
  	}
! 
  	/**
  	 * @see net.sf.hibernate.type.Type#toXML(Object, SessionFactoryImplementor)
  	 */
  	public String toXML(Object value, SessionFactoryImplementor factory) {
  		return value.toString();
  	}
! 
  	/**
  	 * @see net.sf.hibernate.type.Type#getName()
  	 */
  	public String getName() {
  		return name;
  	}
! 
  	/**
  	 * @see net.sf.hibernate.type.Type#deepCopy(Object)
  	 */
  	public Object deepCopy(Object value) throws HibernateException {
  		return userType.deepCopy(value);
  	}
! 
  	/**
  	 * @see net.sf.hibernate.type.Type#isMutable()
  	 */
  	public boolean isMutable() {
  		return userType.isMutable();
  	}
! 
  	public boolean hasNiceEquals() {
  		return false;
  	}
! 
! 	/**
! 	 * Return customized placeholder for sql statements.
! 	 */
!   public String getPlaceHolder() {
!     if (userType instanceof CustomizablePlaceHolderType)
!       return ((CustomizablePlaceHolderType) userType).getPlaceHolder();
!     else
!       return "?";
!   }
! 
  }
  
  
Index: hibernate-2.0/src/net/sf/hibernate/type/CustomizablePlaceHolderType.java
diff -c /dev/null hibernate-2.0/src/net/sf/hibernate/type/CustomizablePlaceHolderType.java:1.1
*** /dev/null	Wed Apr 30 16:03:14 2003
--- hibernate-2.0/src/net/sf/hibernate/type/CustomizablePlaceHolderType.java	Tue Apr 29 09:30:25 2003
***************
*** 0 ****
--- 1,12 ----
+ package net.sf.hibernate.type;
+ 
+ 
+ /**
+  * This interface should be implemented by user-defined "types"
+  * that need to specify a custom place holder for sql statements.
+  */
+ public interface CustomizablePlaceHolderType {
+ 
+   public String getPlaceHolder();
+ 
+ }
Index: hibernate-2.0/src/net/sf/hibernate/type/Type.java
diff -c hibernate-2.0/src/net/sf/hibernate/type/Type.java:1.1.1.2 hibernate-2.0/src/net/sf/hibernate/type/Type.java:1.4
*** hibernate-2.0/src/net/sf/hibernate/type/Type.java:1.1.1.2	Tue Apr 22 14:28:26 2003
--- hibernate-2.0/src/net/sf/hibernate/type/Type.java	Tue Apr 29 09:30:25 2003
***************
*** 1,4 ****
! //$Id: Type.java,v 1.1.1.2 2003/04/22 19:28:26 paulsenj Exp $
  package net.sf.hibernate.type;
  
  import java.io.Serializable;
--- 1,4 ----
! //$Id: Type.java,v 1.4 2003/04/29 14:30:25 paulsenj Exp $
  package net.sf.hibernate.type;
  
  import java.io.Serializable;
***************
*** 19,25 ****
   * Implementors should usually be immutable and <b>must</b> definately be threadsafe.
   */
  public interface Type extends Serializable {
! 	
  	/**
  	 * Return true if the implementation is castable to
  	 * <tt>AssociationType</tt>. This does not necessarily imply that
--- 19,25 ----
   * Implementors should usually be immutable and <b>must</b> definately be threadsafe.
   */
  public interface Type extends Serializable {
! 
  	/**
  	 * Return true if the implementation is castable to
  	 * <tt>AssociationType</tt>. This does not necessarily imply that
***************
*** 33,39 ****
  	 * @return boolean
  	 */
  	public boolean isPersistentCollectionType();
! 	
  	/**
  	 * Is this type a component type? If so, the implementation
  	 * must be castable to <tt>AbstractComponentType</tt>. A component
--- 33,39 ----
  	 * @return boolean
  	 */
  	public boolean isPersistentCollectionType();
! 
  	/**
  	 * Is this type a component type? If so, the implementation
  	 * must be castable to <tt>AbstractComponentType</tt>. A component
***************
*** 43,65 ****
  	 * @return boolean
  	 */
  	public boolean isComponentType();
! 	
  	/**
  	 * Is this type an entity type?
  	 * @return boolean
  	 */
  	public boolean isEntityType();
! 	
  	/**
  	 * Is this an "object" type, ie. a reference to a persistent entity
  	 * that is not modelled as a (foreign key) association.
! 	 * 
  	 * @param mapping
  	 * @return int[]
  	 * @throws MappingException
  	 */
  	public boolean isObjectType();
! 	
  	/**
  	 * Return the SQL type codes for the columns mapped by this type. The codes
  	 * are defined on <tt>java.sql.Types</tt>.
--- 43,65 ----
  	 * @return boolean
  	 */
  	public boolean isComponentType();
! 
  	/**
  	 * Is this type an entity type?
  	 * @return boolean
  	 */
  	public boolean isEntityType();
! 
  	/**
  	 * Is this an "object" type, ie. a reference to a persistent entity
  	 * that is not modelled as a (foreign key) association.
! 	 *
  	 * @param mapping
  	 * @return int[]
  	 * @throws MappingException
  	 */
  	public boolean isObjectType();
! 
  	/**
  	 * Return the SQL type codes for the columns mapped by this type. The codes
  	 * are defined on <tt>java.sql.Types</tt>.
***************
*** 69,90 ****
  	 * @throws MappingException
  	 */
  	public int[] sqlTypes(Mapping mapping) throws MappingException;
! 	
  	/**
  	 * How many columns are used to persist this type?
  	 * @param session
  	 * @return int
  	 */
  	public int getColumnSpan(Mapping mapping) throws MappingException;
! 	
  	/**
! 	 * The class returned by <tt>nullSafeGet()</tt> methods. This is used to establish 
  	 * the class of an array of this type.
  	 *
  	 * @return Class
  	 */
  	public Class getReturnedClass();
! 	
  	/**
  	 * Compare two instances of the class mapped by this type for persistence
  	 * "equality", ie. Equality of persistent state.
--- 69,90 ----
  	 * @throws MappingException
  	 */
  	public int[] sqlTypes(Mapping mapping) throws MappingException;
! 
  	/**
  	 * How many columns are used to persist this type?
  	 * @param session
  	 * @return int
  	 */
  	public int getColumnSpan(Mapping mapping) throws MappingException;
! 
  	/**
! 	 * The class returned by <tt>nullSafeGet()</tt> methods. This is used to establish
  	 * the class of an array of this type.
  	 *
  	 * @return Class
  	 */
  	public Class getReturnedClass();
! 
  	/**
  	 * Compare two instances of the class mapped by this type for persistence
  	 * "equality", ie. Equality of persistent state.
***************
*** 95,101 ****
  	 * @throws HibernateException
  	 */
  	public boolean equals(Object x, Object y) throws HibernateException;
! 	
  	/**
  	 * Should the parent be considered dirty, given both the old and current field or element value?
  	 * @param old the old value
--- 95,101 ----
  	 * @throws HibernateException
  	 */
  	public boolean equals(Object x, Object y) throws HibernateException;
! 
  	/**
  	 * Should the parent be considered dirty, given both the old and current field or element value?
  	 * @param old the old value
***************
*** 104,110 ****
  	 * @return true if the field is dirty
  	 */
  	public boolean isDirty(Object old, Object current, SessionImplementor session) throws HibernateException;
! 	
  	/**
  	 * Retrieve an instance of the mapped class from a JDBC resultset. Implementors
  	 * should handle possibility of null values.
--- 104,110 ----
  	 * @return true if the field is dirty
  	 */
  	public boolean isDirty(Object old, Object current, SessionImplementor session) throws HibernateException;
! 
  	/**
  	 * Retrieve an instance of the mapped class from a JDBC resultset. Implementors
  	 * should handle possibility of null values.
***************
*** 119,125 ****
  	 * @throws SQLException
  	 */
  	public Object nullSafeGet(ResultSet rs, String[] names, SessionImplementor session, Object owner) throws HibernateException, SQLException;
! 	
  	/**
  	 * Retrieve an instance of the mapped class from a JDBC resultset. Implementations
  	 * should handle possibility of null values. This method might be called if the
--- 119,125 ----
  	 * @throws SQLException
  	 */
  	public Object nullSafeGet(ResultSet rs, String[] names, SessionImplementor session, Object owner) throws HibernateException, SQLException;
! 
  	/**
  	 * Retrieve an instance of the mapped class from a JDBC resultset. Implementations
  	 * should handle possibility of null values. This method might be called if the
***************
*** 134,140 ****
  	 * @throws SQLException
  	 */
  	public Object nullSafeGet(ResultSet rs, String name, SessionImplementor session, Object owner) throws HibernateException, SQLException;
! 	
  	/**
  	 * Write an instance of the mapped class to a prepared statement. Implementors
  	 * should handle possibility of null values. A multi-column type should be written
--- 134,140 ----
  	 * @throws SQLException
  	 */
  	public Object nullSafeGet(ResultSet rs, String name, SessionImplementor session, Object owner) throws HibernateException, SQLException;
! 
  	/**
  	 * Write an instance of the mapped class to a prepared statement. Implementors
  	 * should handle possibility of null values. A multi-column type should be written
***************
*** 148,154 ****
  	 * @throws SQLException
  	 */
  	public void nullSafeSet(PreparedStatement st, Object value, int index, SessionImplementor session) throws HibernateException, SQLException;
! 	
  	/**
  	 * A representation of the value to be embedded in an XML element.
  	 *
--- 148,154 ----
  	 * @throws SQLException
  	 */
  	public void nullSafeSet(PreparedStatement st, Object value, int index, SessionImplementor session) throws HibernateException, SQLException;
! 
  	/**
  	 * A representation of the value to be embedded in an XML element.
  	 *
***************
*** 158,171 ****
  	 * @throws HibernateException
  	 */
  	public String toXML(Object value, SessionFactoryImplementor factory) throws HibernateException;
! 	
  	/**
  	 * Returns the abbreviated name of the type.
  	 *
  	 * @return String the Hibernate type name
  	 */
  	public String getName();
! 	
  	/**
  	 * Return a deep copy of the persistent state, stopping at entities and at
  	 * collections.
--- 158,171 ----
  	 * @throws HibernateException
  	 */
  	public String toXML(Object value, SessionFactoryImplementor factory) throws HibernateException;
! 
  	/**
  	 * Returns the abbreviated name of the type.
  	 *
  	 * @return String the Hibernate type name
  	 */
  	public String getName();
! 
  	/**
  	 * Return a deep copy of the persistent state, stopping at entities and at
  	 * collections.
***************
*** 175,181 ****
  	 * @return Object a copy
  	 */
  	public Object deepCopy(Object value) throws HibernateException;
! 	
  	/**
  	 * Are objects of this type mutable? (With respect to the referencing object ...
  	 * entities and collections are considered immutable because they manage their
--- 175,181 ----
  	 * @return Object a copy
  	 */
  	public Object deepCopy(Object value) throws HibernateException;
! 
  	/**
  	 * Are objects of this type mutable? (With respect to the referencing object ...
  	 * entities and collections are considered immutable because they manage their
***************
*** 184,190 ****
  	 * @return boolean
  	 */
  	public boolean isMutable();
! 	
  	/**
  	 * Return a cacheable "disassembled" representation of the object.
  	 * @param value the value to cache
--- 184,190 ----
  	 * @return boolean
  	 */
  	public boolean isMutable();
! 
  	/**
  	 * Return a cacheable "disassembled" representation of the object.
  	 * @param value the value to cache
***************
*** 192,198 ****
  	 * @return the disassembled, deep cloned state
  	 */
  	public Serializable disassemble(Object value, SessionImplementor session) throws HibernateException;
! 	
  	/**
  	 * Reconstruct the object from its cached "disassembled" state.
  	 * @param cached the disassembled state from the cache
--- 192,198 ----
  	 * @return the disassembled, deep cloned state
  	 */
  	public Serializable disassemble(Object value, SessionImplementor session) throws HibernateException;
! 
  	/**
  	 * Reconstruct the object from its cached "disassembled" state.
  	 * @param cached the disassembled state from the cache
***************
*** 201,207 ****
  	 * @return the the object
  	 */
  	public Object assemble(Serializable cached, SessionImplementor session, Object owner) throws HibernateException;
! 	
  	/**
  	 * Does this type implement a well-behaved <tt>equals()</tt> method?
  	 * (ie. one that is consistent with <tt>Type.equals()</tt>.) Strictly,
--- 201,207 ----
  	 * @return the the object
  	 */
  	public Object assemble(Serializable cached, SessionImplementor session, Object owner) throws HibernateException;
! 
  	/**
  	 * Does this type implement a well-behaved <tt>equals()</tt> method?
  	 * (ie. one that is consistent with <tt>Type.equals()</tt>.) Strictly,
***************
*** 212,218 ****
  	 * @see Type#equals(java.lang.Object, java.lang.Object)
  	 */
  	public boolean hasNiceEquals();
! 	
  	/**
  	 * Retrieve an instance of the mapped class, or the identifier of an entity or collection, from a JDBC resultset.
  	 * This is useful for 2-phase property initialization - the second phase is a call to <tt>resolveIdentifier()</tt>.
--- 212,218 ----
  	 * @see Type#equals(java.lang.Object, java.lang.Object)
  	 */
  	public boolean hasNiceEquals();
! 
  	/**
  	 * Retrieve an instance of the mapped class, or the identifier of an entity or collection, from a JDBC resultset.
  	 * This is useful for 2-phase property initialization - the second phase is a call to <tt>resolveIdentifier()</tt>.
***************
*** 226,232 ****
  	 * @throws SQLException
  	 */
  	public Object hydrate(ResultSet rs, String[] names, SessionImplementor session, Object owner) throws HibernateException, SQLException;
! 	
  	/**
  	 * Map identifiers to entities or collections. This is the second phase of 2-phase property initialization.
  	 * @see Type#hydrate(ResultSet, String[], SessionImplementor, Object)
--- 226,232 ----
  	 * @throws SQLException
  	 */
  	public Object hydrate(ResultSet rs, String[] names, SessionImplementor session, Object owner) throws HibernateException, SQLException;
! 
  	/**
  	 * Map identifiers to entities or collections. This is the second phase of 2-phase property initialization.
  	 * @see Type#hydrate(ResultSet, String[], SessionImplementor, Object)
***************
*** 238,243 ****
--- 238,245 ----
  	 * @throws SQLException
  	 */
  	public Object resolveIdentifier(Object value, SessionImplementor session, Object owner) throws HibernateException;
+ 
+   public String getPlaceHolder();
  }
  
  
Index: hibernate-2.0/src/net/sf/hibernate/util/TypeHelper.java
diff -c /dev/null hibernate-2.0/src/net/sf/hibernate/util/TypeHelper.java:1.2
*** /dev/null	Wed Apr 30 16:03:14 2003
--- hibernate-2.0/src/net/sf/hibernate/util/TypeHelper.java	Tue Apr 29 09:30:25 2003
***************
*** 0 ****
--- 1,35 ----
+ package net.sf.hibernate.util;
+ 
+ import net.sf.hibernate.type.Type;
+ 
+ /**
+  * Helper methods for hibernate type objects.
+  */
+ public class TypeHelper {
+   /**
+    * Return array of placeholder strings for array of types.
+    * @param types
+    * @return String[]
+    */
+   public static String[] getPlaceHolders(Type[] types) {
+     if (types == null)
+       return null;
+     String[] placeHolders = new String[types.length];
+     for (int i = 0; i < types.length; i++)
+       placeHolders[i] = types[i].getPlaceHolder();
+     return placeHolders;
+   }
+ 
+   /**
+    * Append two type arrays into one array
+    * @param x
+    * @param y
+    * @return Type[]
+    */
+   public static Type[] join(Type[] x, Type[] y) {
+ 		Type[] result = new Type[ x.length + y.length ];
+ 		for ( int i=0; i<x.length; i++ ) result[i] = x[i];
+ 		for ( int i=0; i<y.length; i++ ) result[i+x.length] = y[i];
+ 		return result;
+ 	}
+ }
